<!doctype html>
<html lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
  <title>libMesh - A C++ Finite Element Library</title>
  <meta name="author" content="libMesh development team">
  <link rel="stylesheet" type="text/css" media="all" href="../styles.css">
  <link rel="stylesheet" type="text/css" media="all" href="../doxygen_stylesheet.css">
</head>

<body>
  <nav id="fixedbar">
    <ul id="fixednav">
      <li><a href="../index.html">Home</a></li>
      <li><a href="../support.html">About Us</a></li>
      <li><a href="../publications.html">Publications</a></li>
      <li><a href="https://github.com/libMesh/libmesh/graphs/contributors">Developers</a></li>
      <li><a href="../installation.html">Installation</a></li>
      <li><a href="../examples.html">Examples</a></li>
     <li><a href="../doxygen/index.html">Documentation</a></li>
    </ul>
  </nav>

  <div id="w">
    <header id="logo"><a href="../index.html"><span id="logobg">SomeWebsiteLogo</span></a></header>

    <nav id="navigation">
      <ul>
        <li><a href="../index.html">Home</a></li>
        <li><a href="../support.html">About Us</a></li>
        <li><a href="../publications.html">Publications</a></li>
        <li><a href="https://github.com/libMesh/libmesh/graphs/contributors">Developers</a></li>
        <li><a href="../installation.html">Installation</a></li>
        <li><a href="../examples.html">Examples</a></li>
        <li><a href="../doxygen/index.html">Documentation</a></li>
      </ul>
    </nav>

<div id="content">

<a name="comments"></a>
<br><br><br> <h1> The source file augment_sparsity_on_contact.h with comments: </h1>
<div class = "comment">
</div>

<div class ="fragment">
<pre>
        #ifndef AUGMENT_SPARSITY_ON_CONTACT_H
        #define AUGMENT_SPARSITY_ON_CONTACT_H

        #include "libmesh/dof_map.h"
        #include "libmesh/system.h"
        #include LIBMESH_INCLUDE_UNORDERED_MAP

        using libMesh::DofMap;
        using libMesh::System;
        using libMesh::Node;
        using libMesh::dof_id_type;
        using libMesh::boundary_id_type;

        class AugmentSparsityOnContact : public DofMap::AugmentSparsityPattern
        {
        public:

          /**
           * Constructor.
           */
          AugmentSparsityOnContact(System & _sys);

          /**
           * Clear the contact element map.
           */
          void clear_contact_node_map();

          /**
           * Add a new entry to _contact_node_map.
           */
          void add_contact_node(dof_id_type lower_node_id,
                                dof_id_type upper_node_id);

          /**
           * User-defined function to augment the sparsity pattern.
           */
          virtual void augment_sparsity_pattern (libMesh::SparsityPattern::Graph &,
                                                 std::vector&lt;dof_id_type&gt; & n_nz,
                                                 std::vector&lt;dof_id_type&gt; & n_oz);

          /**
           * Helper function that actually sets the sparsity values.
           */
          void set_sparsity_values(const Node & this_node,
                                   const Node & other_node,
                                   std::vector&lt;dof_id_type&gt; & n_nz,
                                   std::vector&lt;dof_id_type&gt; & n_oz);

          /**
           * The System object that we're using here.
           */
          System & _sys;

          /**
           * This provides a map between contact nodes.
           */
          LIBMESH_BEST_UNORDERED_MAP&lt;dof_id_type, dof_id_type&gt; _contact_node_map;
        };

        #endif
</pre>
</div>

<a name="comments"></a>
<br><br><br> <h1> The source file linear_elasticity_with_contact.h with comments: </h1>
<div class = "comment">
</div>

<div class ="fragment">
<pre>
        #ifndef LINEAR_ELASTICITY_WITH_CONTACT_H
        #define LINEAR_ELASTICITY_WITH_CONTACT_H

        #include "libmesh/dof_map.h"
        #include "libmesh/nonlinear_implicit_system.h"
        #include "augment_sparsity_on_contact.h"

</pre>
</div>
<div class = "comment">
define the subdomain IDs
</div>

<div class ="fragment">
<pre>
        #define TOP_SUBDOMAIN 2
        #define BOTTOM_SUBDOMAIN 1

</pre>
</div>
<div class = "comment">
define the boundary IDs in the mesh
</div>

<div class ="fragment">
<pre>
        #define MIN_Z_BOUNDARY 1
        #define MAX_Z_BOUNDARY 2
        #define CONTACT_BOUNDARY_LOWER 3
        #define CONTACT_BOUNDARY_UPPER 4

        using libMesh::DofMap;
        using libMesh::NonlinearImplicitSystem;
        using libMesh::dof_id_type;
        using libMesh::Point;
        using libMesh::Real;
        using libMesh::Number;
        using libMesh::MeshBase;
        using libMesh::NumericVector;
        using libMesh::SparseMatrix;

        /**
         * This class encapsulate all functionality required for assembling
         * and solving a linear elastic model with contact.
         */
        class LinearElasticityWithContact :
          public NonlinearImplicitSystem::ComputeResidualandJacobian
        {
        private:

          /**
           * Keep a reference to the NonlinearImplicitSystem.
           */
          NonlinearImplicitSystem & _sys;

          /**
           * The object that handles augmenting the sparsity pattern.
           */
          AugmentSparsityOnContact _augment_sparsity;

          /**
           * Penalize overlapping elements.
           */
          Real _contact_penalty;

          /**
           * Store the intermediate values of lambda plus penalty. The dof IDs refer
           * to the nodes on the upper contact surface.
           */
          std::map&lt;dof_id_type, Real&gt; _lambda_plus_penalty_values;

          /**
           * Augmented Lagrangian values at each contact node. The dof IDs refer
           * to the nodes on the upper contact surface.
           */
          std::map&lt;dof_id_type, Real&gt; _lambdas;

        public:

          /**
           * Constructor.
           */
          LinearElasticityWithContact(NonlinearImplicitSystem & sys_in,
                                      Real contact_penalty_in);

          /**
           * @return a reference to the object for augmenting the sparsity pattern.
           */
          AugmentSparsityOnContact & get_augment_sparsity();

          /**
           * Update the penalty parameter.
           */
          void set_contact_penalty(Real contact_penalty_in);

          /**
           * Get the penalty parameter.
           */
          Real get_contact_penalty() const;

          /**
           * Kronecker delta function.
           */
          Real kronecker_delta(unsigned int i,
                               unsigned int j);

          /**
           * Evaluate the fourth order tensor (C_ijkl) that relates stress to strain.
           */
          Real elasticity_tensor(Real young_modulus,
                                 Real poisson_ratio,
                                 unsigned int i,
                                 unsigned int j,
                                 unsigned int k,
                                 unsigned int l);

          /**
           * Move the mesh nodes of \p input_mesh based on the displacement field
           * in \p input_solution.
           */
          void move_mesh(MeshBase & input_mesh,
                         const NumericVector&lt;Number&gt; & input_solution);

          /**
           * Set up the load paths on the contact surfaces.
           */
          void initialize_contact_load_paths();

          /**
           * Evaluate the Jacobian of the nonlinear system.
           */
          virtual void residual_and_jacobian (const NumericVector&lt;Number&gt; & soln,
                                              NumericVector&lt;Number&gt; * residual,
                                              SparseMatrix&lt;Number&gt; * jacobian,
                                              NonlinearImplicitSystem & /*sys*/);

          /**
           * Compute the Cauchy stress for the current solution.
           */
          void compute_stresses();

          /**
           * Update the lambda parameters in the augmented Lagrangian
           * method.
           * @return the largest change in the lambdas, and the largest
           * lambda value.
           */
          std::pair&lt;Real, Real&gt; update_lambdas();

          /**
           * @return the least and max gap function values for the current solution.
           */
          std::pair&lt;Real, Real&gt; get_least_and_max_gap_function();
        };

        #endif
</pre>
</div>

<a name="comments"></a>
<br><br><br> <h1> The source file augment_sparsity_on_contact.C with comments: </h1>
<div class = "comment">
</div>

<div class ="fragment">
<pre>
        #include "augment_sparsity_on_contact.h"

</pre>
</div>
<div class = "comment">
libMesh includes
</div>

<div class ="fragment">
<pre>
        #include "libmesh/linear_implicit_system.h"
        #include LIBMESH_INCLUDE_UNORDERED_SET
        #include "libmesh/elem.h"

        using namespace libMesh;

        AugmentSparsityOnContact::AugmentSparsityOnContact(System & sys) :
          _sys(sys)
        {}

        void AugmentSparsityOnContact::clear_contact_node_map()
        {
          _contact_node_map.clear();
        }

        void AugmentSparsityOnContact::add_contact_node(dof_id_type lower_node_id,
                                                        dof_id_type upper_node_id)
        {
          _contact_node_map[lower_node_id] = upper_node_id;
        }

        void AugmentSparsityOnContact::augment_sparsity_pattern(SparsityPattern::Graph &,
                                                                std::vector&lt;dof_id_type&gt; & n_nz,
                                                                std::vector&lt;dof_id_type&gt; & n_oz)
        {
</pre>
</div>
<div class = "comment">
get a constant reference to the mesh object
</div>

<div class ="fragment">
<pre>
          const MeshBase & mesh = _sys.get_mesh();

          LIBMESH_BEST_UNORDERED_MAP&lt;dof_id_type, dof_id_type&gt;::iterator it     = _contact_node_map.begin();
          LIBMESH_BEST_UNORDERED_MAP&lt;dof_id_type, dof_id_type&gt;::iterator it_end = _contact_node_map.end();

          for ( ; it != it_end; ++it)
            {
              const Node & this_node = mesh.node(it-&gt;first);
              const Node & other_node = mesh.node(it-&gt;second);

              set_sparsity_values(this_node, other_node, n_nz, n_oz);
              set_sparsity_values(other_node, this_node, n_nz, n_oz);
            }
        }

        void AugmentSparsityOnContact::set_sparsity_values(const Node & this_node,
                                                           const Node & other_node,
                                                           std::vector&lt;dof_id_type&gt; & n_nz,
                                                           std::vector&lt;dof_id_type&gt; & n_oz)
        {
          const DofMap & dof_map = _sys.get_dof_map();

          for (unsigned int var_i=0; var_i&lt;3; var_i++)
            {
              dof_id_type dof_index_on_this_node =
                this_node.dof_number(_sys.number(), var_i, 0);

              unsigned int n_local_coupled_dofs = 0;
              unsigned int n_remote_coupled_dofs = 0;

              for (unsigned int var_j=0; var_j&lt;3; var_j++)
                {
                  dof_id_type dof_index_on_other_node =
                    other_node.dof_number(_sys.number(), var_j, 0);

                  if ((dof_index_on_other_node &gt;= dof_map.first_dof()) &&
                      (dof_index_on_other_node  &lt; dof_map.end_dof()))
                    n_local_coupled_dofs++;
                  else
                    n_remote_coupled_dofs++;
                }

</pre>
</div>
<div class = "comment">
only monkey with the sparsity pattern for local dofs!
</div>

<div class ="fragment">
<pre>
              if ((dof_index_on_this_node &gt;= dof_map.first_dof()) &&
                  (dof_index_on_this_node  &lt; dof_map.end_dof()))
                {
                  const unsigned int
                    dof_offset = dof_index_on_this_node - dof_map.first_dof();

                  libmesh_assert_less (dof_offset, n_nz.size());
                  libmesh_assert_less (dof_offset, n_oz.size());

                  n_nz[dof_offset] += n_local_coupled_dofs;
                  n_oz[dof_offset] += n_remote_coupled_dofs;
                }
            }
        }
</pre>
</div>

<a name="comments"></a>
<br><br><br> <h1> The source file linear_elasticity_with_contact.C with comments: </h1>
<div class = "comment">
</div>

<div class ="fragment">
<pre>
        #include "linear_elasticity_with_contact.h"

</pre>
</div>
<div class = "comment">
C++ include files that we need
</div>

<div class ="fragment">
<pre>
        #include &lt;iostream&gt;
        #include &lt;algorithm&gt;
        #include &lt;cmath&gt;

</pre>
</div>
<div class = "comment">
Various include files needed for the mesh & solver functionality.
</div>

<div class ="fragment">
<pre>
        #include "libmesh/libmesh.h"
        #include "libmesh/mesh.h"
        #include "libmesh/equation_systems.h"
        #include "libmesh/fe.h"
        #include "libmesh/quadrature_gauss.h"
        #include "libmesh/dof_map.h"
        #include "libmesh/sparse_matrix.h"
        #include "libmesh/numeric_vector.h"
        #include "libmesh/dense_matrix.h"
        #include "libmesh/dense_vector.h"
        #include "libmesh/elem.h"
        #include "libmesh/fe_interface.h"
        #include "libmesh/fe_compute_data.h"
        #include "libmesh/petsc_matrix.h"
        #include LIBMESH_INCLUDE_UNORDERED_SET

</pre>
</div>
<div class = "comment">
The nonlinear solver and system we will be using
</div>

<div class ="fragment">
<pre>
        #include "libmesh/nonlinear_solver.h"
        #include "libmesh/nonlinear_implicit_system.h"

        using namespace libMesh;

        LinearElasticityWithContact::LinearElasticityWithContact (NonlinearImplicitSystem & sys_in,
                                                                  Real contact_penalty_in) :
          _sys(sys_in),
          _augment_sparsity(_sys),
          _contact_penalty(contact_penalty_in)
        {
        }

        AugmentSparsityOnContact & LinearElasticityWithContact::get_augment_sparsity()
        {
          return _augment_sparsity;
        }

        void LinearElasticityWithContact::set_contact_penalty(Real contact_penalty_in)
        {
          _contact_penalty = contact_penalty_in;
        }

        Real LinearElasticityWithContact::get_contact_penalty() const
        {
          return _contact_penalty;
        }

        Real LinearElasticityWithContact::kronecker_delta(unsigned int i,
                                                          unsigned int j)
        {
          return i == j ? 1. : 0.;
        }

        Real LinearElasticityWithContact::elasticity_tensor(Real young_modulus,
                                                            Real poisson_ratio,
                                                            unsigned int i,
                                                            unsigned int j,
                                                            unsigned int k,
                                                            unsigned int l)
        {
</pre>
</div>
<div class = "comment">
Define the Lame constants
</div>

<div class ="fragment">
<pre>
          const Real lambda_1 = (young_modulus*poisson_ratio)/((1.+poisson_ratio)*(1.-2.*poisson_ratio));
          const Real lambda_2 = young_modulus/(2.*(1.+poisson_ratio));

          return lambda_1 * kronecker_delta(i, j) * kronecker_delta(k, l) +
            lambda_2 * (kronecker_delta(i, k) * kronecker_delta(j, l) + kronecker_delta(i, l) * kronecker_delta(j, k));
        }

        void LinearElasticityWithContact::move_mesh (MeshBase & input_mesh,
                                                     const NumericVector&lt;Number&gt; & input_solution)
        {
</pre>
</div>
<div class = "comment">
Maintain a set of node ids that we've encountered.
</div>

<div class ="fragment">
<pre>
          LIBMESH_BEST_UNORDERED_SET&lt;dof_id_type&gt; encountered_node_ids;

</pre>
</div>
<div class = "comment">
Localize input_solution so that we have the data to move all
elements (not just elements local to this processor).
</div>

<div class ="fragment">
<pre>
          UniquePtr&lt; NumericVector&lt;Number&gt; &gt; localized_input_solution =
            NumericVector&lt;Number&gt;::build(input_solution.comm());

          localized_input_solution-&gt;init (input_solution.size(), false, SERIAL);
          input_solution.localize(*localized_input_solution);

          MeshBase::const_element_iterator       el     = input_mesh.active_elements_begin();
          const MeshBase::const_element_iterator end_el = input_mesh.active_elements_end();

          for ( ; el != end_el; ++el)
            {
              Elem * elem = *el;
              Elem * orig_elem = _sys.get_mesh().elem(elem-&gt;id());

              for (unsigned int node_id=0; node_id&lt;elem-&gt;n_nodes(); node_id++)
                {
                  Node * node = elem-&gt;get_node(node_id);

                  if (encountered_node_ids.find(node-&gt;id()) != encountered_node_ids.end())
                    continue;

                  encountered_node_ids.insert(node-&gt;id());

                  std::vector&lt;std::string&gt; uvw_names(3);
                  uvw_names[0] = "u";
                  uvw_names[1] = "v";
                  uvw_names[2] = "w";

                  {
                    const Point master_point = elem-&gt;master_point(node_id);

                    Point uvw;
                    for (unsigned int index=0; index&lt;uvw_names.size(); index++)
                      {
                        const unsigned int var = _sys.variable_number(uvw_names[index]);
                        const FEType & fe_type = _sys.get_dof_map().variable_type(var);

                        FEComputeData data (_sys.get_equation_systems(), master_point);

                        FEInterface::compute_data(elem-&gt;dim(),
                                                  fe_type,
                                                  elem,
                                                  data);

                        std::vector&lt;dof_id_type&gt; dof_indices_var;
                        _sys.get_dof_map().dof_indices (orig_elem, dof_indices_var, var);

                        for (unsigned int i=0; i&lt;dof_indices_var.size(); i++)
                          {
                            Number value = (*localized_input_solution)(dof_indices_var[i]) * data.shape[i];

        #ifdef LIBMESH_USE_COMPLEX_NUMBERS
</pre>
</div>
<div class = "comment">
We explicitly store the real part in uvw
</div>

<div class ="fragment">
<pre>
                            uvw(index) += value.real();
        #else
                            uvw(index) += value;
        #endif
                          }
                      }

</pre>
</div>
<div class = "comment">
Update the node's location
</div>

<div class ="fragment">
<pre>
                    *node += uvw;
                  }
                }
            }
        }

        void LinearElasticityWithContact::initialize_contact_load_paths()
        {
          const MeshBase & mesh = _sys.get_mesh();

          std::vector&lt;dof_id_type&gt; nodes_on_lower_surface;
          std::vector&lt;dof_id_type&gt; nodes_on_upper_surface;

          MeshBase::const_element_iterator       el     = mesh.active_elements_begin();
          const MeshBase::const_element_iterator end_el = mesh.active_elements_end();

          _lambdas.clear();
          for ( ; el != end_el; ++el)
            {
              const Elem * elem = *el;

              for (unsigned int side=0; side&lt;elem-&gt;n_sides(); side++)
                {
                  if (elem-&gt;neighbor(side) == libmesh_nullptr)
                    {
                      bool on_lower_contact_surface =
                        mesh.get_boundary_info().has_boundary_id (elem, side, CONTACT_BOUNDARY_LOWER);

                      bool on_upper_contact_surface =
                        mesh.get_boundary_info().has_boundary_id (elem, side, CONTACT_BOUNDARY_UPPER);

                      if (on_lower_contact_surface && on_upper_contact_surface)
                        libmesh_error_msg("Should not be on both surfaces at the same time");

                      if (on_lower_contact_surface || on_upper_contact_surface)
                        {
                          for (unsigned int node_index=0; node_index&lt;elem-&gt;n_nodes(); node_index++)
                            if (elem-&gt;is_node_on_side(node_index, side))
                              {
                                if (on_lower_contact_surface)
                                  nodes_on_lower_surface.push_back(elem-&gt;node(node_index));
                                else
                                  {
                                    _lambdas[elem-&gt;node(node_index)] = 0.;
                                    nodes_on_upper_surface.push_back(elem-&gt;node(node_index));
                                  }
                              }
                        }

                    } // end if nieghbor(side_) != libmesh_nullptr
                } // end for side
            } // end for el

</pre>
</div>
<div class = "comment">
In this example, we expect the number of upper and lower nodes to match
</div>

<div class ="fragment">
<pre>
          libmesh_assert(nodes_on_lower_surface.size() == nodes_on_upper_surface.size());

</pre>
</div>
<div class = "comment">
Do an N^2 search to match the contact nodes
</div>

<div class ="fragment">
<pre>
          _augment_sparsity.clear_contact_node_map();
          for (unsigned int i=0; i&lt;nodes_on_lower_surface.size(); i++)
            {
              dof_id_type lower_node_id = nodes_on_lower_surface[i];
              Point p_lower = mesh.point(lower_node_id);

              Real min_distance = std::numeric_limits&lt;Real&gt;::max();

              for (unsigned int j=0; j&lt;nodes_on_upper_surface.size(); j++)
                {
                  dof_id_type upper_node_id = nodes_on_upper_surface[j];
                  Point p_upper = mesh.point(upper_node_id);

                  Real distance = (p_upper - p_lower).size();

                  if (distance &lt; min_distance)
                    {
                      _augment_sparsity.add_contact_node(lower_node_id, upper_node_id);
                      min_distance = distance;
                    }
                }
            }

        }

        void LinearElasticityWithContact::residual_and_jacobian (const NumericVector&lt;Number&gt; & soln,
                                                                 NumericVector&lt;Number&gt; * residual,
                                                                 SparseMatrix&lt;Number&gt; * jacobian,
                                                                 NonlinearImplicitSystem & /*sys*/)
        {
          EquationSystems & es = _sys.get_equation_systems();
          const Real young_modulus = es.parameters.get&lt;Real&gt;("young_modulus");
          const Real poisson_ratio = es.parameters.get&lt;Real&gt;("poisson_ratio");

          const MeshBase & mesh = _sys.get_mesh();
          const unsigned int dim = mesh.mesh_dimension();

          const unsigned int u_var = _sys.variable_number ("u");

          DofMap & dof_map = _sys.get_dof_map();

          FEType fe_type = dof_map.variable_type(u_var);
          UniquePtr&lt;FEBase&gt; fe (FEBase::build(dim, fe_type));
          QGauss qrule (dim, fe_type.default_quadrature_order());
          fe-&gt;attach_quadrature_rule (&qrule);

          UniquePtr&lt;FEBase&gt; fe_face (FEBase::build(dim, fe_type));
          QGauss qface (dim-1, fe_type.default_quadrature_order());
          fe_face-&gt;attach_quadrature_rule (&qface);

          UniquePtr&lt;FEBase&gt; fe_neighbor_face (FEBase::build(dim, fe_type));
          fe_neighbor_face-&gt;attach_quadrature_rule (&qface);

          const std::vector&lt;Real&gt; & JxW = fe-&gt;get_JxW();
          const std::vector&lt;std::vector&lt;RealGradient&gt; &gt; & dphi = fe-&gt;get_dphi();

          if (jacobian)
            jacobian-&gt;zero();

          if (residual)
            residual-&gt;zero();

</pre>
</div>
<div class = "comment">
Do jacobian and residual assembly, including contact forces
</div>

<div class ="fragment">
<pre>
          DenseVector&lt;Number&gt; Re;

          DenseSubVector&lt;Number&gt; Re_var[3] =
            {DenseSubVector&lt;Number&gt;(Re),
             DenseSubVector&lt;Number&gt;(Re),
             DenseSubVector&lt;Number&gt;(Re)};

          DenseMatrix&lt;Number&gt; Ke;
          DenseSubMatrix&lt;Number&gt; Ke_var[3][3] =
            {
              {DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke)},
              {DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke)},
              {DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke)}
            };

          std::vector&lt;dof_id_type&gt; dof_indices;
          std::vector&lt; std::vector&lt;dof_id_type&gt; &gt; dof_indices_var(3);

          MeshBase::const_element_iterator       el     = mesh.active_local_elements_begin();
          const MeshBase::const_element_iterator end_el = mesh.active_local_elements_end();

          for ( ; el != end_el; ++el)
            {
              const Elem * elem = *el;

              dof_map.dof_indices (elem, dof_indices);
              for (unsigned int var=0; var&lt;3; var++)
                dof_map.dof_indices (elem, dof_indices_var[var], var);

              const unsigned int n_dofs   = dof_indices.size();
              const unsigned int n_var_dofs = dof_indices_var[0].size();

              fe-&gt;reinit (elem);

              Re.resize (n_dofs);
              for (unsigned int var=0; var&lt;3; var++)
                Re_var[var].reposition (var*n_var_dofs, n_var_dofs);

              Ke.resize (n_dofs, n_dofs);
              for (unsigned int var_i=0; var_i&lt;3; var_i++)
                for (unsigned int var_j=0; var_j&lt;3; var_j++)
                  Ke_var[var_i][var_j].reposition (var_i*n_var_dofs, var_j*n_var_dofs, n_var_dofs, n_var_dofs);

              for (unsigned int qp=0; qp&lt;qrule.n_points(); qp++)
                {
</pre>
</div>
<div class = "comment">
Row is variable u, v, or w column is x, y, or z
</div>

<div class ="fragment">
<pre>
                  DenseMatrix&lt;Number&gt; grad_u(3, 3);
                  for (unsigned int var_i=0; var_i&lt;3; var_i++)
                    for (unsigned int var_j=0; var_j&lt;3; var_j++)
                      for (unsigned int j=0; j&lt;n_var_dofs; j++)
                        grad_u(var_i, var_j) += dphi[j][qp](var_j)*soln(dof_indices_var[var_i][j]);

</pre>
</div>
<div class = "comment">
- C_ijkl u_k,l v_i,j
</div>

<div class ="fragment">
<pre>
                  for (unsigned int dof_i=0; dof_i&lt;n_var_dofs; dof_i++)
                    for (unsigned int i=0; i&lt;3; i++)
                      for (unsigned int j=0; j&lt;3; j++)
                        for (unsigned int k=0; k&lt;3; k++)
                          for (unsigned int l=0; l&lt;3; l++)
                            Re_var[i](dof_i) -= JxW[qp] *
                              elasticity_tensor(young_modulus, poisson_ratio, i, j, k, l) * grad_u(k,l) * dphi[dof_i][qp](j);

</pre>
</div>
<div class = "comment">
assemble \int_Omega C_ijkl u_k,l v_i,j \dx
</div>

<div class ="fragment">
<pre>
                  for (unsigned int dof_i=0; dof_i&lt;n_var_dofs; dof_i++)
                    for (unsigned int dof_j=0; dof_j&lt;n_var_dofs; dof_j++)
                      for (unsigned int i=0; i&lt;3; i++)
                        for (unsigned int j=0; j&lt;3; j++)
                          for (unsigned int k=0; k&lt;3; k++)
                            for (unsigned int l=0; l&lt;3; l++)
                              Ke_var[i][k](dof_i, dof_j) -= JxW[qp] *
                                elasticity_tensor(young_modulus, poisson_ratio, i, j, k, l) * dphi[dof_j][qp](l) * dphi[dof_i][qp](j);
                }

              dof_map.constrain_element_matrix_and_vector (Ke, Re, dof_indices);

              if (jacobian)
                jacobian-&gt;add_matrix (Ke, dof_indices);

              if (residual)
                residual-&gt;add_vector (Re, dof_indices);
            }

</pre>
</div>
<div class = "comment">
Move a copy of the mesh based on the solution. This is used to get
the contact forces.
</div>

<div class ="fragment">
<pre>
          UniquePtr&lt;MeshBase&gt; mesh_clone = mesh.clone();
          move_mesh(*mesh_clone, soln);

</pre>
</div>
<div class = "comment">
Add contributions due to contact penalty forces. Only need to do this on
one processor.
</div>

<div class ="fragment">
<pre>
          _lambda_plus_penalty_values.clear();

          LIBMESH_BEST_UNORDERED_MAP&lt;dof_id_type, dof_id_type&gt;::iterator it =
            _augment_sparsity._contact_node_map.begin();
          LIBMESH_BEST_UNORDERED_MAP&lt;dof_id_type, dof_id_type&gt;::iterator it_end =
            _augment_sparsity._contact_node_map.end();

          for ( ; it != it_end; ++it)
            {
              dof_id_type lower_point_id = it-&gt;first;
              dof_id_type upper_point_id = it-&gt;second;

              Point upper_to_lower;
              {
                Point lower_node_moved = mesh_clone-&gt;point(lower_point_id);
                Point upper_node_moved = mesh_clone-&gt;node(upper_point_id);

                upper_to_lower = (lower_node_moved - upper_node_moved);
              }

</pre>
</div>
<div class = "comment">
Set the contact force direction. Usually this would be calculated
separately on each master node, but here we just set it to (0, 0, 1)
everywhere.
</div>

<div class ="fragment">
<pre>
              Point contact_force_direction(0., 0., 1.);

</pre>
</div>
<div class = "comment">
gap_function > 0. means that contact has been detected
gap_function < 0. means that we have a gap
This sign convention matches Simo & Laursen (1992).
</div>

<div class ="fragment">
<pre>
              Real gap_function = upper_to_lower * contact_force_direction;

</pre>
</div>
<div class = "comment">
We use the sign of lambda_plus_penalty to determine whether or
not we need to impose a contact force.
</div>

<div class ="fragment">
<pre>
              Real lambda_plus_penalty =
                (_lambdas[upper_point_id] + gap_function * _contact_penalty);

              if (lambda_plus_penalty &lt; 0.)
                lambda_plus_penalty = 0.;

</pre>
</div>
<div class = "comment">
Store lambda_plus_penalty, we'll need to use it later to update _lambdas
</div>

<div class ="fragment">
<pre>
              _lambda_plus_penalty_values[upper_point_id] = lambda_plus_penalty;

              const Node & lower_node = mesh.node(lower_point_id);
              const Node & upper_node = mesh.node(upper_point_id);

              std::vector&lt;dof_id_type&gt; dof_indices_on_lower_node(3);
              std::vector&lt;dof_id_type&gt; dof_indices_on_upper_node(3);
              DenseVector&lt;Number&gt; lower_contact_force_vec(3);
              DenseVector&lt;Number&gt; upper_contact_force_vec(3);

              for (unsigned int var=0; var&lt;3; var++)
                {
                  dof_indices_on_lower_node[var] = lower_node.dof_number(_sys.number(), var, 0);
                  lower_contact_force_vec(var) = -lambda_plus_penalty * contact_force_direction(var);

                  dof_indices_on_upper_node[var] = upper_node.dof_number(_sys.number(), var, 0);
                  upper_contact_force_vec(var) = lambda_plus_penalty * contact_force_direction(var);
                }

              if (lambda_plus_penalty &gt; 0.)
                {
                  if (residual && (_sys.comm().rank() == 0))
                    {
                      residual-&gt;add_vector (lower_contact_force_vec, dof_indices_on_lower_node);
                      residual-&gt;add_vector (upper_contact_force_vec, dof_indices_on_upper_node);
                    }

</pre>
</div>
<div class = "comment">
Add the Jacobian terms due to the contact forces. The lambda contribution
is not relevant here because it doesn't depend on the solution.
</div>

<div class ="fragment">
<pre>
                  if (jacobian && (_sys.comm().rank() == 0))
                    for (unsigned int var=0; var&lt;3; var++)
                      for (unsigned int j=0; j&lt;3; j++)
                        {
                          jacobian-&gt;add(dof_indices_on_lower_node[var],
                                        dof_indices_on_upper_node[j],
                                        _contact_penalty * contact_force_direction(j) * contact_force_direction(var));

                          jacobian-&gt;add(dof_indices_on_lower_node[var],
                                        dof_indices_on_lower_node[j],
                                        -_contact_penalty * contact_force_direction(j) * contact_force_direction(var));

                          jacobian-&gt;add(dof_indices_on_upper_node[var],
                                        dof_indices_on_lower_node[j],
                                        _contact_penalty * contact_force_direction(j) * contact_force_direction(var));

                          jacobian-&gt;add(dof_indices_on_upper_node[var],
                                        dof_indices_on_upper_node[j],
                                        -_contact_penalty * contact_force_direction(j) * contact_force_direction(var));
                        }
                }
              else
                {
</pre>
</div>
<div class = "comment">
We add zeros to the matrix even when lambda_plus_penalty = 0.
We do this because some linear algebra libraries (e.g. PETSc)
will condense out any unused entries from the sparsity pattern,
so adding these zeros in ensures that these entries are not
condensed out.
</div>

<div class ="fragment">
<pre>
                  if (jacobian && (_sys.comm().rank() == 0))
                    for (unsigned int var=0; var&lt;3; var++)
                      for (unsigned int j=0; j&lt;3; j++)
                        {
                          jacobian-&gt;add(dof_indices_on_lower_node[var],
                                        dof_indices_on_upper_node[j],
                                        0.);

                          jacobian-&gt;add(dof_indices_on_lower_node[var],
                                        dof_indices_on_lower_node[j],
                                        0.);

                          jacobian-&gt;add(dof_indices_on_upper_node[var],
                                        dof_indices_on_lower_node[j],
                                        0.);

                          jacobian-&gt;add(dof_indices_on_upper_node[var],
                                        dof_indices_on_upper_node[j],
                                        0.);
                        }
                }
            }
        }

        void LinearElasticityWithContact::compute_stresses()
        {
          EquationSystems & es = _sys.get_equation_systems();
          const Real young_modulus = es.parameters.get&lt;Real&gt;("young_modulus");
          const Real poisson_ratio = es.parameters.get&lt;Real&gt;("poisson_ratio");

          const MeshBase & mesh = _sys.get_mesh();
          const unsigned int dim = mesh.mesh_dimension();

          unsigned int displacement_vars[3];
          displacement_vars[0] = _sys.variable_number ("u");
          displacement_vars[1] = _sys.variable_number ("v");
          displacement_vars[2] = _sys.variable_number ("w");
          const unsigned int u_var = _sys.variable_number ("u");

          const DofMap & dof_map = _sys.get_dof_map();
          FEType fe_type = dof_map.variable_type(u_var);
          UniquePtr&lt;FEBase&gt; fe (FEBase::build(dim, fe_type));
          QGauss qrule (dim, fe_type.default_quadrature_order());
          fe-&gt;attach_quadrature_rule (&qrule);

          const std::vector&lt;Real&gt; & JxW = fe-&gt;get_JxW();
          const std::vector&lt;std::vector&lt;RealGradient&gt; &gt; & dphi = fe-&gt;get_dphi();

</pre>
</div>
<div class = "comment">
Also, get a reference to the ExplicitSystem
</div>

<div class ="fragment">
<pre>
          ExplicitSystem & stress_system = es.get_system&lt;ExplicitSystem&gt;("StressSystem");
          const DofMap & stress_dof_map = stress_system.get_dof_map();
          unsigned int sigma_vars[6];
          sigma_vars[0] = stress_system.variable_number ("sigma_00");
          sigma_vars[1] = stress_system.variable_number ("sigma_01");
          sigma_vars[2] = stress_system.variable_number ("sigma_02");
          sigma_vars[3] = stress_system.variable_number ("sigma_11");
          sigma_vars[4] = stress_system.variable_number ("sigma_12");
          sigma_vars[5] = stress_system.variable_number ("sigma_22");
          unsigned int vonMises_var = stress_system.variable_number ("vonMises");

</pre>
</div>
<div class = "comment">
Storage for the stress dof indices on each element
</div>

<div class ="fragment">
<pre>
          std::vector&lt; std::vector&lt;dof_id_type&gt; &gt; dof_indices_var(_sys.n_vars());
          std::vector&lt;dof_id_type&gt; stress_dof_indices_var;

</pre>
</div>
<div class = "comment">
To store the stress tensor on each element
</div>

<div class ="fragment">
<pre>
          DenseMatrix&lt;Number&gt; elem_avg_stress_tensor(3, 3);

          MeshBase::const_element_iterator       el     = mesh.active_local_elements_begin();
          const MeshBase::const_element_iterator end_el = mesh.active_local_elements_end();

          for ( ; el != end_el; ++el)
            {
              const Elem * elem = *el;

              for (unsigned int var=0; var&lt;3; var++)
                dof_map.dof_indices (elem, dof_indices_var[var], displacement_vars[var]);

              const unsigned int n_var_dofs = dof_indices_var[0].size();

              fe-&gt;reinit (elem);

</pre>
</div>
<div class = "comment">
clear the stress tensor
</div>

<div class ="fragment">
<pre>
              elem_avg_stress_tensor.resize(3, 3);

              for (unsigned int qp=0; qp&lt;qrule.n_points(); qp++)
                {
</pre>
</div>
<div class = "comment">
Row is variable u1, u2, or u3, column is x, y, or z
</div>

<div class ="fragment">
<pre>
                  DenseMatrix&lt;Number&gt; grad_u(3, 3);
                  for (unsigned int var_i=0; var_i&lt;3; var_i++)
                    for (unsigned int var_j=0; var_j&lt;3; var_j++)
                      for (unsigned int j=0; j&lt;n_var_dofs; j++)
                        grad_u(var_i, var_j) +=
                          dphi[j][qp](var_j) * _sys.current_solution(dof_indices_var[var_i][j]);

                  DenseMatrix&lt;Number&gt; stress_tensor(3, 3);
                  for (unsigned int i=0; i&lt;3; i++)
                    for (unsigned int j=0; j&lt;3; j++)
                      for (unsigned int k=0; k&lt;3; k++)
                        for (unsigned int l=0; l&lt;3; l++)
                          stress_tensor(i,j) +=
                            elasticity_tensor(young_modulus, poisson_ratio, i, j, k, l) * grad_u(k,l);

</pre>
</div>
<div class = "comment">
We want to plot the average stress on each element, hence
we integrate stress_tensor
</div>

<div class ="fragment">
<pre>
                  elem_avg_stress_tensor.add(JxW[qp], stress_tensor);
                }

</pre>
</div>
<div class = "comment">
Get the average stress per element by dividing by volume
</div>

<div class ="fragment">
<pre>
              elem_avg_stress_tensor.scale(1./elem-&gt;volume());

</pre>
</div>
<div class = "comment">
load elem_sigma data into stress_system
</div>

<div class ="fragment">
<pre>
              unsigned int stress_var_index = 0;
              for (unsigned int i=0; i&lt;3; i++)
                for (unsigned int j=i; j&lt;3; j++)
                  {
                    stress_dof_map.dof_indices (elem, stress_dof_indices_var, sigma_vars[stress_var_index]);

</pre>
</div>
<div class = "comment">
We are using CONSTANT MONOMIAL basis functions, hence we only need to get
one dof index per variable
</div>

<div class ="fragment">
<pre>
                    dof_id_type dof_index = stress_dof_indices_var[0];

                    if ((stress_system.solution-&gt;first_local_index() &lt;= dof_index) &&
                        (dof_index &lt; stress_system.solution-&gt;last_local_index()))
                      stress_system.solution-&gt;set(dof_index, elem_avg_stress_tensor(i,j));

                    stress_var_index++;
                  }

</pre>
</div>
<div class = "comment">
Also, the von Mises stress
</div>

<div class ="fragment">
<pre>
              Number vonMises_value = std::sqrt(0.5*(pow(elem_avg_stress_tensor(0,0) - elem_avg_stress_tensor(1,1), 2.) +
                                                     pow(elem_avg_stress_tensor(1,1) - elem_avg_stress_tensor(2,2), 2.) +
                                                     pow(elem_avg_stress_tensor(2,2) - elem_avg_stress_tensor(0,0), 2.) +
                                                     6.*(pow(elem_avg_stress_tensor(0,1), 2.) +
                                                         pow(elem_avg_stress_tensor(1,2), 2.) +
                                                         pow(elem_avg_stress_tensor(2,0), 2.))));

              stress_dof_map.dof_indices (elem, stress_dof_indices_var, vonMises_var);
              dof_id_type dof_index = stress_dof_indices_var[0];

              if ((stress_system.solution-&gt;first_local_index() &lt;= dof_index) &&
                  (dof_index &lt; stress_system.solution-&gt;last_local_index()))
                stress_system.solution-&gt;set(dof_index, vonMises_value);
            }

</pre>
</div>
<div class = "comment">
Should call close and update when we set vector entries directly
</div>

<div class ="fragment">
<pre>
          stress_system.solution-&gt;close();
          stress_system.update();
        }

        std::pair&lt;Real, Real&gt; LinearElasticityWithContact::update_lambdas()
        {
          Real max_delta_lambda = 0.;
          Real max_new_lambda = 0.;

          std::map&lt;dof_id_type, Real&gt;::iterator it = _lambdas.begin();
          std::map&lt;dof_id_type, Real&gt;::iterator it_end = _lambdas.end();
          for ( ; it != it_end; ++it)
            {
              dof_id_type upper_node_id = it-&gt;first;

              std::map&lt;dof_id_type, Real&gt;::iterator new_lambda_it = _lambda_plus_penalty_values.find(upper_node_id);
              if (new_lambda_it == _lambda_plus_penalty_values.end())
                libmesh_error_msg("New lambda value not found");

              Real new_lambda = new_lambda_it-&gt;second;
              Real old_lambda = it-&gt;second;

              it-&gt;second = new_lambda;

              Real delta_lambda = std::abs(new_lambda-old_lambda);
              if (delta_lambda &gt; max_delta_lambda)
                max_delta_lambda = delta_lambda;

              if (std::abs(new_lambda) &gt; max_new_lambda)
                max_new_lambda = std::abs(new_lambda);
            }

          return std::make_pair(max_delta_lambda, max_new_lambda);
        }

        std::pair&lt;Real, Real&gt; LinearElasticityWithContact::get_least_and_max_gap_function()
        {
          UniquePtr&lt;MeshBase&gt; mesh_clone = _sys.get_mesh().clone();
          move_mesh(*mesh_clone, *_sys.solution);

          Real least_value = std::numeric_limits&lt;Real&gt;::max();
          Real max_value = std::numeric_limits&lt;Real&gt;::min();

          LIBMESH_BEST_UNORDERED_MAP&lt;dof_id_type, dof_id_type&gt;::iterator it =
            _augment_sparsity._contact_node_map.begin();
          LIBMESH_BEST_UNORDERED_MAP&lt;dof_id_type, dof_id_type&gt;::iterator it_end =
            _augment_sparsity._contact_node_map.end();
          for ( ; it != it_end; ++it)
            {
              dof_id_type lower_point_id = it-&gt;first;
              dof_id_type upper_point_id = it-&gt;second;

              Point upper_to_lower;
              {
                Point lower_node_moved = mesh_clone-&gt;point(lower_point_id);
                Point upper_node_moved = mesh_clone-&gt;node(upper_point_id);

                upper_to_lower = (lower_node_moved - upper_node_moved);
              }

</pre>
</div>
<div class = "comment">
Set the contact force direction. Usually this would be calculated
separately on each master node, but here we just set it to (0, 0, 1)
everywhere.
</div>

<div class ="fragment">
<pre>
              Point contact_force_direction(0., 0., 1.);

</pre>
</div>
<div class = "comment">
gap_function > 0. means that contact has been detected
gap_function < 0. means that we have a gap
This sign convention matches Simo & Laursen (1992).
</div>

<div class ="fragment">
<pre>
              Real gap_function = upper_to_lower * contact_force_direction;

              if (gap_function &lt; least_value)
                least_value = gap_function;

              if (gap_function &gt; max_value)
                max_value = gap_function;
            }

          return std::make_pair(least_value, max_value);
        }
</pre>
</div>

<a name="comments"></a>
<br><br><br> <h1> The source file systems_of_equations_ex8.C with comments: </h1>
<div class = "comment">
</div>

<div class ="fragment">
<pre>
        #include &lt;iostream&gt;

</pre>
</div>
<div class = "comment">
libMesh includes
</div>

<div class ="fragment">
<pre>
        #include "libmesh/libmesh.h"
        #include "libmesh/serial_mesh.h"
        #include "libmesh/exodusII_io.h"
        #include "libmesh/equation_systems.h"
        #include "libmesh/dof_map.h"
        #include "libmesh/numeric_vector.h"
        #include "libmesh/getpot.h"
        #include "libmesh/dirichlet_boundaries.h"
        #include "libmesh/string_to_enum.h"
        #include "libmesh/zero_function.h"
        #include "libmesh/nonlinear_solver.h"
        #include "libmesh/nonlinear_implicit_system.h"
        #include "libmesh/petsc_macro.h"

</pre>
</div>
<div class = "comment">
Local includes
</div>

<div class ="fragment">
<pre>
        #include "linear_elasticity_with_contact.h"

        using namespace libMesh;

        int main (int argc, char ** argv)
        {
          LibMeshInit init (argc, argv);

</pre>
</div>
<div class = "comment">
This example requires the PETSc nonlinear solvers
</div>

<div class ="fragment">
<pre>
          libmesh_example_requires(libMesh::default_solver_package() == PETSC_SOLVERS, "--enable-petsc");

</pre>
</div>
<div class = "comment">
This example requires PETSc >= 3.5.0 since it uses
PetscMatrix::update_preallocation_and_zero().
</div>

<div class ="fragment">
<pre>
        #if PETSC_VERSION_LESS_THAN(3,5,0)
          libmesh_example_requires(false, "PETSc &gt;= 3.5.0");
        #endif

          GetPot infile("systems_of_equations_ex8.in");
          const std::string approx_order = infile("approx_order", "FIRST");
          const std::string fe_family = infile("fe_family", "LAGRANGE");

          const Real young_modulus = infile("Young_modulus", 1.0);
          const Real poisson_ratio = infile("poisson_ratio", 0.3);

          const Real nonlinear_abs_tol = infile("nonlinear_abs_tol", 1.e-8);
          const Real nonlinear_rel_tol = infile("nonlinear_rel_tol", 1.e-8);
          const unsigned int nonlinear_max_its = infile("nonlinear_max_its", 50);
          const Real contact_penalty = infile("contact_penalty", 1.e2);
          const Real gap_function_tol = infile("gap_function_tol", 1.e-8);

</pre>
</div>
<div class = "comment">
This example code has not been written to cope with a distributed mesh
</div>

<div class ="fragment">
<pre>
          SerialMesh mesh(init.comm());
          mesh.read("systems_of_equations_ex8.exo");

          mesh.print_info();

          EquationSystems equation_systems (mesh);

          NonlinearImplicitSystem & system =
            equation_systems.add_system&lt;NonlinearImplicitSystem&gt; ("NonlinearElasticity");

          LinearElasticityWithContact le(system, contact_penalty);

          unsigned int u_var =
            system.add_variable("u",
                                Utility::string_to_enum&lt;Order&gt;   (approx_order),
                                Utility::string_to_enum&lt;FEFamily&gt;(fe_family));

          unsigned int v_var =
            system.add_variable("v",
                                Utility::string_to_enum&lt;Order&gt;   (approx_order),
                                Utility::string_to_enum&lt;FEFamily&gt;(fe_family));

          unsigned int w_var =
            system.add_variable("w",
                                Utility::string_to_enum&lt;Order&gt;   (approx_order),
                                Utility::string_to_enum&lt;FEFamily&gt;(fe_family));

</pre>
</div>
<div class = "comment">
Also, initialize an ExplicitSystem to store stresses
</div>

<div class ="fragment">
<pre>
          ExplicitSystem & stress_system =
            equation_systems.add_system&lt;ExplicitSystem&gt; ("StressSystem");

          stress_system.add_variable("sigma_00", CONSTANT, MONOMIAL);
          stress_system.add_variable("sigma_01", CONSTANT, MONOMIAL);
          stress_system.add_variable("sigma_02", CONSTANT, MONOMIAL);
          stress_system.add_variable("sigma_11", CONSTANT, MONOMIAL);
          stress_system.add_variable("sigma_12", CONSTANT, MONOMIAL);
          stress_system.add_variable("sigma_22", CONSTANT, MONOMIAL);
          stress_system.add_variable("vonMises", CONSTANT, MONOMIAL);

          equation_systems.parameters.set&lt;Real&gt; ("nonlinear solver absolute residual tolerance") = nonlinear_abs_tol;
          equation_systems.parameters.set&lt;Real&gt; ("nonlinear solver relative residual tolerance") = nonlinear_rel_tol;
          equation_systems.parameters.set&lt;unsigned int&gt; ("nonlinear solver maximum iterations") = nonlinear_max_its;

          system.nonlinear_solver-&gt;residual_and_jacobian_object = &le;

          equation_systems.parameters.set&lt;Real&gt;("young_modulus") = young_modulus;
          equation_systems.parameters.set&lt;Real&gt;("poisson_ratio") = poisson_ratio;

</pre>
</div>
<div class = "comment">
Attach Dirichlet boundary conditions
</div>

<div class ="fragment">
<pre>
          {
            std::set&lt;boundary_id_type&gt; clamped_boundaries;
            clamped_boundaries.insert(MIN_Z_BOUNDARY);

            std::vector&lt;unsigned int&gt; uvw;
            uvw.push_back(u_var);
            uvw.push_back(v_var);
            uvw.push_back(w_var);

            ZeroFunction&lt;Number&gt; zero;

            system.get_dof_map().add_dirichlet_boundary(DirichletBoundary (clamped_boundaries, uvw, &zero));
          }
          {
            std::set&lt;boundary_id_type&gt; clamped_boundaries;
            clamped_boundaries.insert(MAX_Z_BOUNDARY);

            std::vector&lt;unsigned int&gt; uv;
            uv.push_back(u_var);
            uv.push_back(v_var);

            ZeroFunction&lt;Number&gt; zero;

            system.get_dof_map().add_dirichlet_boundary(DirichletBoundary (clamped_boundaries, uv, &zero));
          }
          {
            std::set&lt;boundary_id_type&gt; clamped_boundaries;
            clamped_boundaries.insert(MAX_Z_BOUNDARY);

            std::vector&lt;unsigned int&gt; w;
            w.push_back(w_var);

            ConstFunction&lt;Number&gt; neg_one(-1.);

            system.get_dof_map().add_dirichlet_boundary(DirichletBoundary (clamped_boundaries, w, &neg_one));
          }

          le.initialize_contact_load_paths();

</pre>
</div>
<div class = "comment">
The augment_sparsity object was initialized in initialize_contact_load_paths.
</div>

<div class ="fragment">
<pre>
          system.get_dof_map().attach_extra_sparsity_object(le.get_augment_sparsity());

          equation_systems.init();
          equation_systems.print_info();

          libMesh::out &lt;&lt; "Contact penalty: " &lt;&lt; contact_penalty  &lt;&lt; std::endl &lt;&lt; std::endl;

          Real current_max_gap_function = std::numeric_limits&lt;Real&gt;::max();

          unsigned int outer_iteration = 0;
          while (current_max_gap_function &gt; gap_function_tol)
            {
              libMesh::out &lt;&lt; "Starting outer iteration " &lt;&lt; outer_iteration &lt;&lt; std::endl;

</pre>
</div>
<div class = "comment">
Perform inner iteration (i.e. Newton's method loop)
</div>

<div class ="fragment">
<pre>
              system.solve();
              system.nonlinear_solver-&gt;print_converged_reason();

</pre>
</div>
<div class = "comment">
Perform augmented Lagrangian update
</div>

<div class ="fragment">
<pre>
              le.update_lambdas();

              std::pair&lt;Real, Real&gt; least_and_max_gap_function = le.get_least_and_max_gap_function();
              Real least_gap_fn = least_and_max_gap_function.first;
              Real max_gap_fn = least_and_max_gap_function.second;

              libMesh::out &lt;&lt; "Finished outer iteration, least gap function: "
                           &lt;&lt; least_gap_fn
                           &lt;&lt; ", max gap function: "
                           &lt;&lt; max_gap_fn
                           &lt;&lt; std::endl
                           &lt;&lt; std::endl;

              current_max_gap_function = std::max(std::abs(least_gap_fn), std::abs(max_gap_fn));

              outer_iteration++;
            }

          libMesh::out &lt;&lt; "Computing stresses..." &lt;&lt; std::endl;

          le.compute_stresses();

          std::stringstream filename;
          filename &lt;&lt; "solution.exo";
          ExodusII_IO (mesh).write_equation_systems(filename.str(),
                                                    equation_systems);

          return 0;
        }
</pre>
</div>

<a name="nocomments"></a>
<br><br><br> <h1> The source file augment_sparsity_on_contact.h without comments: </h1>
<pre>
  #ifndef AUGMENT_SPARSITY_ON_CONTACT_H
  #define AUGMENT_SPARSITY_ON_CONTACT_H

  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/dof_map.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/system.h&quot;</FONT></B>
  #include LIBMESH_INCLUDE_UNORDERED_MAP

  using libMesh::DofMap;
  using libMesh::System;
  using libMesh::Node;
  using libMesh::dof_id_type;
  using libMesh::boundary_id_type;

  <B><FONT COLOR="#228B22">class</FONT></B> AugmentSparsityOnContact : <B><FONT COLOR="#228B22">public</FONT></B> DofMap::AugmentSparsityPattern
  {
  <B><FONT COLOR="#228B22">public</FONT></B>:

    <I><FONT COLOR="#B22222">/**
     * Constructor.
     */</FONT></I>
    AugmentSparsityOnContact(System &amp; _sys);

    <I><FONT COLOR="#B22222">/**
     * Clear the contact element map.
     */</FONT></I>
    <B><FONT COLOR="#228B22">void</FONT></B> clear_contact_node_map();

    <I><FONT COLOR="#B22222">/**
     * Add a new entry to _contact_node_map.
     */</FONT></I>
    <B><FONT COLOR="#228B22">void</FONT></B> add_contact_node(dof_id_type lower_node_id,
                          dof_id_type upper_node_id);

    <I><FONT COLOR="#B22222">/**
     * User-defined function to augment the sparsity pattern.
     */</FONT></I>
    <B><FONT COLOR="#228B22">virtual</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> augment_sparsity_pattern (libMesh::SparsityPattern::Graph &amp;,
                                           <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;dof_id_type&gt; &amp; n_nz,
                                           <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;dof_id_type&gt; &amp; n_oz);

    <I><FONT COLOR="#B22222">/**
     * Helper function that actually sets the sparsity values.
     */</FONT></I>
    <B><FONT COLOR="#228B22">void</FONT></B> set_sparsity_values(<B><FONT COLOR="#228B22">const</FONT></B> Node &amp; this_node,
                             <B><FONT COLOR="#228B22">const</FONT></B> Node &amp; other_node,
                             <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;dof_id_type&gt; &amp; n_nz,
                             <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;dof_id_type&gt; &amp; n_oz);

    <I><FONT COLOR="#B22222">/**
     * The System object that we're using here.
     */</FONT></I>
    System &amp; _sys;

    <I><FONT COLOR="#B22222">/**
     * This provides a map between contact nodes.
     */</FONT></I>
    LIBMESH_BEST_UNORDERED_MAP&lt;dof_id_type, dof_id_type&gt; _contact_node_map;
  };

  #endif
</pre>
<a name="nocomments"></a>
<br><br><br> <h1> The source file linear_elasticity_with_contact.h without comments: </h1>
<pre>
  #ifndef LINEAR_ELASTICITY_WITH_CONTACT_H
  #define LINEAR_ELASTICITY_WITH_CONTACT_H

  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/dof_map.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/nonlinear_implicit_system.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;augment_sparsity_on_contact.h&quot;</FONT></B>

  #define TOP_SUBDOMAIN 2
  #define BOTTOM_SUBDOMAIN 1

  #define MIN_Z_BOUNDARY 1
  #define MAX_Z_BOUNDARY 2
  #define CONTACT_BOUNDARY_LOWER 3
  #define CONTACT_BOUNDARY_UPPER 4

  using libMesh::DofMap;
  using libMesh::NonlinearImplicitSystem;
  using libMesh::dof_id_type;
  using libMesh::Point;
  using libMesh::Real;
  using libMesh::Number;
  using libMesh::MeshBase;
  using libMesh::NumericVector;
  using libMesh::SparseMatrix;

  <I><FONT COLOR="#B22222">/**
   * This class encapsulate all functionality required for assembling
   * and solving a linear elastic model with contact.
   */</FONT></I>
  <B><FONT COLOR="#228B22">class</FONT></B> LinearElasticityWithContact :
    <B><FONT COLOR="#228B22">public</FONT></B> NonlinearImplicitSystem::ComputeResidualandJacobian
  {
  <B><FONT COLOR="#228B22">private</FONT></B>:

    <I><FONT COLOR="#B22222">/**
     * Keep a reference to the NonlinearImplicitSystem.
     */</FONT></I>
    NonlinearImplicitSystem &amp; _sys;

    <I><FONT COLOR="#B22222">/**
     * The object that handles augmenting the sparsity pattern.
     */</FONT></I>
    AugmentSparsityOnContact _augment_sparsity;

    <I><FONT COLOR="#B22222">/**
     * Penalize overlapping elements.
     */</FONT></I>
    Real _contact_penalty;

    <I><FONT COLOR="#B22222">/**
     * Store the intermediate values of lambda plus penalty. The dof IDs refer
     * to the nodes on the upper contact surface.
     */</FONT></I>
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::map&lt;dof_id_type, Real&gt; _lambda_plus_penalty_values;

    <I><FONT COLOR="#B22222">/**
     * Augmented Lagrangian values at each contact node. The dof IDs refer
     * to the nodes on the upper contact surface.
     */</FONT></I>
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::map&lt;dof_id_type, Real&gt; _lambdas;

  <B><FONT COLOR="#228B22">public</FONT></B>:

    <I><FONT COLOR="#B22222">/**
     * Constructor.
     */</FONT></I>
    LinearElasticityWithContact(NonlinearImplicitSystem &amp; sys_in,
                                Real contact_penalty_in);

    <I><FONT COLOR="#B22222">/**
     * @return a reference to the object for augmenting the sparsity pattern.
     */</FONT></I>
    AugmentSparsityOnContact &amp; get_augment_sparsity();

    <I><FONT COLOR="#B22222">/**
     * Update the penalty parameter.
     */</FONT></I>
    <B><FONT COLOR="#228B22">void</FONT></B> set_contact_penalty(Real contact_penalty_in);

    <I><FONT COLOR="#B22222">/**
     * Get the penalty parameter.
     */</FONT></I>
    Real get_contact_penalty() <B><FONT COLOR="#228B22">const</FONT></B>;

    <I><FONT COLOR="#B22222">/**
     * Kronecker delta function.
     */</FONT></I>
    Real kronecker_delta(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i,
                         <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j);

    <I><FONT COLOR="#B22222">/**
     * Evaluate the fourth order tensor (C_ijkl) that relates stress to strain.
     */</FONT></I>
    Real elasticity_tensor(Real young_modulus,
                           Real poisson_ratio,
                           <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i,
                           <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j,
                           <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> k,
                           <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> l);

    <I><FONT COLOR="#B22222">/**
     * Move the mesh nodes of \p input_mesh based on the displacement field
     * in \p input_solution.
     */</FONT></I>
    <B><FONT COLOR="#228B22">void</FONT></B> move_mesh(MeshBase &amp; input_mesh,
                   <B><FONT COLOR="#228B22">const</FONT></B> NumericVector&lt;Number&gt; &amp; input_solution);

    <I><FONT COLOR="#B22222">/**
     * Set up the load paths on the contact surfaces.
     */</FONT></I>
    <B><FONT COLOR="#228B22">void</FONT></B> initialize_contact_load_paths();

    <I><FONT COLOR="#B22222">/**
     * Evaluate the Jacobian of the nonlinear system.
     */</FONT></I>
    <B><FONT COLOR="#228B22">virtual</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> residual_and_jacobian (<B><FONT COLOR="#228B22">const</FONT></B> NumericVector&lt;Number&gt; &amp; soln,
                                        NumericVector&lt;Number&gt; * residual,
                                        SparseMatrix&lt;Number&gt; * jacobian,
                                        NonlinearImplicitSystem &amp; <I><FONT COLOR="#B22222">/*sys*/</FONT></I>);

    <I><FONT COLOR="#B22222">/**
     * Compute the Cauchy stress for the current solution.
     */</FONT></I>
    <B><FONT COLOR="#228B22">void</FONT></B> compute_stresses();

    <I><FONT COLOR="#B22222">/**
     * Update the lambda parameters in the augmented Lagrangian
     * method.
     * @return the largest change in the lambdas, and the largest
     * lambda value.
     */</FONT></I>
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::pair&lt;Real, Real&gt; update_lambdas();

    <I><FONT COLOR="#B22222">/**
     * @return the least and max gap function values for the current solution.
     */</FONT></I>
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::pair&lt;Real, Real&gt; get_least_and_max_gap_function();
  };

  #endif
</pre>
<a name="nocomments"></a>
<br><br><br> <h1> The source file augment_sparsity_on_contact.C without comments: </h1>
<pre>
  #include <B><FONT COLOR="#BC8F8F">&quot;augment_sparsity_on_contact.h&quot;</FONT></B>

  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/linear_implicit_system.h&quot;</FONT></B>
  #include LIBMESH_INCLUDE_UNORDERED_SET
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/elem.h&quot;</FONT></B>

  using namespace libMesh;

  <B><FONT COLOR="#5F9EA0">AugmentSparsityOnContact</FONT></B>::AugmentSparsityOnContact(System &amp; sys) :
    _sys(sys)
  {}

  <B><FONT COLOR="#228B22">void</FONT></B> AugmentSparsityOnContact::clear_contact_node_map()
  {
    _contact_node_map.clear();
  }

  <B><FONT COLOR="#228B22">void</FONT></B> AugmentSparsityOnContact::add_contact_node(dof_id_type lower_node_id,
                                                  dof_id_type upper_node_id)
  {
    _contact_node_map[lower_node_id] = upper_node_id;
  }

  <B><FONT COLOR="#228B22">void</FONT></B> AugmentSparsityOnContact::augment_sparsity_pattern(SparsityPattern::Graph &amp;,
                                                          <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;dof_id_type&gt; &amp; n_nz,
                                                          <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;dof_id_type&gt; &amp; n_oz)
  {
    <B><FONT COLOR="#228B22">const</FONT></B> MeshBase &amp; mesh = _sys.get_mesh();

    LIBMESH_BEST_UNORDERED_MAP&lt;dof_id_type, dof_id_type&gt;::iterator it     = _contact_node_map.begin();
    LIBMESH_BEST_UNORDERED_MAP&lt;dof_id_type, dof_id_type&gt;::iterator it_end = _contact_node_map.end();

    <B><FONT COLOR="#A020F0">for</FONT></B> ( ; it != it_end; ++it)
      {
        <B><FONT COLOR="#228B22">const</FONT></B> Node &amp; this_node = mesh.node(it-&gt;first);
        <B><FONT COLOR="#228B22">const</FONT></B> Node &amp; other_node = mesh.node(it-&gt;second);

        set_sparsity_values(this_node, other_node, n_nz, n_oz);
        set_sparsity_values(other_node, this_node, n_nz, n_oz);
      }
  }

  <B><FONT COLOR="#228B22">void</FONT></B> AugmentSparsityOnContact::set_sparsity_values(<B><FONT COLOR="#228B22">const</FONT></B> Node &amp; this_node,
                                                     <B><FONT COLOR="#228B22">const</FONT></B> Node &amp; other_node,
                                                     <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;dof_id_type&gt; &amp; n_nz,
                                                     <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;dof_id_type&gt; &amp; n_oz)
  {
    <B><FONT COLOR="#228B22">const</FONT></B> DofMap &amp; dof_map = _sys.get_dof_map();

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var_i=0; var_i&lt;3; var_i++)
      {
        dof_id_type dof_index_on_this_node =
          this_node.dof_number(_sys.number(), var_i, 0);

        <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n_local_coupled_dofs = 0;
        <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n_remote_coupled_dofs = 0;

        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var_j=0; var_j&lt;3; var_j++)
          {
            dof_id_type dof_index_on_other_node =
              other_node.dof_number(_sys.number(), var_j, 0);

            <B><FONT COLOR="#A020F0">if</FONT></B> ((dof_index_on_other_node &gt;= dof_map.first_dof()) &amp;&amp;
                (dof_index_on_other_node  &lt; dof_map.end_dof()))
              n_local_coupled_dofs++;
            <B><FONT COLOR="#A020F0">else</FONT></B>
              n_remote_coupled_dofs++;
          }

        <B><FONT COLOR="#A020F0">if</FONT></B> ((dof_index_on_this_node &gt;= dof_map.first_dof()) &amp;&amp;
            (dof_index_on_this_node  &lt; dof_map.end_dof()))
          {
            <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>
              dof_offset = dof_index_on_this_node - dof_map.first_dof();

            libmesh_assert_less (dof_offset, n_nz.size());
            libmesh_assert_less (dof_offset, n_oz.size());

            n_nz[dof_offset] += n_local_coupled_dofs;
            n_oz[dof_offset] += n_remote_coupled_dofs;
          }
      }
  }
</pre>
<a name="nocomments"></a>
<br><br><br> <h1> The source file linear_elasticity_with_contact.C without comments: </h1>
<pre>
  #include <B><FONT COLOR="#BC8F8F">&quot;linear_elasticity_with_contact.h&quot;</FONT></B>

  #include &lt;iostream&gt;
  #include &lt;algorithm&gt;
  #include &lt;cmath&gt;

  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/libmesh.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/mesh.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/equation_systems.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/fe.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/quadrature_gauss.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/dof_map.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/sparse_matrix.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/numeric_vector.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/dense_matrix.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/dense_vector.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/elem.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/fe_interface.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/fe_compute_data.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/petsc_matrix.h&quot;</FONT></B>
  #include LIBMESH_INCLUDE_UNORDERED_SET

  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/nonlinear_solver.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/nonlinear_implicit_system.h&quot;</FONT></B>

  using namespace libMesh;

  <B><FONT COLOR="#5F9EA0">LinearElasticityWithContact</FONT></B>::LinearElasticityWithContact (NonlinearImplicitSystem &amp; sys_in,
                                                            Real contact_penalty_in) :
    _sys(sys_in),
    _augment_sparsity(_sys),
    _contact_penalty(contact_penalty_in)
  {
  }

  AugmentSparsityOnContact &amp; LinearElasticityWithContact::get_augment_sparsity()
  {
    <B><FONT COLOR="#A020F0">return</FONT></B> _augment_sparsity;
  }

  <B><FONT COLOR="#228B22">void</FONT></B> LinearElasticityWithContact::set_contact_penalty(Real contact_penalty_in)
  {
    _contact_penalty = contact_penalty_in;
  }

  Real LinearElasticityWithContact::get_contact_penalty() <B><FONT COLOR="#228B22">const</FONT></B>
  {
    <B><FONT COLOR="#A020F0">return</FONT></B> _contact_penalty;
  }

  Real LinearElasticityWithContact::kronecker_delta(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i,
                                                    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j)
  {
    <B><FONT COLOR="#A020F0">return</FONT></B> i == j ? 1. : 0.;
  }

  Real LinearElasticityWithContact::elasticity_tensor(Real young_modulus,
                                                      Real poisson_ratio,
                                                      <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i,
                                                      <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j,
                                                      <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> k,
                                                      <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> l)
  {
    <B><FONT COLOR="#228B22">const</FONT></B> Real lambda_1 = (young_modulus*poisson_ratio)/((1.+poisson_ratio)*(1.-2.*poisson_ratio));
    <B><FONT COLOR="#228B22">const</FONT></B> Real lambda_2 = young_modulus/(2.*(1.+poisson_ratio));

    <B><FONT COLOR="#A020F0">return</FONT></B> lambda_1 * kronecker_delta(i, j) * kronecker_delta(k, l) +
      lambda_2 * (kronecker_delta(i, k) * kronecker_delta(j, l) + kronecker_delta(i, l) * kronecker_delta(j, k));
  }

  <B><FONT COLOR="#228B22">void</FONT></B> LinearElasticityWithContact::move_mesh (MeshBase &amp; input_mesh,
                                               <B><FONT COLOR="#228B22">const</FONT></B> NumericVector&lt;Number&gt; &amp; input_solution)
  {
    LIBMESH_BEST_UNORDERED_SET&lt;dof_id_type&gt; encountered_node_ids;

    UniquePtr&lt; NumericVector&lt;Number&gt; &gt; localized_input_solution =
      NumericVector&lt;Number&gt;::build(input_solution.comm());

    localized_input_solution-&gt;init (input_solution.size(), false, SERIAL);
    input_solution.localize(*localized_input_solution);

    <B><FONT COLOR="#5F9EA0">MeshBase</FONT></B>::const_element_iterator       el     = input_mesh.active_elements_begin();
    <B><FONT COLOR="#228B22">const</FONT></B> MeshBase::const_element_iterator end_el = input_mesh.active_elements_end();

    <B><FONT COLOR="#A020F0">for</FONT></B> ( ; el != end_el; ++el)
      {
        Elem * elem = *el;
        Elem * orig_elem = _sys.get_mesh().elem(elem-&gt;id());

        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> node_id=0; node_id&lt;elem-&gt;n_nodes(); node_id++)
          {
            Node * node = elem-&gt;get_node(node_id);

            <B><FONT COLOR="#A020F0">if</FONT></B> (encountered_node_ids.find(node-&gt;id()) != encountered_node_ids.end())
              <B><FONT COLOR="#A020F0">continue</FONT></B>;

            encountered_node_ids.insert(node-&gt;id());

            <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::string&gt; uvw_names(3);
            uvw_names[0] = <B><FONT COLOR="#BC8F8F">&quot;u&quot;</FONT></B>;
            uvw_names[1] = <B><FONT COLOR="#BC8F8F">&quot;v&quot;</FONT></B>;
            uvw_names[2] = <B><FONT COLOR="#BC8F8F">&quot;w&quot;</FONT></B>;

            {
              <B><FONT COLOR="#228B22">const</FONT></B> Point master_point = elem-&gt;master_point(node_id);

              Point uvw;
              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> index=0; index&lt;uvw_names.size(); index++)
                {
                  <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var = _sys.variable_number(uvw_names[index]);
                  <B><FONT COLOR="#228B22">const</FONT></B> FEType &amp; fe_type = _sys.get_dof_map().variable_type(var);

                  FEComputeData data (_sys.get_equation_systems(), master_point);

                  <B><FONT COLOR="#5F9EA0">FEInterface</FONT></B>::compute_data(elem-&gt;dim(),
                                            fe_type,
                                            elem,
                                            data);

                  <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;dof_id_type&gt; dof_indices_var;
                  _sys.get_dof_map().dof_indices (orig_elem, dof_indices_var, var);

                  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;dof_indices_var.size(); i++)
                    {
                      Number value = (*localized_input_solution)(dof_indices_var[i]) * data.shape[i];

  #ifdef LIBMESH_USE_COMPLEX_NUMBERS
                      uvw(index) += value.real();
  #<B><FONT COLOR="#A020F0">else</FONT></B>
                      uvw(index) += value;
  #endif
                    }
                }

              *node += uvw;
            }
          }
      }
  }

  <B><FONT COLOR="#228B22">void</FONT></B> LinearElasticityWithContact::initialize_contact_load_paths()
  {
    <B><FONT COLOR="#228B22">const</FONT></B> MeshBase &amp; mesh = _sys.get_mesh();

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;dof_id_type&gt; nodes_on_lower_surface;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;dof_id_type&gt; nodes_on_upper_surface;

    <B><FONT COLOR="#5F9EA0">MeshBase</FONT></B>::const_element_iterator       el     = mesh.active_elements_begin();
    <B><FONT COLOR="#228B22">const</FONT></B> MeshBase::const_element_iterator end_el = mesh.active_elements_end();

    _lambdas.clear();
    <B><FONT COLOR="#A020F0">for</FONT></B> ( ; el != end_el; ++el)
      {
        <B><FONT COLOR="#228B22">const</FONT></B> Elem * elem = *el;

        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> side=0; side&lt;elem-&gt;n_sides(); side++)
          {
            <B><FONT COLOR="#A020F0">if</FONT></B> (elem-&gt;neighbor(side) == libmesh_nullptr)
              {
                <B><FONT COLOR="#228B22">bool</FONT></B> on_lower_contact_surface =
                  mesh.get_boundary_info().has_boundary_id (elem, side, CONTACT_BOUNDARY_LOWER);

                <B><FONT COLOR="#228B22">bool</FONT></B> on_upper_contact_surface =
                  mesh.get_boundary_info().has_boundary_id (elem, side, CONTACT_BOUNDARY_UPPER);

                <B><FONT COLOR="#A020F0">if</FONT></B> (on_lower_contact_surface &amp;&amp; on_upper_contact_surface)
                  libmesh_error_msg(<B><FONT COLOR="#BC8F8F">&quot;Should not be on both surfaces at the same time&quot;</FONT></B>);

                <B><FONT COLOR="#A020F0">if</FONT></B> (on_lower_contact_surface || on_upper_contact_surface)
                  {
                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> node_index=0; node_index&lt;elem-&gt;n_nodes(); node_index++)
                      <B><FONT COLOR="#A020F0">if</FONT></B> (elem-&gt;is_node_on_side(node_index, side))
                        {
                          <B><FONT COLOR="#A020F0">if</FONT></B> (on_lower_contact_surface)
                            nodes_on_lower_surface.push_back(elem-&gt;node(node_index));
                          <B><FONT COLOR="#A020F0">else</FONT></B>
                            {
                              _lambdas[elem-&gt;node(node_index)] = 0.;
                              nodes_on_upper_surface.push_back(elem-&gt;node(node_index));
                            }
                        }
                  }

              } <I><FONT COLOR="#B22222">// end if nieghbor(side_) != libmesh_nullptr
</FONT></I>          } <I><FONT COLOR="#B22222">// end for side
</FONT></I>      } <I><FONT COLOR="#B22222">// end for el
</FONT></I>
    libmesh_assert(nodes_on_lower_surface.size() == nodes_on_upper_surface.size());

    _augment_sparsity.clear_contact_node_map();
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;nodes_on_lower_surface.size(); i++)
      {
        dof_id_type lower_node_id = nodes_on_lower_surface[i];
        Point p_lower = mesh.point(lower_node_id);

        Real min_distance = std::numeric_limits&lt;Real&gt;::max();

        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;nodes_on_upper_surface.size(); j++)
          {
            dof_id_type upper_node_id = nodes_on_upper_surface[j];
            Point p_upper = mesh.point(upper_node_id);

            Real distance = (p_upper - p_lower).size();

            <B><FONT COLOR="#A020F0">if</FONT></B> (distance &lt; min_distance)
              {
                _augment_sparsity.add_contact_node(lower_node_id, upper_node_id);
                min_distance = distance;
              }
          }
      }

  }

  <B><FONT COLOR="#228B22">void</FONT></B> LinearElasticityWithContact::residual_and_jacobian (<B><FONT COLOR="#228B22">const</FONT></B> NumericVector&lt;Number&gt; &amp; soln,
                                                           NumericVector&lt;Number&gt; * residual,
                                                           SparseMatrix&lt;Number&gt; * jacobian,
                                                           NonlinearImplicitSystem &amp; <I><FONT COLOR="#B22222">/*sys*/</FONT></I>)
  {
    EquationSystems &amp; es = _sys.get_equation_systems();
    <B><FONT COLOR="#228B22">const</FONT></B> Real young_modulus = es.parameters.get&lt;Real&gt;(<B><FONT COLOR="#BC8F8F">&quot;young_modulus&quot;</FONT></B>);
    <B><FONT COLOR="#228B22">const</FONT></B> Real poisson_ratio = es.parameters.get&lt;Real&gt;(<B><FONT COLOR="#BC8F8F">&quot;poisson_ratio&quot;</FONT></B>);

    <B><FONT COLOR="#228B22">const</FONT></B> MeshBase &amp; mesh = _sys.get_mesh();
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dim = mesh.mesh_dimension();

    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> u_var = _sys.variable_number (<B><FONT COLOR="#BC8F8F">&quot;u&quot;</FONT></B>);

    DofMap &amp; dof_map = _sys.get_dof_map();

    FEType fe_type = dof_map.variable_type(u_var);
    UniquePtr&lt;FEBase&gt; fe (FEBase::build(dim, fe_type));
    QGauss qrule (dim, fe_type.default_quadrature_order());
    fe-&gt;attach_quadrature_rule (&amp;qrule);

    UniquePtr&lt;FEBase&gt; fe_face (FEBase::build(dim, fe_type));
    QGauss qface (dim-1, fe_type.default_quadrature_order());
    fe_face-&gt;attach_quadrature_rule (&amp;qface);

    UniquePtr&lt;FEBase&gt; fe_neighbor_face (FEBase::build(dim, fe_type));
    fe_neighbor_face-&gt;attach_quadrature_rule (&amp;qface);

    <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;Real&gt; &amp; JxW = fe-&gt;get_JxW();
    <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;RealGradient&gt; &gt; &amp; dphi = fe-&gt;get_dphi();

    <B><FONT COLOR="#A020F0">if</FONT></B> (jacobian)
      jacobian-&gt;zero();

    <B><FONT COLOR="#A020F0">if</FONT></B> (residual)
      residual-&gt;zero();

    DenseVector&lt;Number&gt; Re;

    DenseSubVector&lt;Number&gt; Re_var[3] =
      {DenseSubVector&lt;Number&gt;(Re),
       DenseSubVector&lt;Number&gt;(Re),
       DenseSubVector&lt;Number&gt;(Re)};

    DenseMatrix&lt;Number&gt; Ke;
    DenseSubMatrix&lt;Number&gt; Ke_var[3][3] =
      {
        {DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke)},
        {DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke)},
        {DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke)}
      };

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;dof_id_type&gt; dof_indices;
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt; std::vector&lt;dof_id_type&gt; &gt; dof_indices_var(3);

    <B><FONT COLOR="#5F9EA0">MeshBase</FONT></B>::const_element_iterator       el     = mesh.active_local_elements_begin();
    <B><FONT COLOR="#228B22">const</FONT></B> MeshBase::const_element_iterator end_el = mesh.active_local_elements_end();

    <B><FONT COLOR="#A020F0">for</FONT></B> ( ; el != end_el; ++el)
      {
        <B><FONT COLOR="#228B22">const</FONT></B> Elem * elem = *el;

        dof_map.dof_indices (elem, dof_indices);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var=0; var&lt;3; var++)
          dof_map.dof_indices (elem, dof_indices_var[var], var);

        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n_dofs   = dof_indices.size();
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n_var_dofs = dof_indices_var[0].size();

        fe-&gt;reinit (elem);

        Re.resize (n_dofs);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var=0; var&lt;3; var++)
          Re_var[var].reposition (var*n_var_dofs, n_var_dofs);

        Ke.resize (n_dofs, n_dofs);
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var_i=0; var_i&lt;3; var_i++)
          <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var_j=0; var_j&lt;3; var_j++)
            Ke_var[var_i][var_j].reposition (var_i*n_var_dofs, var_j*n_var_dofs, n_var_dofs, n_var_dofs);

        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> qp=0; qp&lt;qrule.n_points(); qp++)
          {
            DenseMatrix&lt;Number&gt; grad_u(3, 3);
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var_i=0; var_i&lt;3; var_i++)
              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var_j=0; var_j&lt;3; var_j++)
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;n_var_dofs; j++)
                  grad_u(var_i, var_j) += dphi[j][qp](var_j)*soln(dof_indices_var[var_i][j]);

            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dof_i=0; dof_i&lt;n_var_dofs; dof_i++)
              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;3; i++)
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;3; j++)
                  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> k=0; k&lt;3; k++)
                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> l=0; l&lt;3; l++)
                      Re_var[i](dof_i) -= JxW[qp] *
                        elasticity_tensor(young_modulus, poisson_ratio, i, j, k, l) * grad_u(k,l) * dphi[dof_i][qp](j);

            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dof_i=0; dof_i&lt;n_var_dofs; dof_i++)
              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dof_j=0; dof_j&lt;n_var_dofs; dof_j++)
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;3; i++)
                  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;3; j++)
                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> k=0; k&lt;3; k++)
                      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> l=0; l&lt;3; l++)
                        Ke_var[i][k](dof_i, dof_j) -= JxW[qp] *
                          elasticity_tensor(young_modulus, poisson_ratio, i, j, k, l) * dphi[dof_j][qp](l) * dphi[dof_i][qp](j);
          }

        dof_map.constrain_element_matrix_and_vector (Ke, Re, dof_indices);

        <B><FONT COLOR="#A020F0">if</FONT></B> (jacobian)
          jacobian-&gt;add_matrix (Ke, dof_indices);

        <B><FONT COLOR="#A020F0">if</FONT></B> (residual)
          residual-&gt;add_vector (Re, dof_indices);
      }

    UniquePtr&lt;MeshBase&gt; mesh_clone = mesh.clone();
    move_mesh(*mesh_clone, soln);

    _lambda_plus_penalty_values.clear();

    LIBMESH_BEST_UNORDERED_MAP&lt;dof_id_type, dof_id_type&gt;::iterator it =
      _augment_sparsity._contact_node_map.begin();
    LIBMESH_BEST_UNORDERED_MAP&lt;dof_id_type, dof_id_type&gt;::iterator it_end =
      _augment_sparsity._contact_node_map.end();

    <B><FONT COLOR="#A020F0">for</FONT></B> ( ; it != it_end; ++it)
      {
        dof_id_type lower_point_id = it-&gt;first;
        dof_id_type upper_point_id = it-&gt;second;

        Point upper_to_lower;
        {
          Point lower_node_moved = mesh_clone-&gt;point(lower_point_id);
          Point upper_node_moved = mesh_clone-&gt;node(upper_point_id);

          upper_to_lower = (lower_node_moved - upper_node_moved);
        }

        Point contact_force_direction(0., 0., 1.);

        Real gap_function = upper_to_lower * contact_force_direction;

        Real lambda_plus_penalty =
          (_lambdas[upper_point_id] + gap_function * _contact_penalty);

        <B><FONT COLOR="#A020F0">if</FONT></B> (lambda_plus_penalty &lt; 0.)
          lambda_plus_penalty = 0.;

        _lambda_plus_penalty_values[upper_point_id] = lambda_plus_penalty;

        <B><FONT COLOR="#228B22">const</FONT></B> Node &amp; lower_node = mesh.node(lower_point_id);
        <B><FONT COLOR="#228B22">const</FONT></B> Node &amp; upper_node = mesh.node(upper_point_id);

        <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;dof_id_type&gt; dof_indices_on_lower_node(3);
        <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;dof_id_type&gt; dof_indices_on_upper_node(3);
        DenseVector&lt;Number&gt; lower_contact_force_vec(3);
        DenseVector&lt;Number&gt; upper_contact_force_vec(3);

        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var=0; var&lt;3; var++)
          {
            dof_indices_on_lower_node[var] = lower_node.dof_number(_sys.number(), var, 0);
            lower_contact_force_vec(var) = -lambda_plus_penalty * contact_force_direction(var);

            dof_indices_on_upper_node[var] = upper_node.dof_number(_sys.number(), var, 0);
            upper_contact_force_vec(var) = lambda_plus_penalty * contact_force_direction(var);
          }

        <B><FONT COLOR="#A020F0">if</FONT></B> (lambda_plus_penalty &gt; 0.)
          {
            <B><FONT COLOR="#A020F0">if</FONT></B> (residual &amp;&amp; (_sys.comm().rank() == 0))
              {
                residual-&gt;add_vector (lower_contact_force_vec, dof_indices_on_lower_node);
                residual-&gt;add_vector (upper_contact_force_vec, dof_indices_on_upper_node);
              }

            <B><FONT COLOR="#A020F0">if</FONT></B> (jacobian &amp;&amp; (_sys.comm().rank() == 0))
              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var=0; var&lt;3; var++)
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;3; j++)
                  {
                    jacobian-&gt;add(dof_indices_on_lower_node[var],
                                  dof_indices_on_upper_node[j],
                                  _contact_penalty * contact_force_direction(j) * contact_force_direction(var));

                    jacobian-&gt;add(dof_indices_on_lower_node[var],
                                  dof_indices_on_lower_node[j],
                                  -_contact_penalty * contact_force_direction(j) * contact_force_direction(var));

                    jacobian-&gt;add(dof_indices_on_upper_node[var],
                                  dof_indices_on_lower_node[j],
                                  _contact_penalty * contact_force_direction(j) * contact_force_direction(var));

                    jacobian-&gt;add(dof_indices_on_upper_node[var],
                                  dof_indices_on_upper_node[j],
                                  -_contact_penalty * contact_force_direction(j) * contact_force_direction(var));
                  }
          }
        <B><FONT COLOR="#A020F0">else</FONT></B>
          {
            <B><FONT COLOR="#A020F0">if</FONT></B> (jacobian &amp;&amp; (_sys.comm().rank() == 0))
              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var=0; var&lt;3; var++)
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;3; j++)
                  {
                    jacobian-&gt;add(dof_indices_on_lower_node[var],
                                  dof_indices_on_upper_node[j],
                                  0.);

                    jacobian-&gt;add(dof_indices_on_lower_node[var],
                                  dof_indices_on_lower_node[j],
                                  0.);

                    jacobian-&gt;add(dof_indices_on_upper_node[var],
                                  dof_indices_on_lower_node[j],
                                  0.);

                    jacobian-&gt;add(dof_indices_on_upper_node[var],
                                  dof_indices_on_upper_node[j],
                                  0.);
                  }
          }
      }
  }

  <B><FONT COLOR="#228B22">void</FONT></B> LinearElasticityWithContact::compute_stresses()
  {
    EquationSystems &amp; es = _sys.get_equation_systems();
    <B><FONT COLOR="#228B22">const</FONT></B> Real young_modulus = es.parameters.get&lt;Real&gt;(<B><FONT COLOR="#BC8F8F">&quot;young_modulus&quot;</FONT></B>);
    <B><FONT COLOR="#228B22">const</FONT></B> Real poisson_ratio = es.parameters.get&lt;Real&gt;(<B><FONT COLOR="#BC8F8F">&quot;poisson_ratio&quot;</FONT></B>);

    <B><FONT COLOR="#228B22">const</FONT></B> MeshBase &amp; mesh = _sys.get_mesh();
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dim = mesh.mesh_dimension();

    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> displacement_vars[3];
    displacement_vars[0] = _sys.variable_number (<B><FONT COLOR="#BC8F8F">&quot;u&quot;</FONT></B>);
    displacement_vars[1] = _sys.variable_number (<B><FONT COLOR="#BC8F8F">&quot;v&quot;</FONT></B>);
    displacement_vars[2] = _sys.variable_number (<B><FONT COLOR="#BC8F8F">&quot;w&quot;</FONT></B>);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> u_var = _sys.variable_number (<B><FONT COLOR="#BC8F8F">&quot;u&quot;</FONT></B>);

    <B><FONT COLOR="#228B22">const</FONT></B> DofMap &amp; dof_map = _sys.get_dof_map();
    FEType fe_type = dof_map.variable_type(u_var);
    UniquePtr&lt;FEBase&gt; fe (FEBase::build(dim, fe_type));
    QGauss qrule (dim, fe_type.default_quadrature_order());
    fe-&gt;attach_quadrature_rule (&amp;qrule);

    <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;Real&gt; &amp; JxW = fe-&gt;get_JxW();
    <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;RealGradient&gt; &gt; &amp; dphi = fe-&gt;get_dphi();

    ExplicitSystem &amp; stress_system = es.get_system&lt;ExplicitSystem&gt;(<B><FONT COLOR="#BC8F8F">&quot;StressSystem&quot;</FONT></B>);
    <B><FONT COLOR="#228B22">const</FONT></B> DofMap &amp; stress_dof_map = stress_system.get_dof_map();
    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> sigma_vars[6];
    sigma_vars[0] = stress_system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;sigma_00&quot;</FONT></B>);
    sigma_vars[1] = stress_system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;sigma_01&quot;</FONT></B>);
    sigma_vars[2] = stress_system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;sigma_02&quot;</FONT></B>);
    sigma_vars[3] = stress_system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;sigma_11&quot;</FONT></B>);
    sigma_vars[4] = stress_system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;sigma_12&quot;</FONT></B>);
    sigma_vars[5] = stress_system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;sigma_22&quot;</FONT></B>);
    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> vonMises_var = stress_system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;vonMises&quot;</FONT></B>);

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt; std::vector&lt;dof_id_type&gt; &gt; dof_indices_var(_sys.n_vars());
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;dof_id_type&gt; stress_dof_indices_var;

    DenseMatrix&lt;Number&gt; elem_avg_stress_tensor(3, 3);

    <B><FONT COLOR="#5F9EA0">MeshBase</FONT></B>::const_element_iterator       el     = mesh.active_local_elements_begin();
    <B><FONT COLOR="#228B22">const</FONT></B> MeshBase::const_element_iterator end_el = mesh.active_local_elements_end();

    <B><FONT COLOR="#A020F0">for</FONT></B> ( ; el != end_el; ++el)
      {
        <B><FONT COLOR="#228B22">const</FONT></B> Elem * elem = *el;

        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var=0; var&lt;3; var++)
          dof_map.dof_indices (elem, dof_indices_var[var], displacement_vars[var]);

        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n_var_dofs = dof_indices_var[0].size();

        fe-&gt;reinit (elem);

        elem_avg_stress_tensor.resize(3, 3);

        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> qp=0; qp&lt;qrule.n_points(); qp++)
          {
            DenseMatrix&lt;Number&gt; grad_u(3, 3);
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var_i=0; var_i&lt;3; var_i++)
              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var_j=0; var_j&lt;3; var_j++)
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;n_var_dofs; j++)
                  grad_u(var_i, var_j) +=
                    dphi[j][qp](var_j) * _sys.current_solution(dof_indices_var[var_i][j]);

            DenseMatrix&lt;Number&gt; stress_tensor(3, 3);
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;3; i++)
              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;3; j++)
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> k=0; k&lt;3; k++)
                  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> l=0; l&lt;3; l++)
                    stress_tensor(i,j) +=
                      elasticity_tensor(young_modulus, poisson_ratio, i, j, k, l) * grad_u(k,l);

            elem_avg_stress_tensor.add(JxW[qp], stress_tensor);
          }

        elem_avg_stress_tensor.scale(1./elem-&gt;volume());

        <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> stress_var_index = 0;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;3; i++)
          <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=i; j&lt;3; j++)
            {
              stress_dof_map.dof_indices (elem, stress_dof_indices_var, sigma_vars[stress_var_index]);

              dof_id_type dof_index = stress_dof_indices_var[0];

              <B><FONT COLOR="#A020F0">if</FONT></B> ((stress_system.solution-&gt;first_local_index() &lt;= dof_index) &amp;&amp;
                  (dof_index &lt; stress_system.solution-&gt;last_local_index()))
                stress_system.solution-&gt;set(dof_index, elem_avg_stress_tensor(i,j));

              stress_var_index++;
            }

        Number vonMises_value = std::sqrt(0.5*(pow(elem_avg_stress_tensor(0,0) - elem_avg_stress_tensor(1,1), 2.) +
                                               pow(elem_avg_stress_tensor(1,1) - elem_avg_stress_tensor(2,2), 2.) +
                                               pow(elem_avg_stress_tensor(2,2) - elem_avg_stress_tensor(0,0), 2.) +
                                               6.*(pow(elem_avg_stress_tensor(0,1), 2.) +
                                                   pow(elem_avg_stress_tensor(1,2), 2.) +
                                                   pow(elem_avg_stress_tensor(2,0), 2.))));

        stress_dof_map.dof_indices (elem, stress_dof_indices_var, vonMises_var);
        dof_id_type dof_index = stress_dof_indices_var[0];

        <B><FONT COLOR="#A020F0">if</FONT></B> ((stress_system.solution-&gt;first_local_index() &lt;= dof_index) &amp;&amp;
            (dof_index &lt; stress_system.solution-&gt;last_local_index()))
          stress_system.solution-&gt;set(dof_index, vonMises_value);
      }

    stress_system.solution-&gt;close();
    stress_system.update();
  }

  <B><FONT COLOR="#5F9EA0">std</FONT></B>::pair&lt;Real, Real&gt; LinearElasticityWithContact::update_lambdas()
  {
    Real max_delta_lambda = 0.;
    Real max_new_lambda = 0.;

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::map&lt;dof_id_type, Real&gt;::iterator it = _lambdas.begin();
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::map&lt;dof_id_type, Real&gt;::iterator it_end = _lambdas.end();
    <B><FONT COLOR="#A020F0">for</FONT></B> ( ; it != it_end; ++it)
      {
        dof_id_type upper_node_id = it-&gt;first;

        <B><FONT COLOR="#5F9EA0">std</FONT></B>::map&lt;dof_id_type, Real&gt;::iterator new_lambda_it = _lambda_plus_penalty_values.find(upper_node_id);
        <B><FONT COLOR="#A020F0">if</FONT></B> (new_lambda_it == _lambda_plus_penalty_values.end())
          libmesh_error_msg(<B><FONT COLOR="#BC8F8F">&quot;New lambda value not found&quot;</FONT></B>);

        Real new_lambda = new_lambda_it-&gt;second;
        Real old_lambda = it-&gt;second;

        it-&gt;second = new_lambda;

        Real delta_lambda = std::abs(new_lambda-old_lambda);
        <B><FONT COLOR="#A020F0">if</FONT></B> (delta_lambda &gt; max_delta_lambda)
          max_delta_lambda = delta_lambda;

        <B><FONT COLOR="#A020F0">if</FONT></B> (std::abs(new_lambda) &gt; max_new_lambda)
          max_new_lambda = std::abs(new_lambda);
      }

    <B><FONT COLOR="#A020F0">return</FONT></B> std::make_pair(max_delta_lambda, max_new_lambda);
  }

  <B><FONT COLOR="#5F9EA0">std</FONT></B>::pair&lt;Real, Real&gt; LinearElasticityWithContact::get_least_and_max_gap_function()
  {
    UniquePtr&lt;MeshBase&gt; mesh_clone = _sys.get_mesh().clone();
    move_mesh(*mesh_clone, *_sys.solution);

    Real least_value = std::numeric_limits&lt;Real&gt;::max();
    Real max_value = std::numeric_limits&lt;Real&gt;::min();

    LIBMESH_BEST_UNORDERED_MAP&lt;dof_id_type, dof_id_type&gt;::iterator it =
      _augment_sparsity._contact_node_map.begin();
    LIBMESH_BEST_UNORDERED_MAP&lt;dof_id_type, dof_id_type&gt;::iterator it_end =
      _augment_sparsity._contact_node_map.end();
    <B><FONT COLOR="#A020F0">for</FONT></B> ( ; it != it_end; ++it)
      {
        dof_id_type lower_point_id = it-&gt;first;
        dof_id_type upper_point_id = it-&gt;second;

        Point upper_to_lower;
        {
          Point lower_node_moved = mesh_clone-&gt;point(lower_point_id);
          Point upper_node_moved = mesh_clone-&gt;node(upper_point_id);

          upper_to_lower = (lower_node_moved - upper_node_moved);
        }

        Point contact_force_direction(0., 0., 1.);

        Real gap_function = upper_to_lower * contact_force_direction;

        <B><FONT COLOR="#A020F0">if</FONT></B> (gap_function &lt; least_value)
          least_value = gap_function;

        <B><FONT COLOR="#A020F0">if</FONT></B> (gap_function &gt; max_value)
          max_value = gap_function;
      }

    <B><FONT COLOR="#A020F0">return</FONT></B> std::make_pair(least_value, max_value);
  }
</pre>
<a name="nocomments"></a>
<br><br><br> <h1> The source file systems_of_equations_ex8.C without comments: </h1>
<pre>
  #include &lt;iostream&gt;

  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/libmesh.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/serial_mesh.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/exodusII_io.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/equation_systems.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/dof_map.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/numeric_vector.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/getpot.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/dirichlet_boundaries.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/string_to_enum.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/zero_function.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/nonlinear_solver.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/nonlinear_implicit_system.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/petsc_macro.h&quot;</FONT></B>

  #include <B><FONT COLOR="#BC8F8F">&quot;linear_elasticity_with_contact.h&quot;</FONT></B>

  using namespace libMesh;

  <B><FONT COLOR="#228B22">int</FONT></B> main (<B><FONT COLOR="#228B22">int</FONT></B> argc, <B><FONT COLOR="#228B22">char</FONT></B> ** argv)
  {
    LibMeshInit init (argc, argv);

    libmesh_example_requires(libMesh::default_solver_package() == PETSC_SOLVERS, <B><FONT COLOR="#BC8F8F">&quot;--enable-petsc&quot;</FONT></B>);

  #<B><FONT COLOR="#A020F0">if</FONT></B> PETSC_VERSION_LESS_THAN(3,5,0)
    libmesh_example_requires(false, <B><FONT COLOR="#BC8F8F">&quot;PETSc &gt;= 3.5.0&quot;</FONT></B>);
  #endif

    GetPot infile(<B><FONT COLOR="#BC8F8F">&quot;systems_of_equations_ex8.in&quot;</FONT></B>);
    <B><FONT COLOR="#228B22">const</FONT></B> std::string approx_order = infile(<B><FONT COLOR="#BC8F8F">&quot;approx_order&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;FIRST&quot;</FONT></B>);
    <B><FONT COLOR="#228B22">const</FONT></B> std::string fe_family = infile(<B><FONT COLOR="#BC8F8F">&quot;fe_family&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;LAGRANGE&quot;</FONT></B>);

    <B><FONT COLOR="#228B22">const</FONT></B> Real young_modulus = infile(<B><FONT COLOR="#BC8F8F">&quot;Young_modulus&quot;</FONT></B>, 1.0);
    <B><FONT COLOR="#228B22">const</FONT></B> Real poisson_ratio = infile(<B><FONT COLOR="#BC8F8F">&quot;poisson_ratio&quot;</FONT></B>, 0.3);

    <B><FONT COLOR="#228B22">const</FONT></B> Real nonlinear_abs_tol = infile(<B><FONT COLOR="#BC8F8F">&quot;nonlinear_abs_tol&quot;</FONT></B>, 1.e-8);
    <B><FONT COLOR="#228B22">const</FONT></B> Real nonlinear_rel_tol = infile(<B><FONT COLOR="#BC8F8F">&quot;nonlinear_rel_tol&quot;</FONT></B>, 1.e-8);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> nonlinear_max_its = infile(<B><FONT COLOR="#BC8F8F">&quot;nonlinear_max_its&quot;</FONT></B>, 50);
    <B><FONT COLOR="#228B22">const</FONT></B> Real contact_penalty = infile(<B><FONT COLOR="#BC8F8F">&quot;contact_penalty&quot;</FONT></B>, 1.e2);
    <B><FONT COLOR="#228B22">const</FONT></B> Real gap_function_tol = infile(<B><FONT COLOR="#BC8F8F">&quot;gap_function_tol&quot;</FONT></B>, 1.e-8);

    SerialMesh mesh(init.comm());
    mesh.read(<B><FONT COLOR="#BC8F8F">&quot;systems_of_equations_ex8.exo&quot;</FONT></B>);

    mesh.print_info();

    EquationSystems equation_systems (mesh);

    NonlinearImplicitSystem &amp; system =
      equation_systems.add_system&lt;NonlinearImplicitSystem&gt; (<B><FONT COLOR="#BC8F8F">&quot;NonlinearElasticity&quot;</FONT></B>);

    LinearElasticityWithContact le(system, contact_penalty);

    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> u_var =
      system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;u&quot;</FONT></B>,
                          <B><FONT COLOR="#5F9EA0">Utility</FONT></B>::string_to_enum&lt;Order&gt;   (approx_order),
                          <B><FONT COLOR="#5F9EA0">Utility</FONT></B>::string_to_enum&lt;FEFamily&gt;(fe_family));

    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> v_var =
      system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;v&quot;</FONT></B>,
                          <B><FONT COLOR="#5F9EA0">Utility</FONT></B>::string_to_enum&lt;Order&gt;   (approx_order),
                          <B><FONT COLOR="#5F9EA0">Utility</FONT></B>::string_to_enum&lt;FEFamily&gt;(fe_family));

    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> w_var =
      system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;w&quot;</FONT></B>,
                          <B><FONT COLOR="#5F9EA0">Utility</FONT></B>::string_to_enum&lt;Order&gt;   (approx_order),
                          <B><FONT COLOR="#5F9EA0">Utility</FONT></B>::string_to_enum&lt;FEFamily&gt;(fe_family));

    ExplicitSystem &amp; stress_system =
      equation_systems.add_system&lt;ExplicitSystem&gt; (<B><FONT COLOR="#BC8F8F">&quot;StressSystem&quot;</FONT></B>);

    stress_system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;sigma_00&quot;</FONT></B>, CONSTANT, MONOMIAL);
    stress_system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;sigma_01&quot;</FONT></B>, CONSTANT, MONOMIAL);
    stress_system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;sigma_02&quot;</FONT></B>, CONSTANT, MONOMIAL);
    stress_system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;sigma_11&quot;</FONT></B>, CONSTANT, MONOMIAL);
    stress_system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;sigma_12&quot;</FONT></B>, CONSTANT, MONOMIAL);
    stress_system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;sigma_22&quot;</FONT></B>, CONSTANT, MONOMIAL);
    stress_system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;vonMises&quot;</FONT></B>, CONSTANT, MONOMIAL);

    equation_systems.parameters.set&lt;Real&gt; (<B><FONT COLOR="#BC8F8F">&quot;nonlinear solver absolute residual tolerance&quot;</FONT></B>) = nonlinear_abs_tol;
    equation_systems.parameters.set&lt;Real&gt; (<B><FONT COLOR="#BC8F8F">&quot;nonlinear solver relative residual tolerance&quot;</FONT></B>) = nonlinear_rel_tol;
    equation_systems.parameters.set&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; (<B><FONT COLOR="#BC8F8F">&quot;nonlinear solver maximum iterations&quot;</FONT></B>) = nonlinear_max_its;

    system.nonlinear_solver-&gt;residual_and_jacobian_object = &amp;le;

    equation_systems.parameters.set&lt;Real&gt;(<B><FONT COLOR="#BC8F8F">&quot;young_modulus&quot;</FONT></B>) = young_modulus;
    equation_systems.parameters.set&lt;Real&gt;(<B><FONT COLOR="#BC8F8F">&quot;poisson_ratio&quot;</FONT></B>) = poisson_ratio;

    {
      <B><FONT COLOR="#5F9EA0">std</FONT></B>::set&lt;boundary_id_type&gt; clamped_boundaries;
      clamped_boundaries.insert(MIN_Z_BOUNDARY);

      <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; uvw;
      uvw.push_back(u_var);
      uvw.push_back(v_var);
      uvw.push_back(w_var);

      ZeroFunction&lt;Number&gt; zero;

      system.get_dof_map().add_dirichlet_boundary(DirichletBoundary (clamped_boundaries, uvw, &amp;zero));
    }
    {
      <B><FONT COLOR="#5F9EA0">std</FONT></B>::set&lt;boundary_id_type&gt; clamped_boundaries;
      clamped_boundaries.insert(MAX_Z_BOUNDARY);

      <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; uv;
      uv.push_back(u_var);
      uv.push_back(v_var);

      ZeroFunction&lt;Number&gt; zero;

      system.get_dof_map().add_dirichlet_boundary(DirichletBoundary (clamped_boundaries, uv, &amp;zero));
    }
    {
      <B><FONT COLOR="#5F9EA0">std</FONT></B>::set&lt;boundary_id_type&gt; clamped_boundaries;
      clamped_boundaries.insert(MAX_Z_BOUNDARY);

      <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; w;
      w.push_back(w_var);

      ConstFunction&lt;Number&gt; neg_one(-1.);

      system.get_dof_map().add_dirichlet_boundary(DirichletBoundary (clamped_boundaries, w, &amp;neg_one));
    }

    le.initialize_contact_load_paths();

    system.get_dof_map().attach_extra_sparsity_object(le.get_augment_sparsity());

    equation_systems.init();
    equation_systems.print_info();

    <B><FONT COLOR="#5F9EA0">libMesh</FONT></B>::out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Contact penalty: &quot;</FONT></B> &lt;&lt; contact_penalty  &lt;&lt; std::endl &lt;&lt; std::endl;

    Real current_max_gap_function = std::numeric_limits&lt;Real&gt;::max();

    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> outer_iteration = 0;
    <B><FONT COLOR="#A020F0">while</FONT></B> (current_max_gap_function &gt; gap_function_tol)
      {
        <B><FONT COLOR="#5F9EA0">libMesh</FONT></B>::out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Starting outer iteration &quot;</FONT></B> &lt;&lt; outer_iteration &lt;&lt; std::endl;

        system.solve();
        system.nonlinear_solver-&gt;print_converged_reason();

        le.update_lambdas();

        <B><FONT COLOR="#5F9EA0">std</FONT></B>::pair&lt;Real, Real&gt; least_and_max_gap_function = le.get_least_and_max_gap_function();
        Real least_gap_fn = least_and_max_gap_function.first;
        Real max_gap_fn = least_and_max_gap_function.second;

        <B><FONT COLOR="#5F9EA0">libMesh</FONT></B>::out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Finished outer iteration, least gap function: &quot;</FONT></B>
                     &lt;&lt; least_gap_fn
                     &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;, max gap function: &quot;</FONT></B>
                     &lt;&lt; max_gap_fn
                     &lt;&lt; std::endl
                     &lt;&lt; std::endl;

        current_max_gap_function = std::max(std::abs(least_gap_fn), std::abs(max_gap_fn));

        outer_iteration++;
      }

    <B><FONT COLOR="#5F9EA0">libMesh</FONT></B>::out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Computing stresses...&quot;</FONT></B> &lt;&lt; std::endl;

    le.compute_stresses();

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream filename;
    filename &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;solution.exo&quot;</FONT></B>;
    ExodusII_IO (mesh).write_equation_systems(filename.str(),
                                              equation_systems);

    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  }
</pre>
<a name="output"></a>
<br><br><br> <h1> The console output of the program: </h1>
<pre>
***************************************************************
* Running Example systems_of_equations_ex8:
*   example-opt
***************************************************************

 Mesh Information:
  elem_dimensions()={3}
  spatial_dimension()=3
  n_nodes()=1868
    n_local_nodes()=1868
  n_elem()=8371
    n_local_elem()=8371
    n_active_elem()=8371
  n_subdomains()=2
  n_partitions()=1
  n_processors()=1
  n_threads()=1
  processor_id()=0

*** Warning, This code is deprecated, and likely to be removed in future library versions! ../../../include/libmesh/type_vector.h, line 878, compiled Apr 12 2016 at 11:21:19 ***
 EquationSystems
  n_systems()=2
   System #0, "NonlinearElasticity"
    Type "NonlinearImplicit"
    Variables={ "u" "v" "w" }
    Finite Element Types="LAGRANGE", "JACOBI_20_00"
    Infinite Element Mapping="CARTESIAN"
    Approximation Orders="FIRST", "THIRD"
    n_dofs()=5604
    n_local_dofs()=5604
    n_constrained_dofs()=264
    n_local_constrained_dofs()=264
    n_vectors()=1
    n_matrices()=1
    DofMap Sparsity
      Average  On-Processor Bandwidth <= 38.7591
      Average Off-Processor Bandwidth <= 0
      Maximum  On-Processor Bandwidth <= 69
      Maximum Off-Processor Bandwidth <= 0
    DofMap Constraints
      Number of DoF Constraints = 264
      Number of Heterogenous Constraints= 44
      Average DoF Constraint Length= 0
   System #1, "StressSystem"
    Type "Explicit"
    Variables={ "sigma_00" "sigma_01" "sigma_02" "sigma_11" "sigma_12" "sigma_22" "vonMises" }
    Finite Element Types="MONOMIAL", "JACOBI_20_00"
    Infinite Element Mapping="CARTESIAN"
    Approximation Orders="CONSTANT", "THIRD"
    n_dofs()=58597
    n_local_dofs()=58597
    n_constrained_dofs()=0
    n_local_constrained_dofs()=0
    n_vectors()=1
    n_matrices()=0
    DofMap Sparsity
      Average  On-Processor Bandwidth <= 0
      Average Off-Processor Bandwidth <= 0
      Maximum  On-Processor Bandwidth <= 0
      Maximum Off-Processor Bandwidth <= 0
    DofMap Constraints
      Number of DoF Constraints = 0

Contact penalty: 10

Starting outer iteration 0
  NL step  0, |residual|_2 = 2.504770e+00
  NL step  1, |residual|_2 = 2.504023e+00
  NL step  2, |residual|_2 = 1.021332e-05
Nonlinear solver convergence/divergence reason: CONVERGED_FNORM_RELATIVE
Finished outer iteration, least gap function: 2.595588e-04, max gap function: 1.289789e-03

Starting outer iteration 1
  NL step  0, |residual|_2 = 7.317881e-02
  NL step  1, |residual|_2 = 9.444942e-09
Nonlinear solver convergence/divergence reason: CONVERGED_FNORM_RELATIVE
Finished outer iteration, least gap function: -4.827715e-06, max gap function: 7.559258e-06

Starting outer iteration 2
  NL step  0, |residual|_2 = 3.164300e-04
  NL step  1, |residual|_2 = 4.087461e-11
Nonlinear solver convergence/divergence reason: CONVERGED_FNORM_RELATIVE
Finished outer iteration, least gap function: -1.029859e-07, max gap function: 1.056082e-07

Starting outer iteration 3
  NL step  0, |residual|_2 = 4.234874e-06
  NL step  1, |residual|_2 = 4.619278e-13
Nonlinear solver convergence/divergence reason: CONVERGED_FNORM_ABS
Finished outer iteration, least gap function: -1.730069e-09, max gap function: 2.019234e-09

Computing stresses...

 -------------------------------------------------------------------------------------------------------------------
| Time:           Tue Apr 12 15:03:13 2016                                                                          |
| OS:             Darwin                                                                                            |
| HostName:       peterson-laptop.local                                                                             |
| OS Release:     15.0.0                                                                                            |
| OS Version:     Darwin Kernel Version 15.0.0: Sat Sep 19 15:53:46 PDT 2015; root:xnu-3247.10.11~1/RELEASE_X86_64  |
| Machine:        x86_64                                                                                            |
| Username:       petejw                                                                                            |
| Configuration:  ../configure  'INSTALL=/usr/bin/install -C'                                                       |
|  '--with-methods=opt dbg'                                                                                         |
|  '--prefix=/Users/petejw/projects/libmesh_git/installed'                                                          |
|  '--enable-perflog'                                                                                               |
|  '--enable-tracefiles'                                                                                            |
|  '--disable-blocked-storage'                                                                                      |
|  '--enable-default-comm-world'                                                                                    |
|  '--enable-tecio'                                                                                                 |
|  '--enable-unique-ptr'                                                                                            |
|  '--enable-ifem'                                                                                                  |
|  'PETSC_DIR=/opt/moose/petsc/mpich_petsc-3.6.1/clang-opt-superlu'                                                 |
|  'SLEPC_DIR=/opt/petejw/slepc/3.6.1'                                                                              |
|  'CPPFLAGS= '                                                                                                     |
|  'LIBS= '                                                                                                         |
|  'CPPFLAGS=  '                                                                                                    |
|  'LIBS=  '                                                                                                        |
|  '--disable-netcdf-4'                                                                                             |
|  '--disable-testsets'                                                                                             |
|  'CXX=mpicxx'                                                                                                     |
|  'CC=mpicc'                                                                                                       |
|  'F77=mpif77'                                                                                                     |
|  'FC=mpif90'                                                                                                      |
|  'CPPFLAGS=   '                                                                                                   |
|  'LIBS=   '                                                                                                       |
 -------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------
| libMesh Performance: Alive time=5.17703, Active time=4.97023                                                    |
 -----------------------------------------------------------------------------------------------------------------
| Event                              nCalls     Total Time  Avg Time    Total Time  Avg Time    % of Active Time  |
|                                               w/o Sub     w/o Sub     With Sub    With Sub    w/o S    With S   |
|-----------------------------------------------------------------------------------------------------------------|
|                                                                                                                 |
|                                                                                                                 |
| DofMap                                                                                                          |
|   add_neighbors_to_send_list()     2          0.0039      0.001966    0.0039      0.001966    0.08     0.08     |
|   build_constraint_matrix()        142307     0.0581      0.000000    0.0581      0.000000    1.17     1.17     |
|   build_sparsity()                 1          0.0324      0.032435    0.0355      0.035519    0.65     0.71     |
|   cnstrn_elem_mat_vec()            142307     0.0298      0.000000    0.0298      0.000000    0.60     0.60     |
|   create_dof_constraints()         2          0.0565      0.028251    0.0683      0.034132    1.14     1.37     |
|   distribute_dofs()                2          0.0015      0.000768    0.0101      0.005035    0.03     0.20     |
|   dof_indices()                    912929     0.1695      0.000000    0.1695      0.000000    3.41     3.41     |
|   enforce_constraints_exactly()    21         0.0005      0.000021    0.0005      0.000021    0.01     0.01     |
|   prepare_send_list()              4          0.0000      0.000000    0.0000      0.000000    0.00     0.00     |
|   reinit()                         2          0.0085      0.004266    0.0085      0.004266    0.17     0.17     |
|                                                                                                                 |
| EquationSystems                                                                                                 |
|   build_solution_vector()          1          0.0327      0.032689    0.0494      0.049449    0.66     0.99     |
|                                                                                                                 |
| ExodusII_IO                                                                                                     |
|   write_nodal_data()               1          0.0057      0.005746    0.0057      0.005746    0.12     0.12     |
|                                                                                                                 |
| FE                                                                                                              |
|   compute_shape_functions()        150678     0.0372      0.000000    0.0372      0.000000    0.75     0.75     |
|   init_shape_functions()           18         0.0001      0.000004    0.0001      0.000004    0.00     0.00     |
|                                                                                                                 |
| FEMap                                                                                                           |
|   compute_affine_map()             150678     0.0752      0.000000    0.0752      0.000000    1.51     1.51     |
|   init_reference_to_physical_map() 18         0.0001      0.000006    0.0001      0.000006    0.00     0.00     |
|                                                                                                                 |
| Mesh                                                                                                            |
|   find_neighbors()                 22         0.2897      0.013170    0.2897      0.013170    5.83     5.83     |
|   renumber_nodes_and_elem()        2          0.0004      0.000190    0.0004      0.000190    0.01     0.01     |
|                                                                                                                 |
| MeshOutput                                                                                                      |
|   write_equation_systems()         1          0.0000      0.000023    0.0552      0.055218    0.00     1.11     |
|                                                                                                                 |
| NameBasedIO                                                                                                     |
|   read()                           1          0.0025      0.002519    0.0025      0.002519    0.05     0.05     |
|                                                                                                                 |
| Parallel                                                                                                        |
|   allgather()                      2          0.0000      0.000000    0.0000      0.000000    0.00     0.00     |
|                                                                                                                 |
| Partitioner                                                                                                     |
|   set_node_processor_ids()         21         0.0088      0.000420    0.0088      0.000420    0.18     0.18     |
|   single_partition()               1          0.0001      0.000142    0.0001      0.000142    0.00     0.00     |
|                                                                                                                 |
| PetscNonlinearSolver                                                                                            |
|   jacobian()                       5          1.1969      0.239384    1.4006      0.280123    24.08    28.18    |
|   residual()                       12         2.5609      0.213408    3.0156      0.251304    51.52    60.67    |
|   solve()                          4          0.3978      0.099439    4.8142      1.203555    8.00     96.86    |
|                                                                                                                 |
| System                                                                                                          |
|   solve()                          4          0.0012      0.000304    4.8154      1.203860    0.02     96.89    |
 -----------------------------------------------------------------------------------------------------------------
| Totals:                            1499046    4.9702                                          100.00            |
 -----------------------------------------------------------------------------------------------------------------


***************************************************************
* Done Running Example systems_of_equations_ex8:
*   example-opt
***************************************************************
</pre>
</div>

<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){
  $(window).on('scroll',function() {
    var scrolltop = $(this).scrollTop();

    if(scrolltop >= 215) {
      $('#fixedbar').fadeIn(250);
    }

    else if(scrolltop <= 210) {
      $('#fixedbar').fadeOut(250);
    }
  });
});
</script>

<!-- Google Analytics stuff -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-24978333-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</body>
</html>
