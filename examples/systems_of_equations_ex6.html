<!doctype html>
<html lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
  <title>libMesh - A C++ Finite Element Library</title>
  <meta name="author" content="libMesh development team">
  <link rel="stylesheet" type="text/css" media="all" href="../styles.css">
  <link rel="stylesheet" type="text/css" media="all" href="../doxygen_stylesheet.css">
</head>

<body>
  <nav id="fixedbar">
    <ul id="fixednav">
      <li><a href="../index.html">Home</a></li>
      <li><a href="../support.html">About Us</a></li>
      <li><a href="../publications.html">Publications</a></li>
      <li><a href="https://github.com/libMesh/libmesh/graphs/contributors">Developers</a></li>
      <li><a href="../installation.html">Installation</a></li>
      <li><a href="../examples.html">Examples</a></li>
     <li><a href="../doxygen/index.html">Documentation</a></li>
    </ul>
  </nav>

  <div id="w">
    <header id="logo"><a href="../index.html"><span id="logobg">SomeWebsiteLogo</span></a></header>

    <nav id="navigation">
      <ul>
        <li><a href="../index.html">Home</a></li>
        <li><a href="../support.html">About Us</a></li>
        <li><a href="../publications.html">Publications</a></li>
        <li><a href="https://github.com/libMesh/libmesh/graphs/contributors">Developers</a></li>
        <li><a href="../installation.html">Installation</a></li>
        <li><a href="../examples.html">Examples</a></li>
        <li><a href="../doxygen/index.html">Documentation</a></li>
      </ul>
    </nav>

<div id="content">

<a name="comments"></a>
<br><br><br> <h1> The source file systems_of_equations_ex6.C with comments: </h1>
<div class = "comment">
</div>

<div class ="fragment">
<pre>
        #include &lt;iostream&gt;
        #include &lt;algorithm&gt;
        #include &lt;math.h&gt;

</pre>
</div>
<div class = "comment">
libMesh includes
</div>

<div class ="fragment">
<pre>
        #include "libmesh/libmesh_config.h"
        #include "libmesh/libmesh.h"
        #include "libmesh/mesh.h"
        #include "libmesh/mesh_generation.h"
        #include "libmesh/exodusII_io.h"
        #include "libmesh/gnuplot_io.h"
        #include "libmesh/linear_implicit_system.h"
        #include "libmesh/equation_systems.h"
        #include "libmesh/fe.h"
        #include "libmesh/quadrature_gauss.h"
        #include "libmesh/dof_map.h"
        #include "libmesh/sparse_matrix.h"
        #include "libmesh/numeric_vector.h"
        #include "libmesh/dense_matrix.h"
        #include "libmesh/dense_submatrix.h"
        #include "libmesh/dense_vector.h"
        #include "libmesh/dense_subvector.h"
        #include "libmesh/perf_log.h"
        #include "libmesh/elem.h"
        #include "libmesh/boundary_info.h"
        #include "libmesh/zero_function.h"
        #include "libmesh/dirichlet_boundaries.h"
        #include "libmesh/string_to_enum.h"
        #include "libmesh/getpot.h"
        #include "libmesh/solver_configuration.h"
        #include "libmesh/petsc_linear_solver.h"
        #include "libmesh/petsc_macro.h"
        
        #define x_scaling 1.3

</pre>
</div>
<div class = "comment">
boundary IDs
</div>

<div class ="fragment">
<pre>
        #define BOUNDARY_ID_MIN_Z 0
        #define BOUNDARY_ID_MIN_Y 1
        #define BOUNDARY_ID_MAX_X 2
        #define BOUNDARY_ID_MAX_Y 3
        #define BOUNDARY_ID_MIN_X 4
        #define BOUNDARY_ID_MAX_Z 5
        #define NODE_BOUNDARY_ID 10
        #define EDGE_BOUNDARY_ID 20

</pre>
</div>
<div class = "comment">
Bring in everything from the libMesh namespace
</div>

<div class ="fragment">
<pre>
        using namespace libMesh;

        #ifdef LIBMESH_HAVE_PETSC
</pre>
</div>
<div class = "comment">
This class allows us to set the solver and preconditioner
to be appropriate for linear elasticity.
</div>

<div class ="fragment">
<pre>
        class PetscSolverConfiguration : public SolverConfiguration
        {
        public:

          PetscSolverConfiguration(PetscLinearSolver&lt;Number&gt; & petsc_linear_solver) :
            _petsc_linear_solver(petsc_linear_solver)
          {
          }

          virtual void configure_solver()
          {
            PetscErrorCode ierr = 0;
            ierr = KSPSetType (_petsc_linear_solver.ksp(), const_cast&lt;KSPType&gt;(KSPCG));
            libmesh_assert(ierr == 0);

            ierr = PCSetType (_petsc_linear_solver.pc(), const_cast&lt;PCType&gt;(PCBJACOBI));
            libmesh_assert(ierr == 0);
          }

</pre>
</div>
<div class = "comment">
The linear solver object that we are configuring
</div>

<div class ="fragment">
<pre>
          PetscLinearSolver&lt;Number&gt; & _petsc_linear_solver;

        };
        #endif

        class LinearElasticity : public System::Assembly
        {
        private:
          EquationSystems & es;

        public:

          LinearElasticity (EquationSystems & es_in) :
            es(es_in)
          {}

          /**
           * Kronecker delta function.
           */
          Real kronecker_delta(unsigned int i,
                               unsigned int j)
          {
            return i == j ? 1. : 0.;
          }

          /**
           * Evaluate the fourth order tensor (C_ijkl) that relates stress to strain.
           */
          Real elasticity_tensor(unsigned int i,
                                 unsigned int j,
                                 unsigned int k,
                                 unsigned int l)
          {
</pre>
</div>
<div class = "comment">
Hard code material parameters for the sake of simplicity
</div>

<div class ="fragment">
<pre>
            const Real poisson_ratio = 0.3;
            const Real young_modulus = 1.;

</pre>
</div>
<div class = "comment">
Define the Lame constants
</div>

<div class ="fragment">
<pre>
            const Real lambda_1 = (young_modulus*poisson_ratio)/((1.+poisson_ratio)*(1.-2.*poisson_ratio));
            const Real lambda_2 = young_modulus/(2.*(1.+poisson_ratio));

            return lambda_1 * kronecker_delta(i, j) * kronecker_delta(k, l) +
              lambda_2 * (kronecker_delta(i, k) * kronecker_delta(j, l) + kronecker_delta(i, l) * kronecker_delta(j, k));
          }

          /**
           * Assemble the system matrix and right-hand side vector.
           */
          void assemble()
          {
            const MeshBase & mesh = es.get_mesh();

            const unsigned int dim = mesh.mesh_dimension();

            LinearImplicitSystem & system = es.get_system&lt;LinearImplicitSystem&gt;("Elasticity");

            const unsigned int u_var = system.variable_number ("u");

            const DofMap & dof_map = system.get_dof_map();
            FEType fe_type = dof_map.variable_type(u_var);
            UniquePtr&lt;FEBase&gt; fe (FEBase::build(dim, fe_type));
            QGauss qrule (dim, fe_type.default_quadrature_order());
            fe-&gt;attach_quadrature_rule (&qrule);

            UniquePtr&lt;FEBase&gt; fe_face (FEBase::build(dim, fe_type));
            QGauss qface(dim-1, fe_type.default_quadrature_order());
            fe_face-&gt;attach_quadrature_rule (&qface);

            const std::vector&lt;Real&gt; & JxW = fe-&gt;get_JxW();
            const std::vector&lt;std::vector&lt;Real&gt; &gt; & phi = fe-&gt;get_phi();
            const std::vector&lt;std::vector&lt;RealGradient&gt; &gt; & dphi = fe-&gt;get_dphi();

            DenseMatrix&lt;Number&gt; Ke;
            DenseSubMatrix&lt;Number&gt; Ke_var[3][3] =
              {
                {DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke)},
                {DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke)},
                {DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke)}
              };

            DenseVector&lt;Number&gt; Fe;

            DenseSubVector&lt;Number&gt; Fe_var[3] =
              {DenseSubVector&lt;Number&gt;(Fe),
               DenseSubVector&lt;Number&gt;(Fe),
               DenseSubVector&lt;Number&gt;(Fe)};

            std::vector&lt;dof_id_type&gt; dof_indices;
            std::vector&lt; std::vector&lt;dof_id_type&gt; &gt; dof_indices_var(3);

            MeshBase::const_element_iterator       el     = mesh.active_local_elements_begin();
            const MeshBase::const_element_iterator end_el = mesh.active_local_elements_end();

            for ( ; el != end_el; ++el)
              {
                const Elem * elem = *el;

                dof_map.dof_indices (elem, dof_indices);
                for (unsigned int var=0; var&lt;3; var++)
                  dof_map.dof_indices (elem, dof_indices_var[var], var);

                const unsigned int n_dofs   = dof_indices.size();
                const unsigned int n_var_dofs = dof_indices_var[0].size();

                fe-&gt;reinit (elem);

                Ke.resize (n_dofs, n_dofs);
                for (unsigned int var_i=0; var_i&lt;3; var_i++)
                  for (unsigned int var_j=0; var_j&lt;3; var_j++)
                    Ke_var[var_i][var_j].reposition (var_i*n_var_dofs, var_j*n_var_dofs, n_var_dofs, n_var_dofs);

                Fe.resize (n_dofs);
                for (unsigned int var=0; var&lt;3; var++)
                  Fe_var[var].reposition (var*n_var_dofs, n_var_dofs);

                for (unsigned int qp=0; qp&lt;qrule.n_points(); qp++)
                  {
</pre>
</div>
<div class = "comment">
assemble \int_Omega C_ijkl u_k,l v_i,j \dx
</div>

<div class ="fragment">
<pre>
                    for (unsigned int dof_i=0; dof_i&lt;n_var_dofs; dof_i++)
                      for (unsigned int dof_j=0; dof_j&lt;n_var_dofs; dof_j++)
                        for (unsigned int i=0; i&lt;3; i++)
                          for (unsigned int j=0; j&lt;3; j++)
                            for (unsigned int k=0; k&lt;3; k++)
                              for (unsigned int l=0; l&lt;3; l++)
                                Ke_var[i][k](dof_i,dof_j) +=
                                  JxW[qp] * elasticity_tensor(i,j,k,l) * dphi[dof_j][qp](l) * dphi[dof_i][qp](j);

</pre>
</div>
<div class = "comment">
assemble \int_Omega f_i v_i \dx
</div>

<div class ="fragment">
<pre>
                    DenseVector&lt;Number&gt; f_vec(3);
                    f_vec(0) =  0.;
                    f_vec(1) =  0.;
                    f_vec(2) = -1.;
                    for (unsigned int dof_i=0; dof_i&lt;n_var_dofs; dof_i++)
                      for (unsigned int i=0; i&lt;3; i++)
                        Fe_var[i](dof_i) += JxW[qp] * (f_vec(i) * phi[dof_i][qp]);
                  }

</pre>
</div>
<div class = "comment">
assemble \int_\Gamma g_i v_i \ds
</div>

<div class ="fragment">
<pre>
                DenseVector&lt;Number&gt; g_vec(3);
                g_vec(0) = 0.;
                g_vec(1) = 0.;
                g_vec(2) = -1.;
                {
                  for (unsigned int side=0; side&lt;elem-&gt;n_sides(); side++)
                    if (elem-&gt;neighbor(side) == libmesh_nullptr)
                      {
                        const std::vector&lt;std::vector&lt;Real&gt; &gt; & phi_face = fe_face-&gt;get_phi();
                        const std::vector&lt;Real&gt; & JxW_face = fe_face-&gt;get_JxW();

                        fe_face-&gt;reinit(elem, side);

</pre>
</div>
<div class = "comment">
Apply a traction
</div>

<div class ="fragment">
<pre>
                        for (unsigned int qp=0; qp&lt;qface.n_points(); qp++)
                          if (mesh.get_boundary_info().has_boundary_id(elem, side, BOUNDARY_ID_MAX_X))
                            for (unsigned int dof_i=0; dof_i&lt;n_var_dofs; dof_i++)
                              for (unsigned int i=0; i&lt;3; i++)
                                Fe_var[i](dof_i) += JxW_face[qp] * (g_vec(i) * phi_face[dof_i][qp]);
                      }
                }

                dof_map.constrain_element_matrix_and_vector (Ke, Fe, dof_indices);

                system.matrix-&gt;add_matrix (Ke, dof_indices);
                system.rhs-&gt;add_vector    (Fe, dof_indices);
              }
          }
        
</pre>
</div>
<div class = "comment">
Post-process the solution to compute stresses
</div>

<div class ="fragment">
<pre>
          void compute_stresses()
          {
            const MeshBase & mesh = es.get_mesh();
            const unsigned int dim = mesh.mesh_dimension();

            LinearImplicitSystem & system = es.get_system&lt;LinearImplicitSystem&gt;("Elasticity");

            unsigned int displacement_vars[3];
            displacement_vars[0] = system.variable_number ("u");
            displacement_vars[1] = system.variable_number ("v");
            displacement_vars[2] = system.variable_number ("w");
            const unsigned int u_var = system.variable_number ("u");

            const DofMap & dof_map = system.get_dof_map();
            FEType fe_type = dof_map.variable_type(u_var);
            UniquePtr&lt;FEBase&gt; fe (FEBase::build(dim, fe_type));
            QGauss qrule (dim, fe_type.default_quadrature_order());
            fe-&gt;attach_quadrature_rule (&qrule);

            const std::vector&lt;Real&gt; & JxW = fe-&gt;get_JxW();
            const std::vector&lt;std::vector&lt;RealGradient&gt; &gt; & dphi = fe-&gt;get_dphi();

</pre>
</div>
<div class = "comment">
Also, get a reference to the ExplicitSystem
</div>

<div class ="fragment">
<pre>
            ExplicitSystem & stress_system = es.get_system&lt;ExplicitSystem&gt;("StressSystem");
            const DofMap & stress_dof_map = stress_system.get_dof_map();
            unsigned int sigma_vars[6];
            sigma_vars[0] = stress_system.variable_number ("sigma_00");
            sigma_vars[1] = stress_system.variable_number ("sigma_01");
            sigma_vars[2] = stress_system.variable_number ("sigma_02");
            sigma_vars[3] = stress_system.variable_number ("sigma_11");
            sigma_vars[4] = stress_system.variable_number ("sigma_12");
            sigma_vars[5] = stress_system.variable_number ("sigma_22");
            unsigned int vonMises_var = stress_system.variable_number ("vonMises");

</pre>
</div>
<div class = "comment">
Storage for the stress dof indices on each element
</div>

<div class ="fragment">
<pre>
            std::vector&lt; std::vector&lt;dof_id_type&gt; &gt; dof_indices_var(system.n_vars());
            std::vector&lt;dof_id_type&gt; stress_dof_indices_var;

</pre>
</div>
<div class = "comment">
To store the stress tensor on each element
</div>

<div class ="fragment">
<pre>
            DenseMatrix&lt;Number&gt; elem_avg_stress_tensor(3, 3);

            MeshBase::const_element_iterator       el     = mesh.active_local_elements_begin();
            const MeshBase::const_element_iterator end_el = mesh.active_local_elements_end();

            for ( ; el != end_el; ++el)
              {
                const Elem * elem = *el;

                for (unsigned int var=0; var&lt;3; var++)
                  dof_map.dof_indices (elem, dof_indices_var[var], displacement_vars[var]);

                const unsigned int n_var_dofs = dof_indices_var[0].size();

                fe-&gt;reinit (elem);

</pre>
</div>
<div class = "comment">
clear the stress tensor
</div>

<div class ="fragment">
<pre>
                elem_avg_stress_tensor.resize(3, 3);

                for (unsigned int qp=0; qp&lt;qrule.n_points(); qp++)
                  {
                    DenseMatrix&lt;Number&gt; grad_u(3, 3);

</pre>
</div>
<div class = "comment">
Row is variable u1, u2, or u3, column is x, y, or z
</div>

<div class ="fragment">
<pre>
                    for (unsigned int var_i=0; var_i&lt;3; var_i++)
                      for (unsigned int var_j=0; var_j&lt;3; var_j++)
                        for (unsigned int j=0; j&lt;n_var_dofs; j++)
                          grad_u(var_i,var_j) += dphi[j][qp](var_j) * system.current_solution(dof_indices_var[var_i][j]);

                    DenseMatrix&lt;Number&gt; stress_tensor(3, 3);

                    for (unsigned int i=0; i&lt;3; i++)
                      for (unsigned int j=0; j&lt;3; j++)
                        for (unsigned int k=0; k&lt;3; k++)
                          for (unsigned int l=0; l&lt;3; l++)
                            stress_tensor(i,j) += elasticity_tensor(i,j,k,l) * grad_u(k,l);

</pre>
</div>
<div class = "comment">
stress_tensor now holds the stress at point qp.
We want to plot the average stress on each element, hence
we integrate stress_tensor
</div>

<div class ="fragment">
<pre>
                    elem_avg_stress_tensor.add(JxW[qp], stress_tensor);
                  }

</pre>
</div>
<div class = "comment">
Get the average stress per element by dividing by volume
</div>

<div class ="fragment">
<pre>
                elem_avg_stress_tensor.scale(1./elem-&gt;volume());

</pre>
</div>
<div class = "comment">
load elem_sigma data into stress_system
</div>

<div class ="fragment">
<pre>
                unsigned int stress_var_index = 0;
                for (unsigned int i=0; i&lt;3; i++)
                  for (unsigned int j=i; j&lt;3; j++)
                    {
                      stress_dof_map.dof_indices (elem, stress_dof_indices_var, sigma_vars[stress_var_index]);

</pre>
</div>
<div class = "comment">
We are using CONSTANT MONOMIAL basis functions, hence we only need to get
one dof index per variable
</div>

<div class ="fragment">
<pre>
                      dof_id_type dof_index = stress_dof_indices_var[0];

                      if ((stress_system.solution-&gt;first_local_index() &lt;= dof_index) &&
                          (dof_index &lt; stress_system.solution-&gt;last_local_index()))
                        stress_system.solution-&gt;set(dof_index, elem_avg_stress_tensor(i,j));

                      stress_var_index++;
                    }
        
</pre>
</div>
<div class = "comment">
Also, the von Mises stress
</div>

<div class ="fragment">
<pre>
                Number vonMises_value = std::sqrt(0.5*(pow(elem_avg_stress_tensor(0,0) - elem_avg_stress_tensor(1,1), 2.) +
                                                       pow(elem_avg_stress_tensor(1,1) - elem_avg_stress_tensor(2,2), 2.) +
                                                       pow(elem_avg_stress_tensor(2,2) - elem_avg_stress_tensor(0,0), 2.) +
                                                       6.*(pow(elem_avg_stress_tensor(0,1), 2.) +
                                                           pow(elem_avg_stress_tensor(1,2), 2.) +
                                                           pow(elem_avg_stress_tensor(2,0), 2.))));

                stress_dof_map.dof_indices (elem, stress_dof_indices_var, vonMises_var);
                dof_id_type dof_index = stress_dof_indices_var[0];

                if ((stress_system.solution-&gt;first_local_index() &lt;= dof_index) &&
                    (dof_index &lt; stress_system.solution-&gt;last_local_index()))
                  stress_system.solution-&gt;set(dof_index, vonMises_value);
              }
        
</pre>
</div>
<div class = "comment">
Should call close and update when we set vector entries directly
</div>

<div class ="fragment">
<pre>
            stress_system.solution-&gt;close();
            stress_system.update();
          }
        };

        
</pre>
</div>
<div class = "comment">
Begin the main program.
</div>

<div class ="fragment">
<pre>
        int main (int argc, char ** argv)
        {
</pre>
</div>
<div class = "comment">
Initialize libMesh and any dependent libraries
</div>

<div class ="fragment">
<pre>
          LibMeshInit init (argc, argv);

</pre>
</div>
<div class = "comment">
Initialize the cantilever mesh
</div>

<div class ="fragment">
<pre>
          const unsigned int dim = 3;
        
</pre>
</div>
<div class = "comment">
Make sure libMesh was compiled for 3D
</div>

<div class ="fragment">
<pre>
          libmesh_example_requires(dim == LIBMESH_DIM, "3D support");
        
</pre>
</div>
<div class = "comment">
Create a 3D mesh distributed across the default MPI communicator.
</div>

<div class ="fragment">
<pre>
          Mesh mesh(init.comm(), dim);
          MeshTools::Generation::build_cube (mesh,
                                             40,
                                             10,
                                             5,
                                             0., 1.*x_scaling,
                                             0., 0.3,
                                             0., 0.1,
                                             HEX8);
        
        
</pre>
</div>
<div class = "comment">
Print information about the mesh to the screen.
</div>

<div class ="fragment">
<pre>
          mesh.print_info();
        
</pre>
</div>
<div class = "comment">
Let's add some node and edge boundary conditions
</div>

<div class ="fragment">
<pre>
          MeshBase::const_element_iterator       el     = mesh.active_local_elements_begin();
          const MeshBase::const_element_iterator end_el = mesh.active_local_elements_end();
          for ( ; el != end_el; ++el)
            {
              const Elem * elem = *el;
        
              unsigned int
                side_max_x = 0, side_min_y = 0,
                side_max_y = 0, side_max_z = 0;

              bool
                found_side_max_x = false, found_side_max_y = false,
                found_side_min_y = false, found_side_max_z = false;

              for (unsigned int side=0; side&lt;elem-&gt;n_sides(); side++)
                {
                  if (mesh.get_boundary_info().has_boundary_id(elem, side, BOUNDARY_ID_MAX_X))
                    {
                      side_max_x = side;
                      found_side_max_x = true;
                    }
        
                  if (mesh.get_boundary_info().has_boundary_id(elem, side, BOUNDARY_ID_MIN_Y))
                    {
                      side_min_y = side;
                      found_side_min_y = true;
                    }
        
                  if (mesh.get_boundary_info().has_boundary_id(elem, side, BOUNDARY_ID_MAX_Y))
                    {
                      side_max_y = side;
                      found_side_max_y = true;
                    }
        
                  if (mesh.get_boundary_info().has_boundary_id(elem, side, BOUNDARY_ID_MAX_Z))
                    {
                      side_max_z = side;
                      found_side_max_z = true;
                    }
                }
        
</pre>
</div>
<div class = "comment">
If elem has sides on boundaries
BOUNDARY_ID_MAX_X, BOUNDARY_ID_MAX_Y, BOUNDARY_ID_MAX_Z
then let's set a node boundary condition
</div>

<div class ="fragment">
<pre>
              if (found_side_max_x && found_side_max_y && found_side_max_z)
                for (unsigned int n=0; n&lt;elem-&gt;n_nodes(); n++)
                  if (elem-&gt;is_node_on_side(n, side_max_x) &&
                      elem-&gt;is_node_on_side(n, side_max_y) &&
                      elem-&gt;is_node_on_side(n, side_max_z))
                    mesh.get_boundary_info().add_node(elem-&gt;get_node(n), NODE_BOUNDARY_ID);
        
        
</pre>
</div>
<div class = "comment">
If elem has sides on boundaries
BOUNDARY_ID_MAX_X and BOUNDARY_ID_MIN_Y
then let's set an edge boundary condition
</div>

<div class ="fragment">
<pre>
              if (found_side_max_x && found_side_min_y)
                for (unsigned int e=0; e&lt;elem-&gt;n_edges(); e++)
                  if (elem-&gt;is_edge_on_side(e, side_max_x) &&
                      elem-&gt;is_edge_on_side(e, side_min_y))
                    mesh.get_boundary_info().add_edge(elem, e, EDGE_BOUNDARY_ID);
            }
        
</pre>
</div>
<div class = "comment">
Create an equation systems object.
</div>

<div class ="fragment">
<pre>
          EquationSystems equation_systems (mesh);
        
</pre>
</div>
<div class = "comment">
Declare the system and its variables.
Create a system named "Elasticity"
</div>

<div class ="fragment">
<pre>
          LinearImplicitSystem & system =
            equation_systems.add_system&lt;LinearImplicitSystem&gt; ("Elasticity");
        
        #ifdef LIBMESH_HAVE_PETSC
</pre>
</div>
<div class = "comment">
Attach a SolverConfiguration object to system.linear_solver
</div>

<div class ="fragment">
<pre>
          PetscLinearSolver&lt;Number&gt; * petsc_linear_solver =
            libmesh_cast_ptr&lt;PetscLinearSolver&lt;Number&gt;*&gt;(system.get_linear_solver());
          libmesh_assert(petsc_linear_solver);
          PetscSolverConfiguration petsc_solver_config(*petsc_linear_solver);
          petsc_linear_solver-&gt;set_solver_configuration(petsc_solver_config);
        #endif

</pre>
</div>
<div class = "comment">
Add three displacement variables, u and v, to the system
</div>

<div class ="fragment">
<pre>
          unsigned int u_var = system.add_variable("u", FIRST, LAGRANGE);
          unsigned int v_var = system.add_variable("v", FIRST, LAGRANGE);
          unsigned int w_var = system.add_variable("w", FIRST, LAGRANGE);
        
          LinearElasticity le(equation_systems);
          system.attach_assemble_object(le);
        
          std::set&lt;boundary_id_type&gt; boundary_ids;
          boundary_ids.insert(BOUNDARY_ID_MIN_X);
          boundary_ids.insert(NODE_BOUNDARY_ID);
          boundary_ids.insert(EDGE_BOUNDARY_ID);
        
</pre>
</div>
<div class = "comment">
Create a vector storing the variable numbers which the BC applies to
</div>

<div class ="fragment">
<pre>
          std::vector&lt;unsigned int&gt; variables;
          variables.push_back(u_var);
          variables.push_back(v_var);
          variables.push_back(w_var);
        
</pre>
</div>
<div class = "comment">
Create a ZeroFunction to initialize dirichlet_bc
</div>

<div class ="fragment">
<pre>
          ZeroFunction&lt;&gt; zf;
        
          DirichletBoundary dirichlet_bc(boundary_ids,
                                         variables,
                                         &zf);
        
</pre>
</div>
<div class = "comment">
We must add the Dirichlet boundary condition _before_
we call equation_systems.init()
</div>

<div class ="fragment">
<pre>
          system.get_dof_map().add_dirichlet_boundary(dirichlet_bc);
        
</pre>
</div>
<div class = "comment">
Also, initialize an ExplicitSystem to store stresses
</div>

<div class ="fragment">
<pre>
          ExplicitSystem & stress_system =
            equation_systems.add_system&lt;ExplicitSystem&gt; ("StressSystem");
        
          stress_system.add_variable("sigma_00", CONSTANT, MONOMIAL);
          stress_system.add_variable("sigma_01", CONSTANT, MONOMIAL);
          stress_system.add_variable("sigma_02", CONSTANT, MONOMIAL);
          stress_system.add_variable("sigma_11", CONSTANT, MONOMIAL);
          stress_system.add_variable("sigma_12", CONSTANT, MONOMIAL);
          stress_system.add_variable("sigma_22", CONSTANT, MONOMIAL);
          stress_system.add_variable("vonMises", CONSTANT, MONOMIAL);
        
</pre>
</div>
<div class = "comment">
Initialize the data structures for the equation system.
</div>

<div class ="fragment">
<pre>
          equation_systems.init();
        
</pre>
</div>
<div class = "comment">
Print information about the system to the screen.
</div>

<div class ="fragment">
<pre>
          equation_systems.print_info();
        
</pre>
</div>
<div class = "comment">
Solve the system
</div>

<div class ="fragment">
<pre>
          system.solve();
        
</pre>
</div>
<div class = "comment">
Post-process the solution to compute the stresses
</div>

<div class ="fragment">
<pre>
          le.compute_stresses();
        
</pre>
</div>
<div class = "comment">
Plot the solution
</div>

<div class ="fragment">
<pre>
        #ifdef LIBMESH_HAVE_EXODUS_API
        
</pre>
</div>
<div class = "comment">
Use single precision in this case (reduces the size of the exodus file)
</div>

<div class ="fragment">
<pre>
          ExodusII_IO exo_io(mesh, /*single_precision=*/true);
        
</pre>
</div>
<div class = "comment">
First plot the displacement field using a nodal plot
</div>

<div class ="fragment">
<pre>
          std::set&lt;std::string&gt; system_names;
          system_names.insert("Elasticity");
          exo_io.write_equation_systems("displacement_and_stress.exo", equation_systems, &system_names);
        
</pre>
</div>
<div class = "comment">
then append element-based discontinuous plots of the stresses
</div>

<div class ="fragment">
<pre>
          exo_io.write_element_data(equation_systems);
        
        #endif // #ifdef LIBMESH_HAVE_EXODUS_API
        
</pre>
</div>
<div class = "comment">
All done.
</div>

<div class ="fragment">
<pre>
          return 0;
        }
</pre>
</div>

<a name="nocomments"></a> 
<br><br><br> <h1> The source file systems_of_equations_ex6.C without comments: </h1> 
<pre> 
  #include &lt;iostream&gt;
  #include &lt;algorithm&gt;
  #include &lt;math.h&gt;
  
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/libmesh_config.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/libmesh.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/mesh.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/mesh_generation.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/exodusII_io.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/gnuplot_io.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/linear_implicit_system.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/equation_systems.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/fe.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/quadrature_gauss.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/dof_map.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/sparse_matrix.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/numeric_vector.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/dense_matrix.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/dense_submatrix.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/dense_vector.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/dense_subvector.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/perf_log.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/elem.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/boundary_info.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/zero_function.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/dirichlet_boundaries.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/string_to_enum.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/getpot.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/solver_configuration.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/petsc_linear_solver.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/petsc_macro.h&quot;</FONT></B>
  
  #define x_scaling 1.3
  
  #define BOUNDARY_ID_MIN_Z 0
  #define BOUNDARY_ID_MIN_Y 1
  #define BOUNDARY_ID_MAX_X 2
  #define BOUNDARY_ID_MAX_Y 3
  #define BOUNDARY_ID_MIN_X 4
  #define BOUNDARY_ID_MAX_Z 5
  #define NODE_BOUNDARY_ID 10
  #define EDGE_BOUNDARY_ID 20
  
  using namespace libMesh;
  
  #ifdef LIBMESH_HAVE_PETSC
  <B><FONT COLOR="#228B22">class</FONT></B> PetscSolverConfiguration : <B><FONT COLOR="#228B22">public</FONT></B> SolverConfiguration
  {
  <B><FONT COLOR="#228B22">public</FONT></B>:

    PetscSolverConfiguration(PetscLinearSolver&lt;Number&gt; &amp; petsc_linear_solver) :
      _petsc_linear_solver(petsc_linear_solver)
    {
    }

    <B><FONT COLOR="#228B22">virtual</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> configure_solver()
    {
      PetscErrorCode ierr = 0;
      ierr = KSPSetType (_petsc_linear_solver.ksp(), const_cast&lt;KSPType&gt;(KSPCG));
      libmesh_assert(ierr == 0);

      ierr = PCSetType (_petsc_linear_solver.pc(), const_cast&lt;PCType&gt;(PCBJACOBI));
      libmesh_assert(ierr == 0);
    }

    PetscLinearSolver&lt;Number&gt; &amp; _petsc_linear_solver;

  };
  #endif

  <B><FONT COLOR="#228B22">class</FONT></B> LinearElasticity : <B><FONT COLOR="#228B22">public</FONT></B> System::Assembly
  {
  <B><FONT COLOR="#228B22">private</FONT></B>:
    EquationSystems &amp; es;

  <B><FONT COLOR="#228B22">public</FONT></B>:

    LinearElasticity (EquationSystems &amp; es_in) :
      es(es_in)
    {}

    <I><FONT COLOR="#B22222">/**
     * Kronecker delta function.
     */</FONT></I>
    Real kronecker_delta(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i,
                         <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j)
    {
      <B><FONT COLOR="#A020F0">return</FONT></B> i == j ? 1. : 0.;
    }

    <I><FONT COLOR="#B22222">/**
     * Evaluate the fourth order tensor (C_ijkl) that relates stress to strain.
     */</FONT></I>
    Real elasticity_tensor(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i,
                           <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j,
                           <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> k,
                           <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> l)
    {
      <B><FONT COLOR="#228B22">const</FONT></B> Real poisson_ratio = 0.3;
      <B><FONT COLOR="#228B22">const</FONT></B> Real young_modulus = 1.;

      <B><FONT COLOR="#228B22">const</FONT></B> Real lambda_1 = (young_modulus*poisson_ratio)/((1.+poisson_ratio)*(1.-2.*poisson_ratio));
      <B><FONT COLOR="#228B22">const</FONT></B> Real lambda_2 = young_modulus/(2.*(1.+poisson_ratio));

      <B><FONT COLOR="#A020F0">return</FONT></B> lambda_1 * kronecker_delta(i, j) * kronecker_delta(k, l) +
        lambda_2 * (kronecker_delta(i, k) * kronecker_delta(j, l) + kronecker_delta(i, l) * kronecker_delta(j, k));
    }

    <I><FONT COLOR="#B22222">/**
     * Assemble the system matrix and right-hand side vector.
     */</FONT></I>
    <B><FONT COLOR="#228B22">void</FONT></B> assemble()
    {
      <B><FONT COLOR="#228B22">const</FONT></B> MeshBase &amp; mesh = es.get_mesh();

      <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dim = mesh.mesh_dimension();

      LinearImplicitSystem &amp; system = es.get_system&lt;LinearImplicitSystem&gt;(<B><FONT COLOR="#BC8F8F">&quot;Elasticity&quot;</FONT></B>);

      <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> u_var = system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;u&quot;</FONT></B>);

      <B><FONT COLOR="#228B22">const</FONT></B> DofMap &amp; dof_map = system.get_dof_map();
      FEType fe_type = dof_map.variable_type(u_var);
      UniquePtr&lt;FEBase&gt; fe (FEBase::build(dim, fe_type));
      QGauss qrule (dim, fe_type.default_quadrature_order());
      fe-&gt;attach_quadrature_rule (&amp;qrule);

      UniquePtr&lt;FEBase&gt; fe_face (FEBase::build(dim, fe_type));
      QGauss qface(dim-1, fe_type.default_quadrature_order());
      fe_face-&gt;attach_quadrature_rule (&amp;qface);

      <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;Real&gt; &amp; JxW = fe-&gt;get_JxW();
      <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;Real&gt; &gt; &amp; phi = fe-&gt;get_phi();
      <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;RealGradient&gt; &gt; &amp; dphi = fe-&gt;get_dphi();

      DenseMatrix&lt;Number&gt; Ke;
      DenseSubMatrix&lt;Number&gt; Ke_var[3][3] =
        {
          {DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke)},
          {DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke)},
          {DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke)}
        };

      DenseVector&lt;Number&gt; Fe;

      DenseSubVector&lt;Number&gt; Fe_var[3] =
        {DenseSubVector&lt;Number&gt;(Fe),
         DenseSubVector&lt;Number&gt;(Fe),
         DenseSubVector&lt;Number&gt;(Fe)};

      <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;dof_id_type&gt; dof_indices;
      <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt; std::vector&lt;dof_id_type&gt; &gt; dof_indices_var(3);

      <B><FONT COLOR="#5F9EA0">MeshBase</FONT></B>::const_element_iterator       el     = mesh.active_local_elements_begin();
      <B><FONT COLOR="#228B22">const</FONT></B> MeshBase::const_element_iterator end_el = mesh.active_local_elements_end();

      <B><FONT COLOR="#A020F0">for</FONT></B> ( ; el != end_el; ++el)
        {
          <B><FONT COLOR="#228B22">const</FONT></B> Elem * elem = *el;

          dof_map.dof_indices (elem, dof_indices);
          <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var=0; var&lt;3; var++)
            dof_map.dof_indices (elem, dof_indices_var[var], var);

          <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n_dofs   = dof_indices.size();
          <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n_var_dofs = dof_indices_var[0].size();

          fe-&gt;reinit (elem);

          Ke.resize (n_dofs, n_dofs);
          <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var_i=0; var_i&lt;3; var_i++)
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var_j=0; var_j&lt;3; var_j++)
              Ke_var[var_i][var_j].reposition (var_i*n_var_dofs, var_j*n_var_dofs, n_var_dofs, n_var_dofs);

          Fe.resize (n_dofs);
          <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var=0; var&lt;3; var++)
            Fe_var[var].reposition (var*n_var_dofs, n_var_dofs);

          <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> qp=0; qp&lt;qrule.n_points(); qp++)
            {
              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dof_i=0; dof_i&lt;n_var_dofs; dof_i++)
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dof_j=0; dof_j&lt;n_var_dofs; dof_j++)
                  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;3; i++)
                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;3; j++)
                      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> k=0; k&lt;3; k++)
                        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> l=0; l&lt;3; l++)
                          Ke_var[i][k](dof_i,dof_j) +=
                            JxW[qp] * elasticity_tensor(i,j,k,l) * dphi[dof_j][qp](l) * dphi[dof_i][qp](j);

              DenseVector&lt;Number&gt; f_vec(3);
              f_vec(0) =  0.;
              f_vec(1) =  0.;
              f_vec(2) = -1.;
              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dof_i=0; dof_i&lt;n_var_dofs; dof_i++)
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;3; i++)
                  Fe_var[i](dof_i) += JxW[qp] * (f_vec(i) * phi[dof_i][qp]);
            }

          DenseVector&lt;Number&gt; g_vec(3);
          g_vec(0) = 0.;
          g_vec(1) = 0.;
          g_vec(2) = -1.;
          {
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> side=0; side&lt;elem-&gt;n_sides(); side++)
              <B><FONT COLOR="#A020F0">if</FONT></B> (elem-&gt;neighbor(side) == libmesh_nullptr)
                {
                  <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;Real&gt; &gt; &amp; phi_face = fe_face-&gt;get_phi();
                  <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;Real&gt; &amp; JxW_face = fe_face-&gt;get_JxW();

                  fe_face-&gt;reinit(elem, side);

                  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> qp=0; qp&lt;qface.n_points(); qp++)
                    <B><FONT COLOR="#A020F0">if</FONT></B> (mesh.get_boundary_info().has_boundary_id(elem, side, BOUNDARY_ID_MAX_X))
                      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dof_i=0; dof_i&lt;n_var_dofs; dof_i++)
                        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;3; i++)
                          Fe_var[i](dof_i) += JxW_face[qp] * (g_vec(i) * phi_face[dof_i][qp]);
                }
          }

          dof_map.constrain_element_matrix_and_vector (Ke, Fe, dof_indices);

          system.matrix-&gt;add_matrix (Ke, dof_indices);
          system.rhs-&gt;add_vector    (Fe, dof_indices);
        }
    }

    <B><FONT COLOR="#228B22">void</FONT></B> compute_stresses()
    {
      <B><FONT COLOR="#228B22">const</FONT></B> MeshBase &amp; mesh = es.get_mesh();
      <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dim = mesh.mesh_dimension();

      LinearImplicitSystem &amp; system = es.get_system&lt;LinearImplicitSystem&gt;(<B><FONT COLOR="#BC8F8F">&quot;Elasticity&quot;</FONT></B>);

      <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> displacement_vars[3];
      displacement_vars[0] = system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;u&quot;</FONT></B>);
      displacement_vars[1] = system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;v&quot;</FONT></B>);
      displacement_vars[2] = system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;w&quot;</FONT></B>);
      <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> u_var = system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;u&quot;</FONT></B>);

      <B><FONT COLOR="#228B22">const</FONT></B> DofMap &amp; dof_map = system.get_dof_map();
      FEType fe_type = dof_map.variable_type(u_var);
      UniquePtr&lt;FEBase&gt; fe (FEBase::build(dim, fe_type));
      QGauss qrule (dim, fe_type.default_quadrature_order());
      fe-&gt;attach_quadrature_rule (&amp;qrule);

      <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;Real&gt; &amp; JxW = fe-&gt;get_JxW();
      <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;RealGradient&gt; &gt; &amp; dphi = fe-&gt;get_dphi();

      ExplicitSystem &amp; stress_system = es.get_system&lt;ExplicitSystem&gt;(<B><FONT COLOR="#BC8F8F">&quot;StressSystem&quot;</FONT></B>);
      <B><FONT COLOR="#228B22">const</FONT></B> DofMap &amp; stress_dof_map = stress_system.get_dof_map();
      <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> sigma_vars[6];
      sigma_vars[0] = stress_system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;sigma_00&quot;</FONT></B>);
      sigma_vars[1] = stress_system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;sigma_01&quot;</FONT></B>);
      sigma_vars[2] = stress_system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;sigma_02&quot;</FONT></B>);
      sigma_vars[3] = stress_system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;sigma_11&quot;</FONT></B>);
      sigma_vars[4] = stress_system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;sigma_12&quot;</FONT></B>);
      sigma_vars[5] = stress_system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;sigma_22&quot;</FONT></B>);
      <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> vonMises_var = stress_system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;vonMises&quot;</FONT></B>);

      <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt; std::vector&lt;dof_id_type&gt; &gt; dof_indices_var(system.n_vars());
      <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;dof_id_type&gt; stress_dof_indices_var;

      DenseMatrix&lt;Number&gt; elem_avg_stress_tensor(3, 3);

      <B><FONT COLOR="#5F9EA0">MeshBase</FONT></B>::const_element_iterator       el     = mesh.active_local_elements_begin();
      <B><FONT COLOR="#228B22">const</FONT></B> MeshBase::const_element_iterator end_el = mesh.active_local_elements_end();

      <B><FONT COLOR="#A020F0">for</FONT></B> ( ; el != end_el; ++el)
        {
          <B><FONT COLOR="#228B22">const</FONT></B> Elem * elem = *el;

          <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var=0; var&lt;3; var++)
            dof_map.dof_indices (elem, dof_indices_var[var], displacement_vars[var]);

          <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n_var_dofs = dof_indices_var[0].size();

          fe-&gt;reinit (elem);

          elem_avg_stress_tensor.resize(3, 3);
  
          <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> qp=0; qp&lt;qrule.n_points(); qp++)
            {
              DenseMatrix&lt;Number&gt; grad_u(3, 3);

              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var_i=0; var_i&lt;3; var_i++)
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var_j=0; var_j&lt;3; var_j++)
                  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;n_var_dofs; j++)
                    grad_u(var_i,var_j) += dphi[j][qp](var_j) * system.current_solution(dof_indices_var[var_i][j]);

              DenseMatrix&lt;Number&gt; stress_tensor(3, 3);

              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;3; i++)
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;3; j++)
                  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> k=0; k&lt;3; k++)
                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> l=0; l&lt;3; l++)
                      stress_tensor(i,j) += elasticity_tensor(i,j,k,l) * grad_u(k,l);

              elem_avg_stress_tensor.add(JxW[qp], stress_tensor);
            }

          elem_avg_stress_tensor.scale(1./elem-&gt;volume());

          <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> stress_var_index = 0;
          <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;3; i++)
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=i; j&lt;3; j++)
              {
                stress_dof_map.dof_indices (elem, stress_dof_indices_var, sigma_vars[stress_var_index]);

                dof_id_type dof_index = stress_dof_indices_var[0];

                <B><FONT COLOR="#A020F0">if</FONT></B> ((stress_system.solution-&gt;first_local_index() &lt;= dof_index) &amp;&amp;
                    (dof_index &lt; stress_system.solution-&gt;last_local_index()))
                  stress_system.solution-&gt;set(dof_index, elem_avg_stress_tensor(i,j));

                stress_var_index++;
              }

          Number vonMises_value = std::sqrt(0.5*(pow(elem_avg_stress_tensor(0,0) - elem_avg_stress_tensor(1,1), 2.) +
                                                 pow(elem_avg_stress_tensor(1,1) - elem_avg_stress_tensor(2,2), 2.) +
                                                 pow(elem_avg_stress_tensor(2,2) - elem_avg_stress_tensor(0,0), 2.) +
                                                 6.*(pow(elem_avg_stress_tensor(0,1), 2.) +
                                                     pow(elem_avg_stress_tensor(1,2), 2.) +
                                                     pow(elem_avg_stress_tensor(2,0), 2.))));

          stress_dof_map.dof_indices (elem, stress_dof_indices_var, vonMises_var);
          dof_id_type dof_index = stress_dof_indices_var[0];

          <B><FONT COLOR="#A020F0">if</FONT></B> ((stress_system.solution-&gt;first_local_index() &lt;= dof_index) &amp;&amp;
              (dof_index &lt; stress_system.solution-&gt;last_local_index()))
            stress_system.solution-&gt;set(dof_index, vonMises_value);
        }
  
      stress_system.solution-&gt;close();
      stress_system.update();
    }
  };
  
  
  <B><FONT COLOR="#228B22">int</FONT></B> main (<B><FONT COLOR="#228B22">int</FONT></B> argc, <B><FONT COLOR="#228B22">char</FONT></B> ** argv)
  {
    LibMeshInit init (argc, argv);
  
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dim = 3;
  
    libmesh_example_requires(dim == LIBMESH_DIM, <B><FONT COLOR="#BC8F8F">&quot;3D support&quot;</FONT></B>);
  
    Mesh mesh(init.comm(), dim);
    <B><FONT COLOR="#5F9EA0">MeshTools</FONT></B>::Generation::build_cube (mesh,
                                       40,
                                       10,
                                       5,
                                       0., 1.*x_scaling,
                                       0., 0.3,
                                       0., 0.1,
                                       HEX8);
  
  
    mesh.print_info();
  
    <B><FONT COLOR="#5F9EA0">MeshBase</FONT></B>::const_element_iterator       el     = mesh.active_local_elements_begin();
    <B><FONT COLOR="#228B22">const</FONT></B> MeshBase::const_element_iterator end_el = mesh.active_local_elements_end();
    <B><FONT COLOR="#A020F0">for</FONT></B> ( ; el != end_el; ++el)
      {
        <B><FONT COLOR="#228B22">const</FONT></B> Elem * elem = *el;
  
        <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>
          side_max_x = 0, side_min_y = 0,
          side_max_y = 0, side_max_z = 0;

        <B><FONT COLOR="#228B22">bool</FONT></B>
          found_side_max_x = false, found_side_max_y = false,
          found_side_min_y = false, found_side_max_z = false;

        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> side=0; side&lt;elem-&gt;n_sides(); side++)
          {
            <B><FONT COLOR="#A020F0">if</FONT></B> (mesh.get_boundary_info().has_boundary_id(elem, side, BOUNDARY_ID_MAX_X))
              {
                side_max_x = side;
                found_side_max_x = true;
              }
  
            <B><FONT COLOR="#A020F0">if</FONT></B> (mesh.get_boundary_info().has_boundary_id(elem, side, BOUNDARY_ID_MIN_Y))
              {
                side_min_y = side;
                found_side_min_y = true;
              }
  
            <B><FONT COLOR="#A020F0">if</FONT></B> (mesh.get_boundary_info().has_boundary_id(elem, side, BOUNDARY_ID_MAX_Y))
              {
                side_max_y = side;
                found_side_max_y = true;
              }
  
            <B><FONT COLOR="#A020F0">if</FONT></B> (mesh.get_boundary_info().has_boundary_id(elem, side, BOUNDARY_ID_MAX_Z))
              {
                side_max_z = side;
                found_side_max_z = true;
              }
          }
  
        <B><FONT COLOR="#A020F0">if</FONT></B> (found_side_max_x &amp;&amp; found_side_max_y &amp;&amp; found_side_max_z)
          <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n=0; n&lt;elem-&gt;n_nodes(); n++)
            <B><FONT COLOR="#A020F0">if</FONT></B> (elem-&gt;is_node_on_side(n, side_max_x) &amp;&amp;
                elem-&gt;is_node_on_side(n, side_max_y) &amp;&amp;
                elem-&gt;is_node_on_side(n, side_max_z))
              mesh.get_boundary_info().add_node(elem-&gt;get_node(n), NODE_BOUNDARY_ID);
  
  
        <B><FONT COLOR="#A020F0">if</FONT></B> (found_side_max_x &amp;&amp; found_side_min_y)
          <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> e=0; e&lt;elem-&gt;n_edges(); e++)
            <B><FONT COLOR="#A020F0">if</FONT></B> (elem-&gt;is_edge_on_side(e, side_max_x) &amp;&amp;
                elem-&gt;is_edge_on_side(e, side_min_y))
              mesh.get_boundary_info().add_edge(elem, e, EDGE_BOUNDARY_ID);
      }
  
    EquationSystems equation_systems (mesh);
  
    LinearImplicitSystem &amp; system =
      equation_systems.add_system&lt;LinearImplicitSystem&gt; (<B><FONT COLOR="#BC8F8F">&quot;Elasticity&quot;</FONT></B>);
  
  #ifdef LIBMESH_HAVE_PETSC
    PetscLinearSolver&lt;Number&gt; * petsc_linear_solver =
      libmesh_cast_ptr&lt;PetscLinearSolver&lt;Number&gt;*&gt;(system.get_linear_solver());
    libmesh_assert(petsc_linear_solver);
    PetscSolverConfiguration petsc_solver_config(*petsc_linear_solver);
    petsc_linear_solver-&gt;set_solver_configuration(petsc_solver_config);
  #endif

    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> u_var = system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;u&quot;</FONT></B>, FIRST, LAGRANGE);
    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> v_var = system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;v&quot;</FONT></B>, FIRST, LAGRANGE);
    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> w_var = system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;w&quot;</FONT></B>, FIRST, LAGRANGE);
  
    LinearElasticity le(equation_systems);
    system.attach_assemble_object(le);
  
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::set&lt;boundary_id_type&gt; boundary_ids;
    boundary_ids.insert(BOUNDARY_ID_MIN_X);
    boundary_ids.insert(NODE_BOUNDARY_ID);
    boundary_ids.insert(EDGE_BOUNDARY_ID);
  
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; variables;
    variables.push_back(u_var);
    variables.push_back(v_var);
    variables.push_back(w_var);
  
    ZeroFunction&lt;&gt; zf;
  
    DirichletBoundary dirichlet_bc(boundary_ids,
                                   variables,
                                   &amp;zf);
  
    system.get_dof_map().add_dirichlet_boundary(dirichlet_bc);
  
    ExplicitSystem &amp; stress_system =
      equation_systems.add_system&lt;ExplicitSystem&gt; (<B><FONT COLOR="#BC8F8F">&quot;StressSystem&quot;</FONT></B>);
  
    stress_system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;sigma_00&quot;</FONT></B>, CONSTANT, MONOMIAL);
    stress_system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;sigma_01&quot;</FONT></B>, CONSTANT, MONOMIAL);
    stress_system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;sigma_02&quot;</FONT></B>, CONSTANT, MONOMIAL);
    stress_system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;sigma_11&quot;</FONT></B>, CONSTANT, MONOMIAL);
    stress_system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;sigma_12&quot;</FONT></B>, CONSTANT, MONOMIAL);
    stress_system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;sigma_22&quot;</FONT></B>, CONSTANT, MONOMIAL);
    stress_system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;vonMises&quot;</FONT></B>, CONSTANT, MONOMIAL);
  
    equation_systems.init();
  
    equation_systems.print_info();
  
    system.solve();
  
    le.compute_stresses();
  
  #ifdef LIBMESH_HAVE_EXODUS_API
  
    ExodusII_IO exo_io(mesh, <I><FONT COLOR="#B22222">/*single_precision=*/</FONT></I>true);
  
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::set&lt;std::string&gt; system_names;
    system_names.insert(<B><FONT COLOR="#BC8F8F">&quot;Elasticity&quot;</FONT></B>);
    exo_io.write_equation_systems(<B><FONT COLOR="#BC8F8F">&quot;displacement_and_stress.exo&quot;</FONT></B>, equation_systems, &amp;system_names);
  
    exo_io.write_element_data(equation_systems);
  
  #endif <I><FONT COLOR="#B22222">// #ifdef LIBMESH_HAVE_EXODUS_API
</FONT></I>  
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  }
</pre> 
<a name="output"></a> 
<br><br><br> <h1> The console output of the program: </h1> 
<pre>
***************************************************************
* Running Example systems_of_equations_ex6:
*   example-opt
***************************************************************
 
 Mesh Information:
  elem_dimensions()={3}
  spatial_dimension()=3
  n_nodes()=2706
    n_local_nodes()=2706
  n_elem()=2000
    n_local_elem()=2000
    n_active_elem()=2000
  n_subdomains()=1
  n_partitions()=1
  n_processors()=1
  n_threads()=1
  processor_id()=0

 EquationSystems
  n_systems()=2
   System #0, "Elasticity"
    Type "LinearImplicit"
    Variables={ "u" "v" "w" } 
    Finite Element Types="LAGRANGE", "JACOBI_20_00" 
    Infinite Element Mapping="CARTESIAN" 
    Approximation Orders="FIRST", "THIRD" 
    n_dofs()=8118
    n_local_dofs()=8118
    n_constrained_dofs()=219
    n_local_constrained_dofs()=219
    n_vectors()=1
    n_matrices()=1
    DofMap Sparsity
      Average  On-Processor Bandwidth <= 66.5366
      Average Off-Processor Bandwidth <= 0
      Maximum  On-Processor Bandwidth <= 81
      Maximum Off-Processor Bandwidth <= 0
    DofMap Constraints
      Number of DoF Constraints = 219
      Average DoF Constraint Length= 0
   System #1, "StressSystem"
    Type "Explicit"
    Variables={ "sigma_00" "sigma_01" "sigma_02" "sigma_11" "sigma_12" "sigma_22" "vonMises" }
    Finite Element Types="MONOMIAL", "JACOBI_20_00" 
    Infinite Element Mapping="CARTESIAN" 
    Approximation Orders="CONSTANT", "THIRD" 
    n_dofs()=14000
    n_local_dofs()=14000
    n_constrained_dofs()=0
    n_local_constrained_dofs()=0
    n_vectors()=1
    n_matrices()=0
    DofMap Sparsity
      Average  On-Processor Bandwidth <= 0
      Average Off-Processor Bandwidth <= 0
      Maximum  On-Processor Bandwidth <= 0
      Maximum Off-Processor Bandwidth <= 0
    DofMap Constraints
      Number of DoF Constraints = 0


 -------------------------------------------------------------------------------------------------------------------
| Time:           Tue Apr 12 15:00:17 2016                                                                          |
| OS:             Darwin                                                                                            |
| HostName:       peterson-laptop.local                                                                             |
| OS Release:     15.0.0                                                                                            |
| OS Version:     Darwin Kernel Version 15.0.0: Sat Sep 19 15:53:46 PDT 2015; root:xnu-3247.10.11~1/RELEASE_X86_64  |
| Machine:        x86_64                                                                                            |
| Username:       petejw                                                                                            |
| Configuration:  ../configure  'INSTALL=/usr/bin/install -C'                                                       |
|  '--with-methods=opt dbg'                                                                                         |
|  '--prefix=/Users/petejw/projects/libmesh_git/installed'                                                          |
|  '--enable-perflog'                                                                                               |
|  '--enable-tracefiles'                                                                                            |
|  '--disable-blocked-storage'                                                                                      |
|  '--enable-default-comm-world'                                                                                    |
|  '--enable-tecio'                                                                                                 |
|  '--enable-unique-ptr'                                                                                            |
|  '--enable-ifem'                                                                                                  |
|  'PETSC_DIR=/opt/moose/petsc/mpich_petsc-3.6.1/clang-opt-superlu'                                                 |
|  'SLEPC_DIR=/opt/petejw/slepc/3.6.1'                                                                              |
|  'CPPFLAGS= '                                                                                                     |
|  'LIBS= '                                                                                                         |
|  'CPPFLAGS=  '                                                                                                    |
|  'LIBS=  '                                                                                                        |
|  '--disable-netcdf-4'                                                                                             |
|  '--disable-testsets'                                                                                             |
|  'CXX=mpicxx'                                                                                                     |
|  'CC=mpicc'                                                                                                       |
|  'F77=mpif77'                                                                                                     |
|  'FC=mpif90'                                                                                                      |
|  'CPPFLAGS=   '                                                                                                   |
|  'LIBS=   '                                                                                                       |
 -------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------
| libMesh Performance: Alive time=0.481617, Active time=0.439705                                                  |
 -----------------------------------------------------------------------------------------------------------------
| Event                              nCalls     Total Time  Avg Time    Total Time  Avg Time    % of Active Time  |
|                                               w/o Sub     w/o Sub     With Sub    With Sub    w/o S    With S   |
|-----------------------------------------------------------------------------------------------------------------|
|                                                                                                                 |
|                                                                                                                 |
| DofMap                                                                                                          |
|   add_neighbors_to_send_list()     2          0.0016      0.000808    0.0016      0.000808    0.37     0.37     |
|   build_constraint_matrix()        2000       0.0009      0.000000    0.0009      0.000000    0.20     0.20     |
|   build_sparsity()                 1          0.0195      0.019467    0.0207      0.020717    4.43     4.71     |
|   cnstrn_elem_mat_vec()            2000       0.0007      0.000000    0.0007      0.000000    0.17     0.17     |
|   create_dof_constraints()         2          0.0102      0.005103    0.0124      0.006197    2.32     2.82     |
|   distribute_dofs()                2          0.0017      0.000867    0.0056      0.002812    0.39     1.28     |
|   dof_indices()                    56000      0.0107      0.000000    0.0107      0.000000    2.44     2.44     |
|   prepare_send_list()              4          0.0000      0.000000    0.0000      0.000000    0.00     0.00     |
|   reinit()                         2          0.0039      0.001944    0.0039      0.001944    0.88     0.88     |
|                                                                                                                 |
| EquationSystems                                                                                                 |
|   build_solution_vector()          1          0.0039      0.003901    0.0056      0.005594    0.89     1.27     |
|                                                                                                                 |
| ExodusII_IO                                                                                                     |
|   write_nodal_data()               1          0.0039      0.003912    0.0039      0.003912    0.89     0.89     |
|                                                                                                                 |
| FE                                                                                                              |
|   compute_shape_functions()        5315       0.0062      0.000001    0.0062      0.000001    1.41     1.41     |
|   init_shape_functions()           1317       0.0002      0.000000    0.0002      0.000000    0.05     0.05     |
|   inverse_map()                    30         0.0001      0.000002    0.0001      0.000002    0.01     0.01     |
|                                                                                                                 |
| FEMap                                                                                                           |
|   compute_affine_map()             5315       0.0043      0.000001    0.0043      0.000001    0.97     0.97     |
|   compute_edge_map()               15         0.0000      0.000001    0.0000      0.000001    0.00     0.00     |
|   compute_face_map()               1300       0.0006      0.000000    0.0006      0.000000    0.13     0.13     |
|   init_edge_shape_functions()      15         0.0000      0.000003    0.0000      0.000003    0.01     0.01     |
|   init_face_shape_functions()      1          0.0000      0.000010    0.0000      0.000010    0.00     0.00     |
|   init_reference_to_physical_map() 1317       0.0052      0.000004    0.0052      0.000004    1.18     1.18     |
|                                                                                                                 |
| Mesh                                                                                                            |
|   find_neighbors()                 1          0.0052      0.005161    0.0052      0.005161    1.17     1.17     |
|   renumber_nodes_and_elem()        2          0.0002      0.000076    0.0002      0.000076    0.03     0.03     |
|                                                                                                                 |
| MeshOutput                                                                                                      |
|   write_equation_systems()         1          0.0000      0.000023    0.0095      0.009529    0.01     2.17     |
|                                                                                                                 |
| MeshTools::Generation                                                                                           |
|   build_cube()                     1          0.0008      0.000828    0.0008      0.000828    0.19     0.19     |
|                                                                                                                 |
| Parallel                                                                                                        |
|   allgather()                      2          0.0000      0.000000    0.0000      0.000000    0.00     0.00     |
|                                                                                                                 |
| Partitioner                                                                                                     |
|   single_partition()               1          0.0002      0.000170    0.0002      0.000170    0.04     0.04     |
|                                                                                                                 |
| PetscLinearSolver                                                                                               |
|   solve()                          1          0.1208      0.120836    0.1208      0.120836    27.48    27.48    |
|                                                                                                                 |
| System                                                                                                          |
|   assemble()                       1          0.2389      0.238867    0.2582      0.258170    54.32    58.71    |
 -----------------------------------------------------------------------------------------------------------------
| Totals:                            74650      0.4397                                          100.00            |
 -----------------------------------------------------------------------------------------------------------------

 
***************************************************************
* Done Running Example systems_of_equations_ex6:
*   example-opt
***************************************************************
</pre>
</div>

<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){
  $(window).on('scroll',function() {
    var scrolltop = $(this).scrollTop();

    if(scrolltop >= 215) {
      $('#fixedbar').fadeIn(250);
    }

    else if(scrolltop <= 210) {
      $('#fixedbar').fadeOut(250);
    }
  });
});
</script>

<!-- Google Analytics stuff -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-24978333-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</body>
</html>
