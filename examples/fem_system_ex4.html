<!doctype html>
<html lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
  <title>libMesh - A C++ Finite Element Library</title>
  <meta name="author" content="libMesh development team">
  <link rel="stylesheet" type="text/css" media="all" href="../styles.css">
  <link rel="stylesheet" type="text/css" media="all" href="../doxygen_stylesheet.css">
</head>

<body>
  <nav id="fixedbar">
    <ul id="fixednav">
      <li><a href="../index.html">Home</a></li>
      <li><a href="../support.html">About Us</a></li>
      <li><a href="../publications.html">Publications</a></li>
      <li><a href="https://github.com/libMesh/libmesh/graphs/contributors">Developers</a></li>
      <li><a href="../installation.html">Installation</a></li>
      <li><a href="../examples.html">Examples</a></li>
     <li><a href="../doxygen/index.html">Documentation</a></li>
    </ul>
  </nav>

  <div id="w">
    <header id="logo"><a href="../index.html"><span id="logobg">SomeWebsiteLogo</span></a></header>

    <nav id="navigation">
      <ul>
        <li><a href="../index.html">Home</a></li>
        <li><a href="../support.html">About Us</a></li>
        <li><a href="../publications.html">Publications</a></li>
        <li><a href="https://github.com/libMesh/libmesh/graphs/contributors">Developers</a></li>
        <li><a href="../installation.html">Installation</a></li>
        <li><a href="../examples.html">Examples</a></li>
        <li><a href="../doxygen/index.html">Documentation</a></li>
      </ul>
    </nav>

<div id="content">

<a name="comments"></a>
<br><br><br> <h1> The source file heatsystem.h with comments: </h1>
<div class = "comment">
</div>

<div class ="fragment">
<pre>
        #include "libmesh/enum_fe_family.h"
        #include "libmesh/fem_system.h"

</pre>
</div>
<div class = "comment">
FEMSystem, TimeSolver and  NewtonSolver will handle most tasks,
but we must specify element residuals
</div>

<div class ="fragment">
<pre>
        class HeatSystem : public libMesh::FEMSystem
        {
        public:
</pre>
</div>
<div class = "comment">
Constructor
</div>

<div class ="fragment">
<pre>
          HeatSystem(libMesh::EquationSystems & es,
                     const std::string & name,
                     const unsigned int number) :
            libMesh::FEMSystem(es, name, number),
            _fe_family("LAGRANGE"), _fe_order(1)
          {
</pre>
</div>
<div class = "comment">
Get the conductivity ratios right for both 2D and 3D
benchmarks
</div>

<div class ="fragment">
<pre>
            _k[1] = 1/libMesh::pi/std::sqrt(libMesh::Real(3));
            _k[2] = 1;
            _k[3] = 2*libMesh::pi*std::sqrt(libMesh::Real(3));
          }

          std::string & fe_family() { return _fe_family; }
          unsigned int & fe_order() { return _fe_order; }

        protected:
</pre>
</div>
<div class = "comment">
System initialization
</div>

<div class ="fragment">
<pre>
          virtual void init_data ();

</pre>
</div>
<div class = "comment">
Context initialization
</div>

<div class ="fragment">
<pre>
          virtual void init_context (libMesh::DiffContext & context);

</pre>
</div>
<div class = "comment">
Element residual and jacobian calculations
Time dependent parts
</div>

<div class ="fragment">
<pre>
          virtual bool element_time_derivative (bool request_jacobian,
                                                libMesh::DiffContext & context);

</pre>
</div>
<div class = "comment">
The conductivity for the various dimensional elements, indexed by
dim (with _k[0] unused) for simplicity
</div>

<div class ="fragment">
<pre>
          libMesh::Real _k[4];

</pre>
</div>
<div class = "comment">
The FE type to use
</div>

<div class ="fragment">
<pre>
          std::string _fe_family;
          unsigned int _fe_order;

</pre>
</div>
<div class = "comment">
The variable index (yes, this will be 0...)
</div>

<div class ="fragment">
<pre>
          unsigned int T_var;
        };
</pre>
</div>

<a name="comments"></a>
<br><br><br> <h1> The source file fem_system_ex4.C with comments: </h1>
<div class = "comment">
</div>

<div class ="fragment">
<pre>
        #include &lt;iomanip&gt;

</pre>
</div>
<div class = "comment">
Basic include files
</div>

<div class ="fragment">
<pre>
        #include "libmesh/elem.h"
        #include "libmesh/equation_systems.h"
        #include "libmesh/error_vector.h"
        #include "libmesh/exact_solution.h"
        #include "libmesh/getpot.h"
        #include "libmesh/gmv_io.h"
        #include "libmesh/exodusII_io.h"
        #include "libmesh/kelly_error_estimator.h"
        #include "libmesh/mesh.h"
        #include "libmesh/mesh_generation.h"
        #include "libmesh/mesh_refinement.h"
        #include "libmesh/parsed_function.h"
        #include "libmesh/uniform_refinement_estimator.h"

</pre>
</div>
<div class = "comment">
The systems and solvers we may use
</div>

<div class ="fragment">
<pre>
        #include "heatsystem.h"
        #include "libmesh/diff_solver.h"
        #include "libmesh/euler_solver.h"
        #include "libmesh/steady_solver.h"

</pre>
</div>
<div class = "comment">
Bring in everything from the libMesh namespace
</div>

<div class ="fragment">
<pre>
        using namespace libMesh;

</pre>
</div>
<div class = "comment">
The main program.
</div>

<div class ="fragment">
<pre>
        int main (int argc, char ** argv)
        {
</pre>
</div>
<div class = "comment">
Initialize libMesh.
</div>

<div class ="fragment">
<pre>
          LibMeshInit init (argc, argv);

        #ifndef LIBMESH_ENABLE_AMR
          libmesh_example_requires(false, "--enable-amr");
        #else

</pre>
</div>
<div class = "comment">
This doesn't converge with Eigen BICGSTAB for some reason...
</div>

<div class ="fragment">
<pre>
          libmesh_example_requires(libMesh::default_solver_package() != EIGEN_SOLVERS, "--enable-petsc");

</pre>
</div>
<div class = "comment">
Parse the input file
</div>

<div class ="fragment">
<pre>
          GetPot infile("fem_system_ex4.in");

</pre>
</div>
<div class = "comment">
Read in parameters from the input file
</div>

<div class ="fragment">
<pre>
          const Real global_tolerance          = infile("global_tolerance", 0.);
          const unsigned int nelem_target      = infile("n_elements", 400);
          const Real deltat                    = infile("deltat", 0.005);
          const unsigned int coarsegridsize    = infile("coarsegridsize", 20);
          const unsigned int coarserefinements = infile("coarserefinements", 0);
          const unsigned int max_adaptivesteps = infile("max_adaptivesteps", 10);
          const unsigned int dim               = infile("dimension", 2);

</pre>
</div>
<div class = "comment">
Skip higher-dimensional examples on a lower-dimensional libMesh build
</div>

<div class ="fragment">
<pre>
          libmesh_example_requires(dim &lt;= LIBMESH_DIM, "2D/3D support");

</pre>
</div>
<div class = "comment">
We have only defined 2 and 3 dimensional problems
</div>

<div class ="fragment">
<pre>
          libmesh_assert (dim == 2 || dim == 3);

</pre>
</div>
<div class = "comment">
Create a mesh, with dimension to be overridden later, distributed
across the default MPI communicator.
</div>

<div class ="fragment">
<pre>
          Mesh mesh(init.comm());

</pre>
</div>
<div class = "comment">
And an object to refine it
</div>

<div class ="fragment">
<pre>
          MeshRefinement mesh_refinement(mesh);
          mesh_refinement.coarsen_by_parents() = true;
          mesh_refinement.absolute_global_tolerance() = global_tolerance;
          mesh_refinement.nelem_target() = nelem_target;
          mesh_refinement.refine_fraction() = 0.3;
          mesh_refinement.coarsen_fraction() = 0.3;
          mesh_refinement.coarsen_threshold() = 0.1;

</pre>
</div>
<div class = "comment">
Use the MeshTools::Generation mesh generator to create a uniform
grid on the square or cube.  We crop the domain at y=2/3 to allow
for a homogeneous Neumann BC in our benchmark there.
</div>

<div class ="fragment">
<pre>
          boundary_id_type bcid = 3; // +y in 3D
          if (dim == 2)
            {
              MeshTools::Generation::build_square
                (mesh,
                 coarsegridsize,
                 coarsegridsize*2/3, // int arithmetic best we can do here
                 0., 1.,
                 0., 2./3.,
                 QUAD9);
              bcid = 2; // +y in 2D
            }
          else if (dim == 3)
            {
              MeshTools::Generation::build_cube
                (mesh,
                 coarsegridsize,
                 coarsegridsize*2/3,
                 coarsegridsize,
                 0., 1.,
                 0., 2./3.,
                 0., 1.,
                 HEX27);
            }

          {
</pre>
</div>
<div class = "comment">
Add boundary elements corresponding to the +y boundary of our
volume mesh
</div>

<div class ="fragment">
<pre>
            std::set&lt;boundary_id_type&gt; bcids;
            bcids.insert(bcid);
            mesh.get_boundary_info().add_elements(bcids, mesh);
            mesh.prepare_for_use();
          }

</pre>
</div>
<div class = "comment">
To work around ExodusII file format limitations, we need elements
of different dimensionality to belong to different subdomains.
Our interior elements defaulted to subdomain id 0, so we'll set
boundary elements to subdomain 1.
</div>

<div class ="fragment">
<pre>
          {
            const MeshBase::element_iterator end_el = mesh.elements_end();
            for (MeshBase::element_iterator el = mesh.elements_begin();
                 el != end_el; ++el)
              {
                Elem * elem = *el;
                if (elem-&gt;dim() &lt; dim)
                  elem-&gt;subdomain_id() = 1;
              }
          }

          mesh_refinement.uniformly_refine(coarserefinements);

</pre>
</div>
<div class = "comment">
Print information about the mesh to the screen.
</div>

<div class ="fragment">
<pre>
          mesh.print_info();

</pre>
</div>
<div class = "comment">
Create an equation systems object.
</div>

<div class ="fragment">
<pre>
          EquationSystems equation_systems (mesh);

</pre>
</div>
<div class = "comment">
Declare the system "Heat" and its variables.
</div>

<div class ="fragment">
<pre>
          HeatSystem & system =
            equation_systems.add_system&lt;HeatSystem&gt; ("Heat");

</pre>
</div>
<div class = "comment">
Solve this as a steady system
</div>

<div class ="fragment">
<pre>
          system.time_solver =
            UniquePtr&lt;TimeSolver&gt;(new SteadySolver(system));

</pre>
</div>
<div class = "comment">
Initialize the system
</div>

<div class ="fragment">
<pre>
          equation_systems.init ();

</pre>
</div>
<div class = "comment">
Set the time stepping options
</div>

<div class ="fragment">
<pre>
          system.deltat = deltat;

</pre>
</div>
<div class = "comment">
And the nonlinear solver options
</div>

<div class ="fragment">
<pre>
          DiffSolver & solver = *(system.time_solver-&gt;diff_solver().get());
          solver.quiet = infile("solver_quiet", true);
          solver.verbose = !solver.quiet;
          solver.max_nonlinear_iterations = infile("max_nonlinear_iterations", 15);
          solver.relative_step_tolerance = infile("relative_step_tolerance", 1.e-3);
          solver.relative_residual_tolerance = infile("relative_residual_tolerance", 0.0);
          solver.absolute_residual_tolerance = infile("absolute_residual_tolerance", 0.0);

</pre>
</div>
<div class = "comment">
And the linear solver options
</div>

<div class ="fragment">
<pre>
          solver.max_linear_iterations = infile("max_linear_iterations", 50000);
          solver.initial_linear_tolerance = infile("initial_linear_tolerance", 1.e-3);

</pre>
</div>
<div class = "comment">
Print information about the system to the screen.
</div>

<div class ="fragment">
<pre>
          equation_systems.print_info();

</pre>
</div>
<div class = "comment">
Adaptively solve the steady solution
</div>

<div class ="fragment">
<pre>
          unsigned int a_step = 0;
          for (; a_step != max_adaptivesteps; ++a_step)
            {
              system.solve();

              system.postprocess();

              ErrorVector error;

              UniquePtr&lt;ErrorEstimator&gt; error_estimator;

</pre>
</div>
<div class = "comment">
To solve to a tolerance in this problem we
need a better estimator than Kelly
</div>

<div class ="fragment">
<pre>
              if (global_tolerance != 0.)
                {
</pre>
</div>
<div class = "comment">
We can't adapt to both a tolerance and a mesh
size at once
</div>

<div class ="fragment">
<pre>
                  libmesh_assert_equal_to (nelem_target, 0);

                  UniformRefinementEstimator * u =
                    new UniformRefinementEstimator;

</pre>
</div>
<div class = "comment">
The lid-driven cavity problem isn't in H1, so
lets estimate L2 error
</div>

<div class ="fragment">
<pre>
                  u-&gt;error_norm = L2;

                  error_estimator.reset(u);
                }
              else
                {
</pre>
</div>
<div class = "comment">
If we aren't adapting to a tolerance we need a
target mesh size
</div>

<div class ="fragment">
<pre>
                  libmesh_assert_greater (nelem_target, 0);

</pre>
</div>
<div class = "comment">
Kelly is a lousy estimator to use for a problem
not in H1 - if we were doing more than a few
timesteps we'd need to turn off or limit the
maximum level of our adaptivity eventually
</div>

<div class ="fragment">
<pre>
                  error_estimator.reset(new KellyErrorEstimator);
                }

              error_estimator-&gt;estimate_error(system, error);

</pre>
</div>
<div class = "comment">
Print out status at each adaptive step.
</div>

<div class ="fragment">
<pre>
              Real global_error = error.l2_norm();
              libMesh::out &lt;&lt; "Adaptive step "
                           &lt;&lt; a_step
                           &lt;&lt; ": "
                           &lt;&lt; std::endl;

              if (global_tolerance != 0.)
                libMesh::out &lt;&lt; "Global_error = "
                             &lt;&lt; global_error
                             &lt;&lt; std::endl;

              if (global_tolerance != 0.)
                libMesh::out &lt;&lt; "Worst element error = "
                             &lt;&lt; error.maximum()
                             &lt;&lt; ", mean = "
                             &lt;&lt; error.mean()
                             &lt;&lt; std::endl;

              if (global_tolerance != 0.)
                {
</pre>
</div>
<div class = "comment">
If we've reached our desired tolerance, we
don't need any more adaptive steps
</div>

<div class ="fragment">
<pre>
                  if (global_error &lt; global_tolerance)
                    break;
                  mesh_refinement.flag_elements_by_error_tolerance(error);
                }
              else
                {
</pre>
</div>
<div class = "comment">
If flag_elements_by_nelem_target returns true, this
should be our last adaptive step.
</div>

<div class ="fragment">
<pre>
                  if (mesh_refinement.flag_elements_by_nelem_target(error))
                    {
                      mesh_refinement.refine_and_coarsen_elements();
                      equation_systems.reinit();
                      a_step = max_adaptivesteps;
                      break;
                    }
                }

</pre>
</div>
<div class = "comment">
Carry out the adaptive mesh refinement/coarsening
</div>

<div class ="fragment">
<pre>
              mesh_refinement.refine_and_coarsen_elements();
              equation_systems.reinit();

              libMesh::out &lt;&lt; "Refined mesh to "
                           &lt;&lt; mesh.n_active_elem()
                           &lt;&lt; " active elements and "
                           &lt;&lt; equation_systems.n_active_dofs()
                           &lt;&lt; " active dofs."
                           &lt;&lt; std::endl;
            }
</pre>
</div>
<div class = "comment">
Do one last solve if necessary
</div>

<div class ="fragment">
<pre>
          if (a_step == max_adaptivesteps)
            {
              system.solve();

              system.postprocess();
            }


        #ifdef LIBMESH_HAVE_EXODUS_API
          ExodusII_IO(mesh).write_equation_systems
            ("out.e", equation_systems);
        #endif // #ifdef LIBMESH_HAVE_EXODUS_API

        #ifdef LIBMESH_HAVE_GMV
          GMVIO(mesh).write_equation_systems
            ("out.gmv", equation_systems);
        #endif // #ifdef LIBMESH_HAVE_GMV

        #ifdef LIBMESH_HAVE_FPARSER
</pre>
</div>
<div class = "comment">
Check that we got close to the analytic solution
</div>

<div class ="fragment">
<pre>
          ExactSolution exact_sol(equation_systems);
          const std::string exact_str = (dim == 2) ?
            "sin(pi*x)*sin(pi*y)" : "sin(pi*x)*sin(pi*y)*sin(pi*z)";
          ParsedFunction&lt;Number&gt; exact_func(exact_str);
          exact_sol.attach_exact_value(0, &exact_func);
          exact_sol.compute_error("Heat", "T");

          Number err = exact_sol.l2_error("Heat", "T");

</pre>
</div>
<div class = "comment">
Print out the error value
</div>

<div class ="fragment">
<pre>
          libMesh::out &lt;&lt; "L2-Error is: " &lt;&lt; err &lt;&lt; std::endl;

          libmesh_assert_less(libmesh_real(err), 2e-3);

        #endif // #ifdef LIBMESH_HAVE_FPARSER

        #endif // #ifndef LIBMESH_ENABLE_AMR

</pre>
</div>
<div class = "comment">
All done.
</div>

<div class ="fragment">
<pre>
          return 0;
        }
</pre>
</div>

<a name="comments"></a>
<br><br><br> <h1> The source file heatsystem.C with comments: </h1>
<div class = "comment">
</div>

<div class ="fragment">
<pre>
        #include "heatsystem.h"

        #include "libmesh/dirichlet_boundaries.h"
        #include "libmesh/dof_map.h"
        #include "libmesh/fe_base.h"
        #include "libmesh/fe_interface.h"
        #include "libmesh/fem_context.h"
        #include "libmesh/getpot.h"
        #include "libmesh/mesh.h"
        #include "libmesh/quadrature.h"
        #include "libmesh/string_to_enum.h"
        #include "libmesh/zero_function.h"
        #include "libmesh/elem.h"

        using namespace libMesh;

        void HeatSystem::init_data ()
        {
          T_var = this-&gt;add_variable("T", static_cast&lt;Order&gt;(_fe_order),
                                     Utility::string_to_enum&lt;FEFamily&gt;(_fe_family));

          const unsigned int dim = this-&gt;get_mesh().mesh_dimension();

</pre>
</div>
<div class = "comment">
Add dirichlet boundaries on all but the boundary element side
</div>

<div class ="fragment">
<pre>
          const boundary_id_type all_ids[6] = {0, 1, 2, 3, 4, 5};
          std::set&lt;boundary_id_type&gt; nonyplus_bdys(all_ids, all_ids+(dim*2));
          const boundary_id_type yplus_id = (dim == 3) ? 3 : 2;
          nonyplus_bdys.erase(yplus_id);

          std::vector&lt;unsigned int&gt; T_only(1, T_var);
          ZeroFunction&lt;Number&gt; zero;

          this-&gt;get_dof_map().add_dirichlet_boundary
            (DirichletBoundary (nonyplus_bdys, T_only, &zero));

</pre>
</div>
<div class = "comment">
Do the parent's initialization after variables are defined
</div>

<div class ="fragment">
<pre>
          FEMSystem::init_data();

          this-&gt;time_evolving(0);
        }



        void HeatSystem::init_context(DiffContext & context)
        {
          FEMContext & c = libmesh_cast_ref&lt;FEMContext &&gt;(context);

          const std::set&lt;unsigned char&gt; & elem_dims =
            c.elem_dimensions();

          for (std::set&lt;unsigned char&gt;::const_iterator dim_it =
                 elem_dims.begin(); dim_it != elem_dims.end(); ++dim_it)
            {
              const unsigned char dim = *dim_it;

              FEBase * fe = libmesh_nullptr;

              c.get_element_fe(T_var, fe, dim);

              fe-&gt;get_JxW();  // For integration
              fe-&gt;get_dphi(); // For bilinear form
              fe-&gt;get_xyz();  // For forcing
              fe-&gt;get_phi();  // For forcing
            }

          FEMSystem::init_context(context);
        }


        bool HeatSystem::element_time_derivative (bool request_jacobian,
                                                  DiffContext & context)
        {
          FEMContext & c = libmesh_cast_ref&lt;FEMContext &&gt;(context);

          const unsigned int mesh_dim =
            c.get_system().get_mesh().mesh_dimension();

</pre>
</div>
<div class = "comment">
First we get some references to cell-specific data that
will be used to assemble the linear system.
</div>

<div class ="fragment">
<pre>
          const unsigned int dim = c.get_elem().dim();
          FEBase * fe = libmesh_nullptr;
          c.get_element_fe(T_var, fe, dim);

</pre>
</div>
<div class = "comment">
Element Jacobian * quadrature weights for interior integration
</div>

<div class ="fragment">
<pre>
          const std::vector&lt;Real&gt; & JxW = fe-&gt;get_JxW();

          const std::vector&lt;Point&gt; & xyz = fe-&gt;get_xyz();

          const std::vector&lt;std::vector&lt;Real&gt; &gt; & phi = fe-&gt;get_phi();

          const std::vector&lt;std::vector&lt;RealGradient&gt; &gt; & dphi = fe-&gt;get_dphi();

</pre>
</div>
<div class = "comment">
The number of local degrees of freedom in each variable
</div>

<div class ="fragment">
<pre>
          const unsigned int n_T_dofs = c.get_dof_indices(T_var).size();

</pre>
</div>
<div class = "comment">
The subvectors and submatrices we need to fill:
</div>

<div class ="fragment">
<pre>
          DenseSubMatrix&lt;Number&gt; & K = c.get_elem_jacobian(T_var, T_var);
          DenseSubVector&lt;Number&gt; & F = c.get_elem_residual(T_var);

</pre>
</div>
<div class = "comment">
Now we will build the element Jacobian and residual.
Constructing the residual requires the solution and its
gradient from the previous timestep.  This must be
calculated at each quadrature point by summing the
solution degree-of-freedom values by the appropriate
weight functions.
</div>

<div class ="fragment">
<pre>
          unsigned int n_qpoints = c.get_element_qrule().n_points();

          for (unsigned int qp=0; qp != n_qpoints; qp++)
            {
</pre>
</div>
<div class = "comment">
Compute the solution gradient at the Newton iterate
</div>

<div class ="fragment">
<pre>
              Gradient grad_T = c.interior_gradient(T_var, qp);

              const Number k = _k[dim];

              const Point & p = xyz[qp];

</pre>
</div>
<div class = "comment">
solution + laplacian depend on problem dimension
</div>

<div class ="fragment">
<pre>
              const Number u_exact = (mesh_dim == 2) ?
                std::sin(libMesh::pi*p(0)) * std::sin(libMesh::pi*p(1)) :
                std::sin(libMesh::pi*p(0)) * std::sin(libMesh::pi*p(1)) *
                std::sin(libMesh::pi*p(2));

</pre>
</div>
<div class = "comment">
Only apply forcing to interior elements
</div>

<div class ="fragment">
<pre>
              const Number forcing = (dim == mesh_dim) ?
                -k * u_exact * (dim * libMesh::pi * libMesh::pi) : 0;

              const Number JxWxNK = JxW[qp] * -k;

              for (unsigned int i=0; i != n_T_dofs; i++)
                F(i) += JxWxNK * (grad_T * dphi[i][qp] + forcing * phi[i][qp]);
              if (request_jacobian)
                {
                  const Number JxWxNKxD = JxWxNK *
                    context.get_elem_solution_derivative();

                  for (unsigned int i=0; i != n_T_dofs; i++)
                    for (unsigned int j=0; j != n_T_dofs; ++j)
                      K(i,j) += JxWxNKxD * (dphi[i][qp] * dphi[j][qp]);
                }
            } // end of the quadrature point qp-loop

          return request_jacobian;
        }
</pre>
</div>

<a name="nocomments"></a>
<br><br><br> <h1> The source file heatsystem.h without comments: </h1>
<pre>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/enum_fe_family.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/fem_system.h&quot;</FONT></B>

  <B><FONT COLOR="#228B22">class</FONT></B> HeatSystem : <B><FONT COLOR="#228B22">public</FONT></B> libMesh::FEMSystem
  {
  <B><FONT COLOR="#228B22">public</FONT></B>:
    HeatSystem(libMesh::EquationSystems &amp; es,
               <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp; name,
               <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> number) :
      <B><FONT COLOR="#5F9EA0">libMesh</FONT></B>::FEMSystem(es, name, number),
      _fe_family(<B><FONT COLOR="#BC8F8F">&quot;LAGRANGE&quot;</FONT></B>), _fe_order(1)
    {
      _k[1] = 1/libMesh::pi/std::sqrt(libMesh::Real(3));
      _k[2] = 1;
      _k[3] = 2*libMesh::pi*std::sqrt(libMesh::Real(3));
    }

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string &amp; fe_family() { <B><FONT COLOR="#A020F0">return</FONT></B> _fe_family; }
    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> &amp; fe_order() { <B><FONT COLOR="#A020F0">return</FONT></B> _fe_order; }

  <B><FONT COLOR="#228B22">protected</FONT></B>:
    <B><FONT COLOR="#228B22">virtual</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> init_data ();

    <B><FONT COLOR="#228B22">virtual</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> init_context (libMesh::DiffContext &amp; context);

    <B><FONT COLOR="#228B22">virtual</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> element_time_derivative (<B><FONT COLOR="#228B22">bool</FONT></B> request_jacobian,
                                          <B><FONT COLOR="#5F9EA0">libMesh</FONT></B>::DiffContext &amp; context);

    <B><FONT COLOR="#5F9EA0">libMesh</FONT></B>::Real _k[4];

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::string _fe_family;
    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> _fe_order;

    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> T_var;
  };
</pre>
<a name="nocomments"></a>
<br><br><br> <h1> The source file fem_system_ex4.C without comments: </h1>
<pre>
  #include &lt;iomanip&gt;

  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/elem.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/equation_systems.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/error_vector.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/exact_solution.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/getpot.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/gmv_io.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/exodusII_io.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/kelly_error_estimator.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/mesh.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/mesh_generation.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/mesh_refinement.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/parsed_function.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/uniform_refinement_estimator.h&quot;</FONT></B>

  #include <B><FONT COLOR="#BC8F8F">&quot;heatsystem.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/diff_solver.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/euler_solver.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/steady_solver.h&quot;</FONT></B>

  using namespace libMesh;

  <B><FONT COLOR="#228B22">int</FONT></B> main (<B><FONT COLOR="#228B22">int</FONT></B> argc, <B><FONT COLOR="#228B22">char</FONT></B> ** argv)
  {
    LibMeshInit init (argc, argv);

  #ifndef LIBMESH_ENABLE_AMR
    libmesh_example_requires(false, <B><FONT COLOR="#BC8F8F">&quot;--enable-amr&quot;</FONT></B>);
  #<B><FONT COLOR="#A020F0">else</FONT></B>

    libmesh_example_requires(libMesh::default_solver_package() != EIGEN_SOLVERS, <B><FONT COLOR="#BC8F8F">&quot;--enable-petsc&quot;</FONT></B>);

    GetPot infile(<B><FONT COLOR="#BC8F8F">&quot;fem_system_ex4.in&quot;</FONT></B>);

    <B><FONT COLOR="#228B22">const</FONT></B> Real global_tolerance          = infile(<B><FONT COLOR="#BC8F8F">&quot;global_tolerance&quot;</FONT></B>, 0.);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> nelem_target      = infile(<B><FONT COLOR="#BC8F8F">&quot;n_elements&quot;</FONT></B>, 400);
    <B><FONT COLOR="#228B22">const</FONT></B> Real deltat                    = infile(<B><FONT COLOR="#BC8F8F">&quot;deltat&quot;</FONT></B>, 0.005);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> coarsegridsize    = infile(<B><FONT COLOR="#BC8F8F">&quot;coarsegridsize&quot;</FONT></B>, 20);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> coarserefinements = infile(<B><FONT COLOR="#BC8F8F">&quot;coarserefinements&quot;</FONT></B>, 0);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> max_adaptivesteps = infile(<B><FONT COLOR="#BC8F8F">&quot;max_adaptivesteps&quot;</FONT></B>, 10);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dim               = infile(<B><FONT COLOR="#BC8F8F">&quot;dimension&quot;</FONT></B>, 2);

    libmesh_example_requires(dim &lt;= LIBMESH_DIM, <B><FONT COLOR="#BC8F8F">&quot;2D/3D support&quot;</FONT></B>);

    libmesh_assert (dim == 2 || dim == 3);

    Mesh mesh(init.comm());

    MeshRefinement mesh_refinement(mesh);
    mesh_refinement.coarsen_by_parents() = true;
    mesh_refinement.absolute_global_tolerance() = global_tolerance;
    mesh_refinement.nelem_target() = nelem_target;
    mesh_refinement.refine_fraction() = 0.3;
    mesh_refinement.coarsen_fraction() = 0.3;
    mesh_refinement.coarsen_threshold() = 0.1;

    boundary_id_type bcid = 3; <I><FONT COLOR="#B22222">// +y in 3D
</FONT></I>    <B><FONT COLOR="#A020F0">if</FONT></B> (dim == 2)
      {
        <B><FONT COLOR="#5F9EA0">MeshTools</FONT></B>::Generation::build_square
          (mesh,
           coarsegridsize,
           coarsegridsize*2/3, <I><FONT COLOR="#B22222">// int arithmetic best we can do here
</FONT></I>           0., 1.,
           0., 2./3.,
           QUAD9);
        bcid = 2; <I><FONT COLOR="#B22222">// +y in 2D
</FONT></I>      }
    <B><FONT COLOR="#A020F0">else</FONT></B> <B><FONT COLOR="#A020F0">if</FONT></B> (dim == 3)
      {
        <B><FONT COLOR="#5F9EA0">MeshTools</FONT></B>::Generation::build_cube
          (mesh,
           coarsegridsize,
           coarsegridsize*2/3,
           coarsegridsize,
           0., 1.,
           0., 2./3.,
           0., 1.,
           HEX27);
      }

    {
      <B><FONT COLOR="#5F9EA0">std</FONT></B>::set&lt;boundary_id_type&gt; bcids;
      bcids.insert(bcid);
      mesh.get_boundary_info().add_elements(bcids, mesh);
      mesh.prepare_for_use();
    }

    {
      <B><FONT COLOR="#228B22">const</FONT></B> MeshBase::element_iterator end_el = mesh.elements_end();
      <B><FONT COLOR="#A020F0">for</FONT></B> (MeshBase::element_iterator el = mesh.elements_begin();
           el != end_el; ++el)
        {
          Elem * elem = *el;
          <B><FONT COLOR="#A020F0">if</FONT></B> (elem-&gt;dim() &lt; dim)
            elem-&gt;subdomain_id() = 1;
        }
    }

    mesh_refinement.uniformly_refine(coarserefinements);

    mesh.print_info();

    EquationSystems equation_systems (mesh);

    HeatSystem &amp; system =
      equation_systems.add_system&lt;HeatSystem&gt; (<B><FONT COLOR="#BC8F8F">&quot;Heat&quot;</FONT></B>);

    system.time_solver =
      UniquePtr&lt;TimeSolver&gt;(<B><FONT COLOR="#A020F0">new</FONT></B> SteadySolver(system));

    equation_systems.init ();

    system.deltat = deltat;

    DiffSolver &amp; solver = *(system.time_solver-&gt;diff_solver().get());
    solver.quiet = infile(<B><FONT COLOR="#BC8F8F">&quot;solver_quiet&quot;</FONT></B>, true);
    solver.verbose = !solver.quiet;
    solver.max_nonlinear_iterations = infile(<B><FONT COLOR="#BC8F8F">&quot;max_nonlinear_iterations&quot;</FONT></B>, 15);
    solver.relative_step_tolerance = infile(<B><FONT COLOR="#BC8F8F">&quot;relative_step_tolerance&quot;</FONT></B>, 1.e-3);
    solver.relative_residual_tolerance = infile(<B><FONT COLOR="#BC8F8F">&quot;relative_residual_tolerance&quot;</FONT></B>, 0.0);
    solver.absolute_residual_tolerance = infile(<B><FONT COLOR="#BC8F8F">&quot;absolute_residual_tolerance&quot;</FONT></B>, 0.0);

    solver.max_linear_iterations = infile(<B><FONT COLOR="#BC8F8F">&quot;max_linear_iterations&quot;</FONT></B>, 50000);
    solver.initial_linear_tolerance = infile(<B><FONT COLOR="#BC8F8F">&quot;initial_linear_tolerance&quot;</FONT></B>, 1.e-3);

    equation_systems.print_info();

    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> a_step = 0;
    <B><FONT COLOR="#A020F0">for</FONT></B> (; a_step != max_adaptivesteps; ++a_step)
      {
        system.solve();

        system.postprocess();

        ErrorVector error;

        UniquePtr&lt;ErrorEstimator&gt; error_estimator;

        <B><FONT COLOR="#A020F0">if</FONT></B> (global_tolerance != 0.)
          {
            libmesh_assert_equal_to (nelem_target, 0);

            UniformRefinementEstimator * u =
              <B><FONT COLOR="#A020F0">new</FONT></B> UniformRefinementEstimator;

            u-&gt;error_norm = L2;

            error_estimator.reset(u);
          }
        <B><FONT COLOR="#A020F0">else</FONT></B>
          {
            libmesh_assert_greater (nelem_target, 0);

            error_estimator.reset(<B><FONT COLOR="#A020F0">new</FONT></B> KellyErrorEstimator);
          }

        error_estimator-&gt;estimate_error(system, error);

        Real global_error = error.l2_norm();
        <B><FONT COLOR="#5F9EA0">libMesh</FONT></B>::out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Adaptive step &quot;</FONT></B>
                     &lt;&lt; a_step
                     &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;: &quot;</FONT></B>
                     &lt;&lt; std::endl;

        <B><FONT COLOR="#A020F0">if</FONT></B> (global_tolerance != 0.)
          <B><FONT COLOR="#5F9EA0">libMesh</FONT></B>::out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Global_error = &quot;</FONT></B>
                       &lt;&lt; global_error
                       &lt;&lt; std::endl;

        <B><FONT COLOR="#A020F0">if</FONT></B> (global_tolerance != 0.)
          <B><FONT COLOR="#5F9EA0">libMesh</FONT></B>::out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Worst element error = &quot;</FONT></B>
                       &lt;&lt; error.maximum()
                       &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;, mean = &quot;</FONT></B>
                       &lt;&lt; error.mean()
                       &lt;&lt; std::endl;

        <B><FONT COLOR="#A020F0">if</FONT></B> (global_tolerance != 0.)
          {
            <B><FONT COLOR="#A020F0">if</FONT></B> (global_error &lt; global_tolerance)
              <B><FONT COLOR="#A020F0">break</FONT></B>;
            mesh_refinement.flag_elements_by_error_tolerance(error);
          }
        <B><FONT COLOR="#A020F0">else</FONT></B>
          {
            <B><FONT COLOR="#A020F0">if</FONT></B> (mesh_refinement.flag_elements_by_nelem_target(error))
              {
                mesh_refinement.refine_and_coarsen_elements();
                equation_systems.reinit();
                a_step = max_adaptivesteps;
                <B><FONT COLOR="#A020F0">break</FONT></B>;
              }
          }

        mesh_refinement.refine_and_coarsen_elements();
        equation_systems.reinit();

        <B><FONT COLOR="#5F9EA0">libMesh</FONT></B>::out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Refined mesh to &quot;</FONT></B>
                     &lt;&lt; mesh.n_active_elem()
                     &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; active elements and &quot;</FONT></B>
                     &lt;&lt; equation_systems.n_active_dofs()
                     &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; active dofs.&quot;</FONT></B>
                     &lt;&lt; std::endl;
      }
    <B><FONT COLOR="#A020F0">if</FONT></B> (a_step == max_adaptivesteps)
      {
        system.solve();

        system.postprocess();
      }


  #ifdef LIBMESH_HAVE_EXODUS_API
    ExodusII_IO(mesh).write_equation_systems
      (<B><FONT COLOR="#BC8F8F">&quot;out.e&quot;</FONT></B>, equation_systems);
  #endif <I><FONT COLOR="#B22222">// #ifdef LIBMESH_HAVE_EXODUS_API
</FONT></I>
  #ifdef LIBMESH_HAVE_GMV
    GMVIO(mesh).write_equation_systems
      (<B><FONT COLOR="#BC8F8F">&quot;out.gmv&quot;</FONT></B>, equation_systems);
  #endif <I><FONT COLOR="#B22222">// #ifdef LIBMESH_HAVE_GMV
</FONT></I>
  #ifdef LIBMESH_HAVE_FPARSER
    ExactSolution exact_sol(equation_systems);
    <B><FONT COLOR="#228B22">const</FONT></B> std::string exact_str = (dim == 2) ?
      <B><FONT COLOR="#BC8F8F">&quot;sin(pi*x)*sin(pi*y)&quot;</FONT></B> : <B><FONT COLOR="#BC8F8F">&quot;sin(pi*x)*sin(pi*y)*sin(pi*z)&quot;</FONT></B>;
    ParsedFunction&lt;Number&gt; exact_func(exact_str);
    exact_sol.attach_exact_value(0, &amp;exact_func);
    exact_sol.compute_error(<B><FONT COLOR="#BC8F8F">&quot;Heat&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;T&quot;</FONT></B>);

    Number err = exact_sol.l2_error(<B><FONT COLOR="#BC8F8F">&quot;Heat&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;T&quot;</FONT></B>);

    <B><FONT COLOR="#5F9EA0">libMesh</FONT></B>::out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;L2-Error is: &quot;</FONT></B> &lt;&lt; err &lt;&lt; std::endl;

    libmesh_assert_less(libmesh_real(err), 2e-3);

  #endif <I><FONT COLOR="#B22222">// #ifdef LIBMESH_HAVE_FPARSER
</FONT></I>
  #endif <I><FONT COLOR="#B22222">// #ifndef LIBMESH_ENABLE_AMR
</FONT></I>
    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  }
</pre>
<a name="nocomments"></a>
<br><br><br> <h1> The source file heatsystem.C without comments: </h1>
<pre>
  #include <B><FONT COLOR="#BC8F8F">&quot;heatsystem.h&quot;</FONT></B>

  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/dirichlet_boundaries.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/dof_map.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/fe_base.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/fe_interface.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/fem_context.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/getpot.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/mesh.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/quadrature.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/string_to_enum.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/zero_function.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/elem.h&quot;</FONT></B>

  using namespace libMesh;

  <B><FONT COLOR="#228B22">void</FONT></B> HeatSystem::init_data ()
  {
    T_var = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;add_variable(<B><FONT COLOR="#BC8F8F">&quot;T&quot;</FONT></B>, static_cast&lt;Order&gt;(_fe_order),
                               <B><FONT COLOR="#5F9EA0">Utility</FONT></B>::string_to_enum&lt;FEFamily&gt;(_fe_family));

    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dim = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;get_mesh().mesh_dimension();

    <B><FONT COLOR="#228B22">const</FONT></B> boundary_id_type all_ids[6] = {0, 1, 2, 3, 4, 5};
    <B><FONT COLOR="#5F9EA0">std</FONT></B>::set&lt;boundary_id_type&gt; nonyplus_bdys(all_ids, all_ids+(dim*2));
    <B><FONT COLOR="#228B22">const</FONT></B> boundary_id_type yplus_id = (dim == 3) ? 3 : 2;
    nonyplus_bdys.erase(yplus_id);

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; T_only(1, T_var);
    ZeroFunction&lt;Number&gt; zero;

    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;get_dof_map().add_dirichlet_boundary
      (DirichletBoundary (nonyplus_bdys, T_only, &amp;zero));

    <B><FONT COLOR="#5F9EA0">FEMSystem</FONT></B>::init_data();

    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;time_evolving(0);
  }



  <B><FONT COLOR="#228B22">void</FONT></B> HeatSystem::init_context(DiffContext &amp; context)
  {
    FEMContext &amp; c = libmesh_cast_ref&lt;FEMContext &amp;&gt;(context);

    <B><FONT COLOR="#228B22">const</FONT></B> std::set&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>&gt; &amp; elem_dims =
      c.elem_dimensions();

    <B><FONT COLOR="#A020F0">for</FONT></B> (std::set&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B>&gt;::const_iterator dim_it =
           elem_dims.begin(); dim_it != elem_dims.end(); ++dim_it)
      {
        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">char</FONT></B> dim = *dim_it;

        FEBase * fe = libmesh_nullptr;

        c.get_element_fe(T_var, fe, dim);

        fe-&gt;get_JxW();  <I><FONT COLOR="#B22222">// For integration
</FONT></I>        fe-&gt;get_dphi(); <I><FONT COLOR="#B22222">// For bilinear form
</FONT></I>        fe-&gt;get_xyz();  <I><FONT COLOR="#B22222">// For forcing
</FONT></I>        fe-&gt;get_phi();  <I><FONT COLOR="#B22222">// For forcing
</FONT></I>      }

    <B><FONT COLOR="#5F9EA0">FEMSystem</FONT></B>::init_context(context);
  }


  <B><FONT COLOR="#228B22">bool</FONT></B> HeatSystem::element_time_derivative (<B><FONT COLOR="#228B22">bool</FONT></B> request_jacobian,
                                            DiffContext &amp; context)
  {
    FEMContext &amp; c = libmesh_cast_ref&lt;FEMContext &amp;&gt;(context);

    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> mesh_dim =
      c.get_system().get_mesh().mesh_dimension();

    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dim = c.get_elem().dim();
    FEBase * fe = libmesh_nullptr;
    c.get_element_fe(T_var, fe, dim);

    <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;Real&gt; &amp; JxW = fe-&gt;get_JxW();

    <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;Point&gt; &amp; xyz = fe-&gt;get_xyz();

    <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;Real&gt; &gt; &amp; phi = fe-&gt;get_phi();

    <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;RealGradient&gt; &gt; &amp; dphi = fe-&gt;get_dphi();

    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n_T_dofs = c.get_dof_indices(T_var).size();

    DenseSubMatrix&lt;Number&gt; &amp; K = c.get_elem_jacobian(T_var, T_var);
    DenseSubVector&lt;Number&gt; &amp; F = c.get_elem_residual(T_var);

    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n_qpoints = c.get_element_qrule().n_points();

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> qp=0; qp != n_qpoints; qp++)
      {
        Gradient grad_T = c.interior_gradient(T_var, qp);

        <B><FONT COLOR="#228B22">const</FONT></B> Number k = _k[dim];

        <B><FONT COLOR="#228B22">const</FONT></B> Point &amp; p = xyz[qp];

        <B><FONT COLOR="#228B22">const</FONT></B> Number u_exact = (mesh_dim == 2) ?
          <B><FONT COLOR="#5F9EA0">std</FONT></B>::sin(libMesh::pi*p(0)) * std::sin(libMesh::pi*p(1)) :
          <B><FONT COLOR="#5F9EA0">std</FONT></B>::sin(libMesh::pi*p(0)) * std::sin(libMesh::pi*p(1)) *
          <B><FONT COLOR="#5F9EA0">std</FONT></B>::sin(libMesh::pi*p(2));

        <B><FONT COLOR="#228B22">const</FONT></B> Number forcing = (dim == mesh_dim) ?
          -k * u_exact * (dim * libMesh::pi * libMesh::pi) : 0;

        <B><FONT COLOR="#228B22">const</FONT></B> Number JxWxNK = JxW[qp] * -k;

        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i != n_T_dofs; i++)
          F(i) += JxWxNK * (grad_T * dphi[i][qp] + forcing * phi[i][qp]);
        <B><FONT COLOR="#A020F0">if</FONT></B> (request_jacobian)
          {
            <B><FONT COLOR="#228B22">const</FONT></B> Number JxWxNKxD = JxWxNK *
              context.get_elem_solution_derivative();

            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i != n_T_dofs; i++)
              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j != n_T_dofs; ++j)
                K(i,j) += JxWxNKxD * (dphi[i][qp] * dphi[j][qp]);
          }
      } <I><FONT COLOR="#B22222">// end of the quadrature point qp-loop
</FONT></I>
    <B><FONT COLOR="#A020F0">return</FONT></B> request_jacobian;
  }
</pre>
<a name="output"></a>
<br><br><br> <h1> The console output of the program: </h1>
<pre>
***************************************************************
* Running Example fem_system_ex4:
*   example-opt
***************************************************************

 Mesh Information:
  elem_dimensions()={1, 2}
  spatial_dimension()=2
  n_nodes()=1107
    n_local_nodes()=1107
  n_elem()=280
    n_local_elem()=280
    n_active_elem()=280
  n_subdomains()=2
  n_partitions()=1
  n_processors()=1
  n_threads()=1
  processor_id()=0

 EquationSystems
  n_systems()=1
   System #0, "Heat"
    Type "Implicit"
    Variables="T"
    Finite Element Types="LAGRANGE", "JACOBI_20_00"
    Infinite Element Mapping="CARTESIAN"
    Approximation Orders="FIRST", "THIRD"
    n_dofs()=294
    n_local_dofs()=294
    n_constrained_dofs()=47
    n_local_constrained_dofs()=47
    n_vectors()=1
    n_matrices()=1
    DofMap Sparsity
      Average  On-Processor Bandwidth <= 8.29932
      Average Off-Processor Bandwidth <= 0
      Maximum  On-Processor Bandwidth <= 9
      Maximum Off-Processor Bandwidth <= 0
    DofMap Constraints
      Number of DoF Constraints = 47
      Average DoF Constraint Length= 0

Assembling the System
*** Warning, This code is deprecated, and likely to be removed in future library versions! ../../../include/libmesh/libmesh_common.h, line 497, compiled Apr 12 2016 at 12:26:03 ***
Nonlinear Residual: 0.44101
Linear solve starting, tolerance 0.00044101
Linear solve finished, step 6, residual 0.000218566
Trying full Newton step
  Current Residual: 0.000263619
  Nonlinear step: |du|/|u| = 1, |du| = 9.07515
Assembling the System
Nonlinear Residual: 0.000263619
Linear solve starting, tolerance 2.63619e-07
Linear solve finished, step 13, residual 2.19057e-11
Trying full Newton step
  Current Residual: 3.02183e-11
  Nonlinear solver converged, step 1, residual reduction 6.85205e-11 < 1e-07
  Nonlinear solver relative step size 4.50166e-05 > 1e-07
Adaptive step 0:
Refined mesh to 533 active elements and 476 active dofs.
Assembling the System
Nonlinear Residual: 0.226674
Linear solve starting, tolerance 0.000226674
Linear solve finished, step 11, residual 4.68492e-06
Trying full Newton step
  Current Residual: 9.0083e-06
  Nonlinear step: |du|/|u| = 0.0026867, |du| = 0.0430946
Assembling the System
Nonlinear Residual: 9.0083e-06
Linear solve starting, tolerance 9.0083e-09
Linear solve finished, step 22, residual 1.16731e-14
Trying full Newton step
  Current Residual: 4.61342e-14
  Nonlinear solver converged, step 1, residual reduction 2.03527e-13 < 1e-07
  Nonlinear solver relative step size 6.58778e-07 > 1e-07
Adaptive step 1:
Refined mesh to 1049 active elements and 938 active dofs.
Assembling the System
Nonlinear Residual: 0.156385
Linear solve starting, tolerance 0.000156385
Linear solve finished, step 18, residual 2.33773e-06
Trying full Newton step
  Current Residual: 3.11137e-06
  Nonlinear step: |du|/|u| = 0.00129394, |du| = 0.0284054
Assembling the System
Nonlinear Residual: 3.11137e-06
Linear solve starting, tolerance 3.11137e-09
Linear solve finished, step 33, residual 6.09154e-15
Trying full Newton step
  Current Residual: 1.82249e-14
  Nonlinear solver converged, step 1, residual reduction 1.16539e-13 < 1e-07
  Nonlinear solver relative step size 9.59056e-07 > 1e-07
L2-Error is: 0.000273268

 -------------------------------------------------------------------------------------------------------------------
| Time:           Tue Apr 12 15:29:01 2016                                                                          |
| OS:             Darwin                                                                                            |
| HostName:       peterson-laptop.local                                                                             |
| OS Release:     15.0.0                                                                                            |
| OS Version:     Darwin Kernel Version 15.0.0: Sat Sep 19 15:53:46 PDT 2015; root:xnu-3247.10.11~1/RELEASE_X86_64  |
| Machine:        x86_64                                                                                            |
| Username:       petejw                                                                                            |
| Configuration:  ../configure  'INSTALL=/usr/bin/install -C'                                                       |
|  '--with-methods=opt dbg'                                                                                         |
|  '--prefix=/Users/petejw/projects/libmesh_git/installed'                                                          |
|  '--enable-perflog'                                                                                               |
|  '--enable-tracefiles'                                                                                            |
|  '--disable-blocked-storage'                                                                                      |
|  '--enable-default-comm-world'                                                                                    |
|  '--enable-tecio'                                                                                                 |
|  '--enable-unique-ptr'                                                                                            |
|  '--enable-ifem'                                                                                                  |
|  'PETSC_DIR=/opt/moose/petsc/mpich_petsc-3.6.1/clang-opt-superlu'                                                 |
|  'SLEPC_DIR=/opt/petejw/slepc/3.6.1'                                                                              |
|  'CPPFLAGS= '                                                                                                     |
|  'LIBS= '                                                                                                         |
|  'CPPFLAGS=  '                                                                                                    |
|  'LIBS=  '                                                                                                        |
|  '--disable-netcdf-4'                                                                                             |
|  '--disable-testsets'                                                                                             |
|  'CXX=mpicxx'                                                                                                     |
|  'CC=mpicc'                                                                                                       |
|  'F77=mpif77'                                                                                                     |
|  'FC=mpif90'                                                                                                      |
|  'CPPFLAGS=   '                                                                                                   |
|  'LIBS=   '                                                                                                       |
 -------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------
| libMesh Performance: Alive time=0.535481, Active time=0.231857                                                  |
 -----------------------------------------------------------------------------------------------------------------
| Event                              nCalls     Total Time  Avg Time    Total Time  Avg Time    % of Active Time  |
|                                               w/o Sub     w/o Sub     With Sub    With Sub    w/o S    With S   |
|-----------------------------------------------------------------------------------------------------------------|
|                                                                                                                 |
|                                                                                                                 |
| BoundaryInfo                                                                                                    |
|   add_elements()                   1          0.0001      0.000101    0.0001      0.000101    0.04     0.04     |
|                                                                                                                 |
| DofMap                                                                                                          |
|   add_neighbors_to_send_list()     3          0.0004      0.000144    0.0004      0.000144    0.19     0.19     |
|   build_constraint_matrix()        7448       0.0028      0.000000    0.0028      0.000000    1.20     1.20     |
|   build_sparsity()                 3          0.0023      0.000755    0.0027      0.000916    0.98     1.19     |
|   cnstrn_elem_mat_vec()            3724       0.0009      0.000000    0.0009      0.000000    0.39     0.39     |
|   constrain_elem_vector()          3724       0.0008      0.000000    0.0008      0.000000    0.34     0.34     |
|   create_dof_constraints()         3          0.0047      0.001567    0.0053      0.001778    2.03     2.30     |
|   distribute_dofs()                3          0.0006      0.000214    0.0036      0.001196    0.28     1.55     |
|   dof_indices()                    33837      0.0066      0.000000    0.0066      0.000000    2.85     2.85     |
|   enforce_constraints_exactly()    14         0.0004      0.000030    0.0004      0.000030    0.18     0.18     |
|   old_dof_indices()                4746       0.0014      0.000000    0.0014      0.000000    0.59     0.59     |
|   prepare_send_list()              4          0.0000      0.000000    0.0000      0.000000    0.00     0.00     |
|   reinit()                         3          0.0029      0.000981    0.0029      0.000981    1.27     1.27     |
|                                                                                                                 |
| EquationSystems                                                                                                 |
|   build_solution_vector()          2          0.0018      0.000920    0.0025      0.001226    0.79     1.06     |
|                                                                                                                 |
| ExodusII_IO                                                                                                     |
|   write_nodal_data()               1          0.0030      0.002962    0.0030      0.002962    1.28     1.28     |
|                                                                                                                 |
| FE                                                                                                              |
|   compute_shape_functions()        20371      0.0094      0.000000    0.0094      0.000000    4.03     4.03     |
|   init_shape_functions()           10044      0.0172      0.000002    0.0172      0.000002    7.40     7.40     |
|   inverse_map()                    47905      0.0215      0.000000    0.0215      0.000000    9.26     9.26     |
|                                                                                                                 |
| FEMSystem                                                                                                       |
|   assembly()                       6          0.0117      0.001945    0.0247      0.004121    5.03     10.66    |
|   assembly(get_residual)           6          0.0107      0.001782    0.0234      0.003903    4.61     10.10    |
|   postprocess()                    3          0.0024      0.000808    0.0055      0.001820    1.05     2.35     |
|                                                                                                                 |
| FEMap                                                                                                           |
|   compute_affine_map()             20371      0.0111      0.000001    0.0111      0.000001    4.81     4.81     |
|   compute_face_map()               5594       0.0055      0.000001    0.0135      0.000002    2.37     5.82     |
|   init_face_shape_functions()      28         0.0000      0.000001    0.0000      0.000001    0.01     0.01     |
|   init_reference_to_physical_map() 10044      0.0199      0.000002    0.0199      0.000002    8.57     8.57     |
|                                                                                                                 |
| GMVIO                                                                                                           |
|   write_nodal_data()               1          0.0131      0.013051    0.0131      0.013051    5.63     5.63     |
|                                                                                                                 |
| GenericProjector                                                                                                |
|   copy_dofs                        522        0.0002      0.000000    0.0012      0.000002    0.09     0.51     |
|   operator()                       2          0.0029      0.001444    0.0848      0.042387    1.25     36.56    |
|   project_edges                    1060       0.0002      0.000000    0.0002      0.000000    0.07     0.07     |
|   project_interior                 1060       0.0001      0.000000    0.0001      0.000000    0.06     0.06     |
|   project_nodes                    1060       0.0023      0.000002    0.0782      0.000074    0.99     33.71    |
|   project_sides                    1060       0.0001      0.000000    0.0001      0.000000    0.05     0.05     |
|                                                                                                                 |
| JumpErrorEstimator                                                                                              |
|   estimate_error()                 2          0.0158      0.007914    0.0457      0.022873    6.83     19.73    |
|                                                                                                                 |
| Mesh                                                                                                            |
|   contract()                       2          0.0000      0.000017    0.0001      0.000049    0.01     0.04     |
|   find_neighbors()                 4          0.0045      0.001132    0.0045      0.001132    1.95     1.95     |
|   renumber_nodes_and_elem()        10         0.0002      0.000025    0.0002      0.000025    0.11     0.11     |
|                                                                                                                 |
| MeshOutput                                                                                                      |
|   write_equation_systems()         2          0.0000      0.000012    0.0185      0.009245    0.01     7.97     |
|                                                                                                                 |
| MeshRefinement                                                                                                  |
|   _coarsen_elements()              4          0.0000      0.000010    0.0000      0.000010    0.02     0.02     |
|   _refine_elements()               4          0.0035      0.000878    0.0066      0.001661    1.52     2.87     |
|   add_node()                       8916       0.0024      0.000000    0.0024      0.000000    1.04     1.04     |
|   make_coarsening_compatible()     6          0.0004      0.000066    0.0004      0.000066    0.17     0.17     |
|   make_flags_parallel_consistent() 6          0.0003      0.000042    0.0003      0.000042    0.11     0.11     |
|   make_refinement_compatible()     6          0.0001      0.000014    0.0001      0.000014    0.03     0.03     |
|                                                                                                                 |
| MeshTools::Generation                                                                                           |
|   build_cube()                     1          0.0004      0.000403    0.0004      0.000403    0.17     0.17     |
|                                                                                                                 |
| NewtonSolver                                                                                                    |
|   solve()                          3          0.0007      0.000220    0.0525      0.017508    0.29     22.65    |
|                                                                                                                 |
| OldSolutionValue                                                                                                |
|   Number eval_at_node()            4032       0.0005      0.000000    0.0005      0.000000    0.23     0.23     |
|   check_old_context(c)             522        0.0004      0.000001    0.0008      0.000001    0.19     0.32     |
|   check_old_context(c,p)           2908       0.0023      0.000001    0.0050      0.000002    1.01     2.16     |
|   eval_at_point()                  2908       0.0346      0.000012    0.0741      0.000025    14.92    31.94    |
|   eval_old_dofs()                  522        0.0001      0.000000    0.0009      0.000002    0.05     0.40     |
|                                                                                                                 |
| Parallel                                                                                                        |
|   allgather()                      3          0.0000      0.000000    0.0000      0.000000    0.00     0.00     |
|                                                                                                                 |
| Partitioner                                                                                                     |
|   single_partition()               4          0.0002      0.000041    0.0002      0.000041    0.07     0.07     |
|                                                                                                                 |
| PetscLinearSolver                                                                                               |
|   solve()                          6          0.0034      0.000561    0.0034      0.000561    1.45     1.45     |
|                                                                                                                 |
| System                                                                                                          |
|   project_vector(old,new)          2          0.0012      0.000592    0.0865      0.043266    0.51     37.32    |
|                                                                                                                 |
| TopologyMap                                                                                                     |
|   init()                           4          0.0037      0.000931    0.0037      0.000931    1.61     1.61     |
 -----------------------------------------------------------------------------------------------------------------
| Totals:                            192530     0.2319                                          100.00            |
 -----------------------------------------------------------------------------------------------------------------


***************************************************************
* Done Running Example fem_system_ex4:
*   example-opt
***************************************************************
</pre>
</div>

<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){
  $(window).on('scroll',function() {
    var scrolltop = $(this).scrollTop();

    if(scrolltop >= 215) {
      $('#fixedbar').fadeIn(250);
    }

    else if(scrolltop <= 210) {
      $('#fixedbar').fadeOut(250);
    }
  });
});
</script>

<!-- Google Analytics stuff -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-24978333-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</body>
</html>
