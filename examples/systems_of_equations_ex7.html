<!doctype html>
<html lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
  <title>libMesh - A C++ Finite Element Library</title>
  <meta name="author" content="libMesh development team">
  <link rel="stylesheet" type="text/css" media="all" href="../styles.css">
  <link rel="stylesheet" type="text/css" media="all" href="../doxygen_stylesheet.css">
</head>

<body>
  <nav id="fixedbar">
    <ul id="fixednav">
      <li><a href="../index.html">Home</a></li>
      <li><a href="../support.html">About Us</a></li>
      <li><a href="../publications.html">Publications</a></li>
      <li><a href="https://github.com/libMesh/libmesh/graphs/contributors">Developers</a></li>
      <li><a href="../installation.html">Installation</a></li>
      <li><a href="../examples.html">Examples</a></li>
     <li><a href="../doxygen/index.html">Documentation</a></li>
    </ul>
  </nav>

  <div id="w">
    <header id="logo"><a href="../index.html"><span id="logobg">SomeWebsiteLogo</span></a></header>

    <nav id="navigation">
      <ul>
        <li><a href="../index.html">Home</a></li>
        <li><a href="../support.html">About Us</a></li>
        <li><a href="../publications.html">Publications</a></li>
        <li><a href="https://github.com/libMesh/libmesh/graphs/contributors">Developers</a></li>
        <li><a href="../installation.html">Installation</a></li>
        <li><a href="../examples.html">Examples</a></li>
        <li><a href="../doxygen/index.html">Documentation</a></li>
      </ul>
    </nav>

<div id="content">

<a name="comments"></a>
<br><br><br> <h1> The source file systems_of_equations_ex7.C with comments: </h1>
<div class = "comment">
</div>

<div class ="fragment">
<pre>
        #include &lt;iostream&gt;
        #include &lt;algorithm&gt;
        #include &lt;cmath&gt;

</pre>
</div>
<div class = "comment">
Various include files needed for the mesh & solver functionality.
</div>

<div class ="fragment">
<pre>
        #include "libmesh/libmesh.h"
        #include "libmesh/mesh.h"
        #include "libmesh/mesh_refinement.h"
        #include "libmesh/exodusII_io.h"
        #include "libmesh/equation_systems.h"
        #include "libmesh/fe.h"
        #include "libmesh/quadrature_gauss.h"
        #include "libmesh/dof_map.h"
        #include "libmesh/sparse_matrix.h"
        #include "libmesh/numeric_vector.h"
        #include "libmesh/dense_matrix.h"
        #include "libmesh/dense_vector.h"
        #include "libmesh/elem.h"
        #include "libmesh/string_to_enum.h"
        #include "libmesh/getpot.h"
        #include "libmesh/mesh_generation.h"
        #include "libmesh/dirichlet_boundaries.h"
        #include "libmesh/zero_function.h"

</pre>
</div>
<div class = "comment">
The nonlinear solver and system we will be using
</div>

<div class ="fragment">
<pre>
        #include "libmesh/nonlinear_solver.h"
        #include "libmesh/nonlinear_implicit_system.h"

        #define BOUNDARY_ID_MIN_Z 0
        #define BOUNDARY_ID_MIN_Y 1
        #define BOUNDARY_ID_MAX_X 2
        #define BOUNDARY_ID_MAX_Y 3
        #define BOUNDARY_ID_MIN_X 4
        #define BOUNDARY_ID_MAX_Z 5

        using namespace libMesh;



        class LargeDeformationElasticity : public NonlinearImplicitSystem::ComputeResidual,
                                           public NonlinearImplicitSystem::ComputeJacobian
        {
        private:
          EquationSystems & es;

        public:

          LargeDeformationElasticity (EquationSystems & es_in) :
            es(es_in)
          {}

          /**
           * Kronecker delta function.
           */
          Real kronecker_delta(unsigned int i,
                               unsigned int j)
          {
            return i == j ? 1. : 0.;
          }

          /**
           * Evaluate the fourth order tensor (C_ijkl) that relates stress to strain.
           */
          Real elasticity_tensor(Real young_modulus,
                                 Real poisson_ratio,
                                 unsigned int i,
                                 unsigned int j,
                                 unsigned int k,
                                 unsigned int l)
          {
</pre>
</div>
<div class = "comment">
Define the Lame constants
</div>

<div class ="fragment">
<pre>
            const Real lambda_1 = (young_modulus*poisson_ratio)/((1.+poisson_ratio)*(1.-2.*poisson_ratio));
            const Real lambda_2 = young_modulus/(2.*(1.+poisson_ratio));

            return lambda_1 * kronecker_delta(i,j) * kronecker_delta(k,l) +
              lambda_2 * (kronecker_delta(i,k) * kronecker_delta(j,l) + kronecker_delta(i,l) * kronecker_delta(j,k));
          }


          /**
           * Evaluate the Jacobian of the nonlinear system.
           */
          virtual void jacobian (const NumericVector&lt;Number&gt; & soln,
                                 SparseMatrix&lt;Number&gt; & jacobian,
                                 NonlinearImplicitSystem & /*sys*/)
          {
            const Real young_modulus = es.parameters.get&lt;Real&gt;("young_modulus");
            const Real poisson_ratio = es.parameters.get&lt;Real&gt;("poisson_ratio");

            const MeshBase & mesh = es.get_mesh();
            const unsigned int dim = mesh.mesh_dimension();

            NonlinearImplicitSystem & system =
              es.get_system&lt;NonlinearImplicitSystem&gt;("NonlinearElasticity");

            const unsigned int u_var = system.variable_number ("u");

            const DofMap & dof_map = system.get_dof_map();

            FEType fe_type = dof_map.variable_type(u_var);
            UniquePtr&lt;FEBase&gt; fe (FEBase::build(dim, fe_type));
            QGauss qrule (dim, fe_type.default_quadrature_order());
            fe-&gt;attach_quadrature_rule (&qrule);

            UniquePtr&lt;FEBase&gt; fe_face (FEBase::build(dim, fe_type));
            QGauss qface (dim-1, fe_type.default_quadrature_order());
            fe_face-&gt;attach_quadrature_rule (&qface);

            const std::vector&lt;Real&gt; & JxW = fe-&gt;get_JxW();
            const std::vector&lt;std::vector&lt;Real&gt; &gt; & phi = fe-&gt;get_phi();
            const std::vector&lt;std::vector&lt;RealGradient&gt; &gt; & dphi = fe-&gt;get_dphi();

            DenseMatrix&lt;Number&gt; Ke;
            DenseSubMatrix&lt;Number&gt; Ke_var[3][3] =
              {
                {DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke)},
                {DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke)},
                {DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke)}
              };

            std::vector&lt;dof_id_type&gt; dof_indices;
            std::vector&lt;std::vector&lt;dof_id_type&gt; &gt; dof_indices_var(3);

            jacobian.zero();

            MeshBase::const_element_iterator       el     = mesh.active_local_elements_begin();
            const MeshBase::const_element_iterator end_el = mesh.active_local_elements_end();

            for ( ; el != end_el; ++el)
              {
                const Elem * elem = *el;
                dof_map.dof_indices (elem, dof_indices);
                for (unsigned int var=0; var&lt;3; var++)
                  dof_map.dof_indices (elem, dof_indices_var[var], var);

                const unsigned int n_dofs = dof_indices.size();
                const unsigned int n_var_dofs = dof_indices_var[0].size();

                fe-&gt;reinit (elem);

                Ke.resize (n_dofs, n_dofs);
                for (unsigned int var_i=0; var_i&lt;3; var_i++)
                  for (unsigned int var_j=0; var_j&lt;3; var_j++)
                    Ke_var[var_i][var_j].reposition (var_i*n_var_dofs, var_j*n_var_dofs, n_var_dofs, n_var_dofs);

                for (unsigned int qp=0; qp&lt;qrule.n_points(); qp++)
                  {
                    DenseVector&lt;Number&gt; u_vec(3);
                    DenseMatrix&lt;Number&gt; grad_u(3, 3);
                    for (unsigned int var_i=0; var_i&lt;3; var_i++)
                      {
                        for (unsigned int j=0; j&lt;n_var_dofs; j++)
                          u_vec(var_i) += phi[j][qp]*soln(dof_indices_var[var_i][j]);

</pre>
</div>
<div class = "comment">
Row is variable u1, u2, or u3, column is x, y, or z
</div>

<div class ="fragment">
<pre>
                        for (unsigned int var_j=0; var_j&lt;3; var_j++)
                          for (unsigned int j=0; j&lt;n_var_dofs; j++)
                            grad_u(var_i,var_j) += dphi[j][qp](var_j)*soln(dof_indices_var[var_i][j]);
                      }

                    DenseMatrix&lt;Number&gt; strain_tensor(3, 3);
                    for (unsigned int i=0; i&lt;3; i++)
                      for (unsigned int j=0; j&lt;3; j++)
                        {
                          strain_tensor(i,j) += 0.5 * (grad_u(i,j) + grad_u(j,i));

                          for (unsigned int k=0; k&lt;3; k++)
                            strain_tensor(i,j) += 0.5 * grad_u(k,i)*grad_u(k,j);
                        }

</pre>
</div>
<div class = "comment">
Define the deformation gradient
</div>

<div class ="fragment">
<pre>
                    DenseMatrix&lt;Number&gt; F(3, 3);
                    F = grad_u;
                    for (unsigned int var=0; var&lt;3; var++)
                      F(var, var) += 1.;

                    DenseMatrix&lt;Number&gt; stress_tensor(3, 3);

                    for (unsigned int i=0; i&lt;3; i++)
                      for (unsigned int j=0; j&lt;3; j++)
                        for (unsigned int k=0; k&lt;3; k++)
                          for (unsigned int l=0; l&lt;3; l++)
                            stress_tensor(i,j) +=
                              elasticity_tensor(young_modulus, poisson_ratio, i, j, k, l) * strain_tensor(k, l);

                    for (unsigned int dof_i=0; dof_i&lt;n_var_dofs; dof_i++)
                      for (unsigned int dof_j=0; dof_j&lt;n_var_dofs; dof_j++)
                        {
                          for (unsigned int i=0; i&lt;3; i++)
                            for (unsigned int j=0; j&lt;3; j++)
                              for (unsigned int m=0; m&lt;3; m++)
                                Ke_var[i][i](dof_i,dof_j) += JxW[qp] *
                                  (-dphi[dof_j][qp](m) * stress_tensor(m,j) * dphi[dof_i][qp](j));

                          for (unsigned int i=0; i&lt;3; i++)
                            for (unsigned int j=0; j&lt;3; j++)
                              for (unsigned int k=0; k&lt;3; k++)
                                for (unsigned int l=0; l&lt;3; l++)
                                  {
                                    Number FxC_ijkl = 0.;
                                    for (unsigned int m=0; m&lt;3; m++)
                                      FxC_ijkl += F(i,m) * elasticity_tensor(young_modulus, poisson_ratio, m, j, k, l);

                                    Ke_var[i][k](dof_i,dof_j) += JxW[qp] *
                                      (-0.5 * FxC_ijkl * dphi[dof_j][qp](l) * dphi[dof_i][qp](j));

                                    Ke_var[i][l](dof_i,dof_j) += JxW[qp] *
                                      (-0.5 * FxC_ijkl * dphi[dof_j][qp](k) * dphi[dof_i][qp](j));

                                    for (unsigned int n=0; n&lt;3; n++)
                                      Ke_var[i][n](dof_i,dof_j) += JxW[qp] *
                                        (-0.5 * FxC_ijkl * (dphi[dof_j][qp](k) * grad_u(n,l) + dphi[dof_j][qp](l) * grad_u(n,k)) * dphi[dof_i][qp](j));
                                  }
                        }
                  }

                dof_map.constrain_element_matrix (Ke, dof_indices);
                jacobian.add_matrix (Ke, dof_indices);
              }
          }

          /**
           * Evaluate the residual of the nonlinear system.
           */
          virtual void residual (const NumericVector&lt;Number&gt; & soln,
                                 NumericVector&lt;Number&gt; & residual,
                                 NonlinearImplicitSystem & /*sys*/)
          {
            const Real young_modulus = es.parameters.get&lt;Real&gt;("young_modulus");
            const Real poisson_ratio = es.parameters.get&lt;Real&gt;("poisson_ratio");
            const Real forcing_magnitude = es.parameters.get&lt;Real&gt;("forcing_magnitude");

            const MeshBase & mesh = es.get_mesh();
            const unsigned int dim = mesh.mesh_dimension();

            NonlinearImplicitSystem & system =
              es.get_system&lt;NonlinearImplicitSystem&gt;("NonlinearElasticity");

            const unsigned int u_var = system.variable_number ("u");

            const DofMap & dof_map = system.get_dof_map();

            FEType fe_type = dof_map.variable_type(u_var);
            UniquePtr&lt;FEBase&gt; fe (FEBase::build(dim, fe_type));
            QGauss qrule (dim, fe_type.default_quadrature_order());
            fe-&gt;attach_quadrature_rule (&qrule);

            UniquePtr&lt;FEBase&gt; fe_face (FEBase::build(dim, fe_type));
            QGauss qface (dim-1, fe_type.default_quadrature_order());
            fe_face-&gt;attach_quadrature_rule (&qface);

            const std::vector&lt;Real&gt; & JxW = fe-&gt;get_JxW();
            const std::vector&lt;std::vector&lt;Real&gt; &gt; & phi = fe-&gt;get_phi();
            const std::vector&lt;std::vector&lt;RealGradient&gt; &gt; & dphi = fe-&gt;get_dphi();

            DenseVector&lt;Number&gt; Re;

            DenseSubVector&lt;Number&gt; Re_var[3] =
              {DenseSubVector&lt;Number&gt;(Re),
               DenseSubVector&lt;Number&gt;(Re),
               DenseSubVector&lt;Number&gt;(Re)};

            std::vector&lt;dof_id_type&gt; dof_indices;
            std::vector&lt; std::vector&lt;dof_id_type&gt; &gt; dof_indices_var(3);

            residual.zero();

            MeshBase::const_element_iterator       el     = mesh.active_local_elements_begin();
            const MeshBase::const_element_iterator end_el = mesh.active_local_elements_end();

            for ( ; el != end_el; ++el)
              {
                const Elem * elem = *el;
                dof_map.dof_indices (elem, dof_indices);
                for (unsigned int var=0; var&lt;3; var++)
                  dof_map.dof_indices (elem, dof_indices_var[var], var);

                const unsigned int n_dofs = dof_indices.size();
                const unsigned int n_var_dofs = dof_indices_var[0].size();

                fe-&gt;reinit (elem);

                Re.resize (n_dofs);
                for (unsigned int var=0; var&lt;3; var++)
                  Re_var[var].reposition (var*n_var_dofs, n_var_dofs);

                for (unsigned int qp=0; qp&lt;qrule.n_points(); qp++)
                  {
                    DenseVector&lt;Number&gt; u_vec(3);
                    DenseMatrix&lt;Number&gt; grad_u(3, 3);
                    for (unsigned int var_i=0; var_i&lt;3; var_i++)
                      {
                        for (unsigned int j=0; j&lt;n_var_dofs; j++)
                          u_vec(var_i) += phi[j][qp]*soln(dof_indices_var[var_i][j]);

</pre>
</div>
<div class = "comment">
Row is variable u, v, or w column is x, y, or z
</div>

<div class ="fragment">
<pre>
                        for (unsigned int var_j=0; var_j&lt;3; var_j++)
                          for (unsigned int j=0; j&lt;n_var_dofs; j++)
                            grad_u(var_i,var_j) += dphi[j][qp](var_j)*soln(dof_indices_var[var_i][j]);
                      }

                    DenseMatrix&lt;Number&gt; strain_tensor(3, 3);
                    for (unsigned int i=0; i&lt;3; i++)
                      for (unsigned int j=0; j&lt;3; j++)
                        {
                          strain_tensor(i,j) += 0.5 * (grad_u(i,j) + grad_u(j,i));

                          for (unsigned int k=0; k&lt;3; k++)
                            strain_tensor(i,j) += 0.5 * grad_u(k,i)*grad_u(k,j);
                        }

</pre>
</div>
<div class = "comment">
Define the deformation gradient
</div>

<div class ="fragment">
<pre>
                    DenseMatrix&lt;Number&gt; F(3, 3);
                    F = grad_u;
                    for (unsigned int var=0; var&lt;3; var++)
                      F(var, var) += 1.;

                    DenseMatrix&lt;Number&gt; stress_tensor(3, 3);

                    for (unsigned int i=0; i&lt;3; i++)
                      for (unsigned int j=0; j&lt;3; j++)
                        for (unsigned int k=0; k&lt;3; k++)
                          for (unsigned int l=0; l&lt;3; l++)
                            stress_tensor(i,j) +=
                              elasticity_tensor(young_modulus, poisson_ratio, i, j, k, l) * strain_tensor(k,l);

                    DenseVector&lt;Number&gt; f_vec(3);
                    f_vec(0) = 0.;
                    f_vec(1) = 0.;
                    f_vec(2) = -forcing_magnitude;

                    for (unsigned int dof_i=0; dof_i&lt;n_var_dofs; dof_i++)
                      for (unsigned int i=0; i&lt;3; i++)
                        {
                          for (unsigned int j=0; j&lt;3; j++)
                            {
                              Number FxStress_ij = 0.;
                              for (unsigned int m=0; m&lt;3; m++)
                                FxStress_ij += F(i,m) * stress_tensor(m,j);

                              Re_var[i](dof_i) += JxW[qp] * (-FxStress_ij * dphi[dof_i][qp](j));
                            }

                          Re_var[i](dof_i) += JxW[qp] * (f_vec(i) * phi[dof_i][qp]);
                        }
                  }

                dof_map.constrain_element_vector (Re, dof_indices);
                residual.add_vector (Re, dof_indices);
              }
          }

          /**
           * Compute the Cauchy stress for the current solution.
           */
          void compute_stresses()
          {
            const Real young_modulus = es.parameters.get&lt;Real&gt;("young_modulus");
            const Real poisson_ratio = es.parameters.get&lt;Real&gt;("poisson_ratio");

            const MeshBase & mesh = es.get_mesh();
            const unsigned int dim = mesh.mesh_dimension();

            NonlinearImplicitSystem & system =
              es.get_system&lt;NonlinearImplicitSystem&gt;("NonlinearElasticity");

            unsigned int displacement_vars[3];
            displacement_vars[0] = system.variable_number ("u");
            displacement_vars[1] = system.variable_number ("v");
            displacement_vars[2] = system.variable_number ("w");
            const unsigned int u_var = system.variable_number ("u");

            const DofMap & dof_map = system.get_dof_map();
            FEType fe_type = dof_map.variable_type(u_var);
            UniquePtr&lt;FEBase&gt; fe (FEBase::build(dim, fe_type));
            QGauss qrule (dim, fe_type.default_quadrature_order());
            fe-&gt;attach_quadrature_rule (&qrule);

            const std::vector&lt;Real&gt; & JxW = fe-&gt;get_JxW();
            const std::vector&lt;std::vector&lt;RealGradient&gt; &gt; & dphi = fe-&gt;get_dphi();

</pre>
</div>
<div class = "comment">
Also, get a reference to the ExplicitSystem
</div>

<div class ="fragment">
<pre>
            ExplicitSystem & stress_system = es.get_system&lt;ExplicitSystem&gt;("StressSystem");
            const DofMap & stress_dof_map = stress_system.get_dof_map();
            unsigned int sigma_vars[6];
            sigma_vars[0] = stress_system.variable_number ("sigma_00");
            sigma_vars[1] = stress_system.variable_number ("sigma_01");
            sigma_vars[2] = stress_system.variable_number ("sigma_02");
            sigma_vars[3] = stress_system.variable_number ("sigma_11");
            sigma_vars[4] = stress_system.variable_number ("sigma_12");
            sigma_vars[5] = stress_system.variable_number ("sigma_22");

</pre>
</div>
<div class = "comment">
Storage for the stress dof indices on each element
</div>

<div class ="fragment">
<pre>
            std::vector&lt; std::vector&lt;dof_id_type&gt; &gt; dof_indices_var(system.n_vars());
            std::vector&lt;dof_id_type&gt; stress_dof_indices_var;

</pre>
</div>
<div class = "comment">
To store the stress tensor on each element
</div>

<div class ="fragment">
<pre>
            DenseMatrix&lt;Number&gt; elem_avg_stress_tensor(3, 3);

            MeshBase::const_element_iterator       el     = mesh.active_local_elements_begin();
            const MeshBase::const_element_iterator end_el = mesh.active_local_elements_end();

            for ( ; el != end_el; ++el)
              {
                const Elem * elem = *el;

                for (unsigned int var=0; var&lt;3; var++)
                  dof_map.dof_indices (elem, dof_indices_var[var], displacement_vars[var]);

                const unsigned int n_var_dofs = dof_indices_var[0].size();

                fe-&gt;reinit (elem);

</pre>
</div>
<div class = "comment">
clear the stress tensor
</div>

<div class ="fragment">
<pre>
                elem_avg_stress_tensor.resize(3, 3);

                for (unsigned int qp=0; qp&lt;qrule.n_points(); qp++)
                  {
                    DenseMatrix&lt;Number&gt; grad_u(3, 3);
</pre>
</div>
<div class = "comment">
Row is variable u1, u2, or u3, column is x, y, or z
</div>

<div class ="fragment">
<pre>
                    for (unsigned int var_i=0; var_i&lt;3; var_i++)
                      for (unsigned int var_j=0; var_j&lt;3; var_j++)
                        for (unsigned int j=0; j&lt;n_var_dofs; j++)
                          grad_u(var_i,var_j) += dphi[j][qp](var_j) * system.current_solution(dof_indices_var[var_i][j]);

                    DenseMatrix&lt;Number&gt; strain_tensor(3, 3);
                    for (unsigned int i=0; i&lt;3; i++)
                      for (unsigned int j=0; j&lt;3; j++)
                        {
                          strain_tensor(i,j) += 0.5 * (grad_u(i,j) + grad_u(j,i));

                          for (unsigned int k=0; k&lt;3; k++)
                            strain_tensor(i,j) += 0.5 * grad_u(k,i)*grad_u(k,j);
                        }

</pre>
</div>
<div class = "comment">
Define the deformation gradient
</div>

<div class ="fragment">
<pre>
                    DenseMatrix&lt;Number&gt; F(3, 3);
                    F = grad_u;
                    for (unsigned int var=0; var&lt;3; var++)
                      F(var, var) += 1.;

                    DenseMatrix&lt;Number&gt; stress_tensor(3, 3);
                    for (unsigned int i=0; i&lt;3; i++)
                      for (unsigned int j=0; j&lt;3; j++)
                        for (unsigned int k=0; k&lt;3; k++)
                          for (unsigned int l=0; l&lt;3; l++)
                            stress_tensor(i,j) +=
                              elasticity_tensor(young_modulus, poisson_ratio, i, j, k, l) * strain_tensor(k, l);

</pre>
</div>
<div class = "comment">
stress_tensor now holds the second Piola-Kirchoff stress (PK2) at point qp.
However, in this example we want to compute the Cauchy stress which is given by
1/det(F) * F * PK2 * F^T, hence we now apply this transformation.
</div>

<div class ="fragment">
<pre>
                    stress_tensor.scale(1./F.det());
                    stress_tensor.left_multiply(F);
                    stress_tensor.right_multiply_transpose(F);

</pre>
</div>
<div class = "comment">
We want to plot the average Cauchy stress on each element, hence
we integrate stress_tensor
</div>

<div class ="fragment">
<pre>
                    elem_avg_stress_tensor.add(JxW[qp], stress_tensor);
                  }

</pre>
</div>
<div class = "comment">
Get the average stress per element by dividing by volume
</div>

<div class ="fragment">
<pre>
                elem_avg_stress_tensor.scale(1./elem-&gt;volume());

</pre>
</div>
<div class = "comment">
load elem_sigma data into stress_system
</div>

<div class ="fragment">
<pre>
                unsigned int stress_var_index = 0;
                for (unsigned int i=0; i&lt;3; i++)
                  for (unsigned int j=i; j&lt;3; j++)
                    {
                      stress_dof_map.dof_indices (elem, stress_dof_indices_var, sigma_vars[stress_var_index]);

</pre>
</div>
<div class = "comment">
We are using CONSTANT MONOMIAL basis functions, hence we only need to get
one dof index per variable
</div>

<div class ="fragment">
<pre>
                      dof_id_type dof_index = stress_dof_indices_var[0];

                      if ((stress_system.solution-&gt;first_local_index() &lt;= dof_index) &&
                          (dof_index &lt; stress_system.solution-&gt;last_local_index()))
                        stress_system.solution-&gt;set(dof_index, elem_avg_stress_tensor(i,j));

                      stress_var_index++;
                    }
              }

</pre>
</div>
<div class = "comment">
Should call close and update when we set vector entries directly
</div>

<div class ="fragment">
<pre>
            stress_system.solution-&gt;close();
            stress_system.update();
          }

        };


        int main (int argc, char ** argv)
        {
          LibMeshInit init (argc, argv);

</pre>
</div>
<div class = "comment">
This example requires the PETSc nonlinear solvers
</div>

<div class ="fragment">
<pre>
          libmesh_example_requires(libMesh::default_solver_package() == PETSC_SOLVERS, "--enable-petsc");

          GetPot infile("systems_of_equations_ex7.in");
          const Real x_length = infile("x_length", 0.);
          const Real y_length = infile("y_length", 0.);
          const Real z_length = infile("z_length", 0.);
          const Real n_elem_x = infile("n_elem_x", 0);
          const Real n_elem_y = infile("n_elem_y", 0);
          const Real n_elem_z = infile("n_elem_z", 0);
          const std::string approx_order = infile("approx_order", "FIRST");
          const std::string fe_family = infile("fe_family", "LAGRANGE");

          const Real young_modulus = infile("Young_modulus", 1.0);
          const Real poisson_ratio = infile("poisson_ratio", 0.3);
          const Real forcing_magnitude = infile("forcing_magnitude", 0.001);

          const Real nonlinear_abs_tol = infile("nonlinear_abs_tol", 1.e-8);
          const Real nonlinear_rel_tol = infile("nonlinear_rel_tol", 1.e-8);
          const unsigned int nonlinear_max_its = infile("nonlinear_max_its", 50);

          const unsigned int n_solves = infile("n_solves", 10);
          const Real force_scaling = infile("force_scaling", 5.0);

          Mesh mesh(init.comm());

          MeshTools::Generation::build_cube(mesh,
                                            n_elem_x,
                                            n_elem_y,
                                            n_elem_z,
                                            0., x_length,
                                            0., y_length,
                                            0., z_length,
                                            HEX27);

          mesh.print_info();

          EquationSystems equation_systems (mesh);
          LargeDeformationElasticity lde(equation_systems);

          NonlinearImplicitSystem & system =
            equation_systems.add_system&lt;NonlinearImplicitSystem&gt; ("NonlinearElasticity");

          unsigned int u_var =
            system.add_variable("u",
                                Utility::string_to_enum&lt;Order&gt;   (approx_order),
                                Utility::string_to_enum&lt;FEFamily&gt;(fe_family));

          unsigned int v_var =
            system.add_variable("v",
                                Utility::string_to_enum&lt;Order&gt;   (approx_order),
                                Utility::string_to_enum&lt;FEFamily&gt;(fe_family));

          unsigned int w_var =
            system.add_variable("w",
                                Utility::string_to_enum&lt;Order&gt;   (approx_order),
                                Utility::string_to_enum&lt;FEFamily&gt;(fe_family));

</pre>
</div>
<div class = "comment">
Also, initialize an ExplicitSystem to store stresses
</div>

<div class ="fragment">
<pre>
          ExplicitSystem & stress_system =
            equation_systems.add_system&lt;ExplicitSystem&gt; ("StressSystem");
          stress_system.add_variable("sigma_00", CONSTANT, MONOMIAL);
          stress_system.add_variable("sigma_01", CONSTANT, MONOMIAL);
          stress_system.add_variable("sigma_02", CONSTANT, MONOMIAL);
          stress_system.add_variable("sigma_11", CONSTANT, MONOMIAL);
          stress_system.add_variable("sigma_12", CONSTANT, MONOMIAL);
          stress_system.add_variable("sigma_22", CONSTANT, MONOMIAL);

          equation_systems.parameters.set&lt;Real&gt;         ("nonlinear solver absolute residual tolerance") = nonlinear_abs_tol;
          equation_systems.parameters.set&lt;Real&gt;         ("nonlinear solver relative residual tolerance") = nonlinear_rel_tol;
          equation_systems.parameters.set&lt;unsigned int&gt; ("nonlinear solver maximum iterations")          = nonlinear_max_its;

          system.nonlinear_solver-&gt;residual_object = &lde;
          system.nonlinear_solver-&gt;jacobian_object = &lde;

          equation_systems.parameters.set&lt;Real&gt;("young_modulus") = young_modulus;
          equation_systems.parameters.set&lt;Real&gt;("poisson_ratio") = poisson_ratio;
          equation_systems.parameters.set&lt;Real&gt;("forcing_magnitude") = forcing_magnitude;

</pre>
</div>
<div class = "comment">
Attach Dirichlet boundary conditions
</div>

<div class ="fragment">
<pre>
          std::set&lt;boundary_id_type&gt; clamped_boundaries;
          clamped_boundaries.insert(BOUNDARY_ID_MIN_X);

          std::vector&lt;unsigned int&gt; uvw;
          uvw.push_back(u_var);
          uvw.push_back(v_var);
          uvw.push_back(w_var);

          ZeroFunction&lt;Number&gt; zero;

          system.get_dof_map().add_dirichlet_boundary(DirichletBoundary (clamped_boundaries, uvw, &zero));

          equation_systems.init();
          equation_systems.print_info();

</pre>
</div>
<div class = "comment">
Provide a loop here so that we can do a sequence of solves
where solve n gives a good starting guess for solve n+1.
This "continuation" approach is helpful for solving for
large values of "forcing_magnitude".
Set n_solves and force_scaling in nonlinear_elasticity.in.
</div>

<div class ="fragment">
<pre>
          for (unsigned int count=0; count&lt;n_solves; count++)
            {
              Real previous_forcing_magnitude = equation_systems.parameters.get&lt;Real&gt;("forcing_magnitude");
              equation_systems.parameters.set&lt;Real&gt;("forcing_magnitude") = previous_forcing_magnitude*force_scaling;

              libMesh::out &lt;&lt; "Performing solve "
                           &lt;&lt; count
                           &lt;&lt; ", forcing_magnitude: "
                           &lt;&lt; equation_systems.parameters.get&lt;Real&gt;("forcing_magnitude")
                           &lt;&lt; std::endl;

              system.solve();

              libMesh::out &lt;&lt; "System solved at nonlinear iteration "
                           &lt;&lt; system.n_nonlinear_iterations()
                           &lt;&lt; " , final nonlinear residual norm: "
                           &lt;&lt; system.final_nonlinear_residual()
                           &lt;&lt; std::endl
                           &lt;&lt; std::endl;

              libMesh::out &lt;&lt; "Computing stresses..." &lt;&lt; std::endl;

              lde.compute_stresses();

              std::stringstream filename;
              filename &lt;&lt; "solution_" &lt;&lt; count &lt;&lt; ".exo";
              ExodusII_IO (mesh).write_equation_systems(filename.str(), equation_systems);
            }

          return 0;
        }
</pre>
</div>

<a name="nocomments"></a>
<br><br><br> <h1> The source file systems_of_equations_ex7.C without comments: </h1>
<pre>
  #include &lt;iostream&gt;
  #include &lt;algorithm&gt;
  #include &lt;cmath&gt;

  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/libmesh.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/mesh.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/mesh_refinement.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/exodusII_io.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/equation_systems.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/fe.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/quadrature_gauss.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/dof_map.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/sparse_matrix.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/numeric_vector.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/dense_matrix.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/dense_vector.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/elem.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/string_to_enum.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/getpot.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/mesh_generation.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/dirichlet_boundaries.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/zero_function.h&quot;</FONT></B>

  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/nonlinear_solver.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/nonlinear_implicit_system.h&quot;</FONT></B>

  #define BOUNDARY_ID_MIN_Z 0
  #define BOUNDARY_ID_MIN_Y 1
  #define BOUNDARY_ID_MAX_X 2
  #define BOUNDARY_ID_MAX_Y 3
  #define BOUNDARY_ID_MIN_X 4
  #define BOUNDARY_ID_MAX_Z 5

  using namespace libMesh;



  <B><FONT COLOR="#228B22">class</FONT></B> LargeDeformationElasticity : <B><FONT COLOR="#228B22">public</FONT></B> NonlinearImplicitSystem::ComputeResidual,
                                     <B><FONT COLOR="#228B22">public</FONT></B> NonlinearImplicitSystem::ComputeJacobian
  {
  <B><FONT COLOR="#228B22">private</FONT></B>:
    EquationSystems &amp; es;

  <B><FONT COLOR="#228B22">public</FONT></B>:

    LargeDeformationElasticity (EquationSystems &amp; es_in) :
      es(es_in)
    {}

    <I><FONT COLOR="#B22222">/**
     * Kronecker delta function.
     */</FONT></I>
    Real kronecker_delta(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i,
                         <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j)
    {
      <B><FONT COLOR="#A020F0">return</FONT></B> i == j ? 1. : 0.;
    }

    <I><FONT COLOR="#B22222">/**
     * Evaluate the fourth order tensor (C_ijkl) that relates stress to strain.
     */</FONT></I>
    Real elasticity_tensor(Real young_modulus,
                           Real poisson_ratio,
                           <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i,
                           <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j,
                           <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> k,
                           <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> l)
    {
      <B><FONT COLOR="#228B22">const</FONT></B> Real lambda_1 = (young_modulus*poisson_ratio)/((1.+poisson_ratio)*(1.-2.*poisson_ratio));
      <B><FONT COLOR="#228B22">const</FONT></B> Real lambda_2 = young_modulus/(2.*(1.+poisson_ratio));

      <B><FONT COLOR="#A020F0">return</FONT></B> lambda_1 * kronecker_delta(i,j) * kronecker_delta(k,l) +
        lambda_2 * (kronecker_delta(i,k) * kronecker_delta(j,l) + kronecker_delta(i,l) * kronecker_delta(j,k));
    }


    <I><FONT COLOR="#B22222">/**
     * Evaluate the Jacobian of the nonlinear system.
     */</FONT></I>
    <B><FONT COLOR="#228B22">virtual</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> jacobian (<B><FONT COLOR="#228B22">const</FONT></B> NumericVector&lt;Number&gt; &amp; soln,
                           SparseMatrix&lt;Number&gt; &amp; jacobian,
                           NonlinearImplicitSystem &amp; <I><FONT COLOR="#B22222">/*sys*/</FONT></I>)
    {
      <B><FONT COLOR="#228B22">const</FONT></B> Real young_modulus = es.parameters.get&lt;Real&gt;(<B><FONT COLOR="#BC8F8F">&quot;young_modulus&quot;</FONT></B>);
      <B><FONT COLOR="#228B22">const</FONT></B> Real poisson_ratio = es.parameters.get&lt;Real&gt;(<B><FONT COLOR="#BC8F8F">&quot;poisson_ratio&quot;</FONT></B>);

      <B><FONT COLOR="#228B22">const</FONT></B> MeshBase &amp; mesh = es.get_mesh();
      <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dim = mesh.mesh_dimension();

      NonlinearImplicitSystem &amp; system =
        es.get_system&lt;NonlinearImplicitSystem&gt;(<B><FONT COLOR="#BC8F8F">&quot;NonlinearElasticity&quot;</FONT></B>);

      <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> u_var = system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;u&quot;</FONT></B>);

      <B><FONT COLOR="#228B22">const</FONT></B> DofMap &amp; dof_map = system.get_dof_map();

      FEType fe_type = dof_map.variable_type(u_var);
      UniquePtr&lt;FEBase&gt; fe (FEBase::build(dim, fe_type));
      QGauss qrule (dim, fe_type.default_quadrature_order());
      fe-&gt;attach_quadrature_rule (&amp;qrule);

      UniquePtr&lt;FEBase&gt; fe_face (FEBase::build(dim, fe_type));
      QGauss qface (dim-1, fe_type.default_quadrature_order());
      fe_face-&gt;attach_quadrature_rule (&amp;qface);

      <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;Real&gt; &amp; JxW = fe-&gt;get_JxW();
      <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;Real&gt; &gt; &amp; phi = fe-&gt;get_phi();
      <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;RealGradient&gt; &gt; &amp; dphi = fe-&gt;get_dphi();

      DenseMatrix&lt;Number&gt; Ke;
      DenseSubMatrix&lt;Number&gt; Ke_var[3][3] =
        {
          {DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke)},
          {DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke)},
          {DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke), DenseSubMatrix&lt;Number&gt;(Ke)}
        };

      <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;dof_id_type&gt; dof_indices;
      <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;std::vector&lt;dof_id_type&gt; &gt; dof_indices_var(3);

      jacobian.zero();

      <B><FONT COLOR="#5F9EA0">MeshBase</FONT></B>::const_element_iterator       el     = mesh.active_local_elements_begin();
      <B><FONT COLOR="#228B22">const</FONT></B> MeshBase::const_element_iterator end_el = mesh.active_local_elements_end();

      <B><FONT COLOR="#A020F0">for</FONT></B> ( ; el != end_el; ++el)
        {
          <B><FONT COLOR="#228B22">const</FONT></B> Elem * elem = *el;
          dof_map.dof_indices (elem, dof_indices);
          <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var=0; var&lt;3; var++)
            dof_map.dof_indices (elem, dof_indices_var[var], var);

          <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n_dofs = dof_indices.size();
          <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n_var_dofs = dof_indices_var[0].size();

          fe-&gt;reinit (elem);

          Ke.resize (n_dofs, n_dofs);
          <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var_i=0; var_i&lt;3; var_i++)
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var_j=0; var_j&lt;3; var_j++)
              Ke_var[var_i][var_j].reposition (var_i*n_var_dofs, var_j*n_var_dofs, n_var_dofs, n_var_dofs);

          <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> qp=0; qp&lt;qrule.n_points(); qp++)
            {
              DenseVector&lt;Number&gt; u_vec(3);
              DenseMatrix&lt;Number&gt; grad_u(3, 3);
              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var_i=0; var_i&lt;3; var_i++)
                {
                  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;n_var_dofs; j++)
                    u_vec(var_i) += phi[j][qp]*soln(dof_indices_var[var_i][j]);

                  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var_j=0; var_j&lt;3; var_j++)
                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;n_var_dofs; j++)
                      grad_u(var_i,var_j) += dphi[j][qp](var_j)*soln(dof_indices_var[var_i][j]);
                }

              DenseMatrix&lt;Number&gt; strain_tensor(3, 3);
              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;3; i++)
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;3; j++)
                  {
                    strain_tensor(i,j) += 0.5 * (grad_u(i,j) + grad_u(j,i));

                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> k=0; k&lt;3; k++)
                      strain_tensor(i,j) += 0.5 * grad_u(k,i)*grad_u(k,j);
                  }

              DenseMatrix&lt;Number&gt; F(3, 3);
              F = grad_u;
              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var=0; var&lt;3; var++)
                F(var, var) += 1.;

              DenseMatrix&lt;Number&gt; stress_tensor(3, 3);

              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;3; i++)
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;3; j++)
                  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> k=0; k&lt;3; k++)
                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> l=0; l&lt;3; l++)
                      stress_tensor(i,j) +=
                        elasticity_tensor(young_modulus, poisson_ratio, i, j, k, l) * strain_tensor(k, l);

              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dof_i=0; dof_i&lt;n_var_dofs; dof_i++)
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dof_j=0; dof_j&lt;n_var_dofs; dof_j++)
                  {
                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;3; i++)
                      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;3; j++)
                        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> m=0; m&lt;3; m++)
                          Ke_var[i][i](dof_i,dof_j) += JxW[qp] *
                            (-dphi[dof_j][qp](m) * stress_tensor(m,j) * dphi[dof_i][qp](j));

                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;3; i++)
                      <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;3; j++)
                        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> k=0; k&lt;3; k++)
                          <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> l=0; l&lt;3; l++)
                            {
                              Number FxC_ijkl = 0.;
                              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> m=0; m&lt;3; m++)
                                FxC_ijkl += F(i,m) * elasticity_tensor(young_modulus, poisson_ratio, m, j, k, l);

                              Ke_var[i][k](dof_i,dof_j) += JxW[qp] *
                                (-0.5 * FxC_ijkl * dphi[dof_j][qp](l) * dphi[dof_i][qp](j));

                              Ke_var[i][l](dof_i,dof_j) += JxW[qp] *
                                (-0.5 * FxC_ijkl * dphi[dof_j][qp](k) * dphi[dof_i][qp](j));

                              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n=0; n&lt;3; n++)
                                Ke_var[i][n](dof_i,dof_j) += JxW[qp] *
                                  (-0.5 * FxC_ijkl * (dphi[dof_j][qp](k) * grad_u(n,l) + dphi[dof_j][qp](l) * grad_u(n,k)) * dphi[dof_i][qp](j));
                            }
                  }
            }

          dof_map.constrain_element_matrix (Ke, dof_indices);
          jacobian.add_matrix (Ke, dof_indices);
        }
    }

    <I><FONT COLOR="#B22222">/**
     * Evaluate the residual of the nonlinear system.
     */</FONT></I>
    <B><FONT COLOR="#228B22">virtual</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> residual (<B><FONT COLOR="#228B22">const</FONT></B> NumericVector&lt;Number&gt; &amp; soln,
                           NumericVector&lt;Number&gt; &amp; residual,
                           NonlinearImplicitSystem &amp; <I><FONT COLOR="#B22222">/*sys*/</FONT></I>)
    {
      <B><FONT COLOR="#228B22">const</FONT></B> Real young_modulus = es.parameters.get&lt;Real&gt;(<B><FONT COLOR="#BC8F8F">&quot;young_modulus&quot;</FONT></B>);
      <B><FONT COLOR="#228B22">const</FONT></B> Real poisson_ratio = es.parameters.get&lt;Real&gt;(<B><FONT COLOR="#BC8F8F">&quot;poisson_ratio&quot;</FONT></B>);
      <B><FONT COLOR="#228B22">const</FONT></B> Real forcing_magnitude = es.parameters.get&lt;Real&gt;(<B><FONT COLOR="#BC8F8F">&quot;forcing_magnitude&quot;</FONT></B>);

      <B><FONT COLOR="#228B22">const</FONT></B> MeshBase &amp; mesh = es.get_mesh();
      <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dim = mesh.mesh_dimension();

      NonlinearImplicitSystem &amp; system =
        es.get_system&lt;NonlinearImplicitSystem&gt;(<B><FONT COLOR="#BC8F8F">&quot;NonlinearElasticity&quot;</FONT></B>);

      <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> u_var = system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;u&quot;</FONT></B>);

      <B><FONT COLOR="#228B22">const</FONT></B> DofMap &amp; dof_map = system.get_dof_map();

      FEType fe_type = dof_map.variable_type(u_var);
      UniquePtr&lt;FEBase&gt; fe (FEBase::build(dim, fe_type));
      QGauss qrule (dim, fe_type.default_quadrature_order());
      fe-&gt;attach_quadrature_rule (&amp;qrule);

      UniquePtr&lt;FEBase&gt; fe_face (FEBase::build(dim, fe_type));
      QGauss qface (dim-1, fe_type.default_quadrature_order());
      fe_face-&gt;attach_quadrature_rule (&amp;qface);

      <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;Real&gt; &amp; JxW = fe-&gt;get_JxW();
      <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;Real&gt; &gt; &amp; phi = fe-&gt;get_phi();
      <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;RealGradient&gt; &gt; &amp; dphi = fe-&gt;get_dphi();

      DenseVector&lt;Number&gt; Re;

      DenseSubVector&lt;Number&gt; Re_var[3] =
        {DenseSubVector&lt;Number&gt;(Re),
         DenseSubVector&lt;Number&gt;(Re),
         DenseSubVector&lt;Number&gt;(Re)};

      <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;dof_id_type&gt; dof_indices;
      <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt; std::vector&lt;dof_id_type&gt; &gt; dof_indices_var(3);

      residual.zero();

      <B><FONT COLOR="#5F9EA0">MeshBase</FONT></B>::const_element_iterator       el     = mesh.active_local_elements_begin();
      <B><FONT COLOR="#228B22">const</FONT></B> MeshBase::const_element_iterator end_el = mesh.active_local_elements_end();

      <B><FONT COLOR="#A020F0">for</FONT></B> ( ; el != end_el; ++el)
        {
          <B><FONT COLOR="#228B22">const</FONT></B> Elem * elem = *el;
          dof_map.dof_indices (elem, dof_indices);
          <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var=0; var&lt;3; var++)
            dof_map.dof_indices (elem, dof_indices_var[var], var);

          <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n_dofs = dof_indices.size();
          <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n_var_dofs = dof_indices_var[0].size();

          fe-&gt;reinit (elem);

          Re.resize (n_dofs);
          <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var=0; var&lt;3; var++)
            Re_var[var].reposition (var*n_var_dofs, n_var_dofs);

          <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> qp=0; qp&lt;qrule.n_points(); qp++)
            {
              DenseVector&lt;Number&gt; u_vec(3);
              DenseMatrix&lt;Number&gt; grad_u(3, 3);
              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var_i=0; var_i&lt;3; var_i++)
                {
                  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;n_var_dofs; j++)
                    u_vec(var_i) += phi[j][qp]*soln(dof_indices_var[var_i][j]);

                  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var_j=0; var_j&lt;3; var_j++)
                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;n_var_dofs; j++)
                      grad_u(var_i,var_j) += dphi[j][qp](var_j)*soln(dof_indices_var[var_i][j]);
                }

              DenseMatrix&lt;Number&gt; strain_tensor(3, 3);
              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;3; i++)
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;3; j++)
                  {
                    strain_tensor(i,j) += 0.5 * (grad_u(i,j) + grad_u(j,i));

                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> k=0; k&lt;3; k++)
                      strain_tensor(i,j) += 0.5 * grad_u(k,i)*grad_u(k,j);
                  }

              DenseMatrix&lt;Number&gt; F(3, 3);
              F = grad_u;
              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var=0; var&lt;3; var++)
                F(var, var) += 1.;

              DenseMatrix&lt;Number&gt; stress_tensor(3, 3);

              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;3; i++)
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;3; j++)
                  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> k=0; k&lt;3; k++)
                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> l=0; l&lt;3; l++)
                      stress_tensor(i,j) +=
                        elasticity_tensor(young_modulus, poisson_ratio, i, j, k, l) * strain_tensor(k,l);

              DenseVector&lt;Number&gt; f_vec(3);
              f_vec(0) = 0.;
              f_vec(1) = 0.;
              f_vec(2) = -forcing_magnitude;

              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dof_i=0; dof_i&lt;n_var_dofs; dof_i++)
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;3; i++)
                  {
                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;3; j++)
                      {
                        Number FxStress_ij = 0.;
                        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> m=0; m&lt;3; m++)
                          FxStress_ij += F(i,m) * stress_tensor(m,j);

                        Re_var[i](dof_i) += JxW[qp] * (-FxStress_ij * dphi[dof_i][qp](j));
                      }

                    Re_var[i](dof_i) += JxW[qp] * (f_vec(i) * phi[dof_i][qp]);
                  }
            }

          dof_map.constrain_element_vector (Re, dof_indices);
          residual.add_vector (Re, dof_indices);
        }
    }

    <I><FONT COLOR="#B22222">/**
     * Compute the Cauchy stress for the current solution.
     */</FONT></I>
    <B><FONT COLOR="#228B22">void</FONT></B> compute_stresses()
    {
      <B><FONT COLOR="#228B22">const</FONT></B> Real young_modulus = es.parameters.get&lt;Real&gt;(<B><FONT COLOR="#BC8F8F">&quot;young_modulus&quot;</FONT></B>);
      <B><FONT COLOR="#228B22">const</FONT></B> Real poisson_ratio = es.parameters.get&lt;Real&gt;(<B><FONT COLOR="#BC8F8F">&quot;poisson_ratio&quot;</FONT></B>);

      <B><FONT COLOR="#228B22">const</FONT></B> MeshBase &amp; mesh = es.get_mesh();
      <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dim = mesh.mesh_dimension();

      NonlinearImplicitSystem &amp; system =
        es.get_system&lt;NonlinearImplicitSystem&gt;(<B><FONT COLOR="#BC8F8F">&quot;NonlinearElasticity&quot;</FONT></B>);

      <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> displacement_vars[3];
      displacement_vars[0] = system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;u&quot;</FONT></B>);
      displacement_vars[1] = system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;v&quot;</FONT></B>);
      displacement_vars[2] = system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;w&quot;</FONT></B>);
      <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> u_var = system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;u&quot;</FONT></B>);

      <B><FONT COLOR="#228B22">const</FONT></B> DofMap &amp; dof_map = system.get_dof_map();
      FEType fe_type = dof_map.variable_type(u_var);
      UniquePtr&lt;FEBase&gt; fe (FEBase::build(dim, fe_type));
      QGauss qrule (dim, fe_type.default_quadrature_order());
      fe-&gt;attach_quadrature_rule (&amp;qrule);

      <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;Real&gt; &amp; JxW = fe-&gt;get_JxW();
      <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;RealGradient&gt; &gt; &amp; dphi = fe-&gt;get_dphi();

      ExplicitSystem &amp; stress_system = es.get_system&lt;ExplicitSystem&gt;(<B><FONT COLOR="#BC8F8F">&quot;StressSystem&quot;</FONT></B>);
      <B><FONT COLOR="#228B22">const</FONT></B> DofMap &amp; stress_dof_map = stress_system.get_dof_map();
      <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> sigma_vars[6];
      sigma_vars[0] = stress_system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;sigma_00&quot;</FONT></B>);
      sigma_vars[1] = stress_system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;sigma_01&quot;</FONT></B>);
      sigma_vars[2] = stress_system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;sigma_02&quot;</FONT></B>);
      sigma_vars[3] = stress_system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;sigma_11&quot;</FONT></B>);
      sigma_vars[4] = stress_system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;sigma_12&quot;</FONT></B>);
      sigma_vars[5] = stress_system.variable_number (<B><FONT COLOR="#BC8F8F">&quot;sigma_22&quot;</FONT></B>);

      <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt; std::vector&lt;dof_id_type&gt; &gt; dof_indices_var(system.n_vars());
      <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;dof_id_type&gt; stress_dof_indices_var;

      DenseMatrix&lt;Number&gt; elem_avg_stress_tensor(3, 3);

      <B><FONT COLOR="#5F9EA0">MeshBase</FONT></B>::const_element_iterator       el     = mesh.active_local_elements_begin();
      <B><FONT COLOR="#228B22">const</FONT></B> MeshBase::const_element_iterator end_el = mesh.active_local_elements_end();

      <B><FONT COLOR="#A020F0">for</FONT></B> ( ; el != end_el; ++el)
        {
          <B><FONT COLOR="#228B22">const</FONT></B> Elem * elem = *el;

          <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var=0; var&lt;3; var++)
            dof_map.dof_indices (elem, dof_indices_var[var], displacement_vars[var]);

          <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n_var_dofs = dof_indices_var[0].size();

          fe-&gt;reinit (elem);

          elem_avg_stress_tensor.resize(3, 3);

          <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> qp=0; qp&lt;qrule.n_points(); qp++)
            {
              DenseMatrix&lt;Number&gt; grad_u(3, 3);
              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var_i=0; var_i&lt;3; var_i++)
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var_j=0; var_j&lt;3; var_j++)
                  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;n_var_dofs; j++)
                    grad_u(var_i,var_j) += dphi[j][qp](var_j) * system.current_solution(dof_indices_var[var_i][j]);

              DenseMatrix&lt;Number&gt; strain_tensor(3, 3);
              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;3; i++)
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;3; j++)
                  {
                    strain_tensor(i,j) += 0.5 * (grad_u(i,j) + grad_u(j,i));

                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> k=0; k&lt;3; k++)
                      strain_tensor(i,j) += 0.5 * grad_u(k,i)*grad_u(k,j);
                  }

              DenseMatrix&lt;Number&gt; F(3, 3);
              F = grad_u;
              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> var=0; var&lt;3; var++)
                F(var, var) += 1.;

              DenseMatrix&lt;Number&gt; stress_tensor(3, 3);
              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;3; i++)
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j&lt;3; j++)
                  <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> k=0; k&lt;3; k++)
                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> l=0; l&lt;3; l++)
                      stress_tensor(i,j) +=
                        elasticity_tensor(young_modulus, poisson_ratio, i, j, k, l) * strain_tensor(k, l);

              stress_tensor.scale(1./F.det());
              stress_tensor.left_multiply(F);
              stress_tensor.right_multiply_transpose(F);

              elem_avg_stress_tensor.add(JxW[qp], stress_tensor);
            }

          elem_avg_stress_tensor.scale(1./elem-&gt;volume());

          <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> stress_var_index = 0;
          <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i&lt;3; i++)
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=i; j&lt;3; j++)
              {
                stress_dof_map.dof_indices (elem, stress_dof_indices_var, sigma_vars[stress_var_index]);

                dof_id_type dof_index = stress_dof_indices_var[0];

                <B><FONT COLOR="#A020F0">if</FONT></B> ((stress_system.solution-&gt;first_local_index() &lt;= dof_index) &amp;&amp;
                    (dof_index &lt; stress_system.solution-&gt;last_local_index()))
                  stress_system.solution-&gt;set(dof_index, elem_avg_stress_tensor(i,j));

                stress_var_index++;
              }
        }

      stress_system.solution-&gt;close();
      stress_system.update();
    }

  };


  <B><FONT COLOR="#228B22">int</FONT></B> main (<B><FONT COLOR="#228B22">int</FONT></B> argc, <B><FONT COLOR="#228B22">char</FONT></B> ** argv)
  {
    LibMeshInit init (argc, argv);

    libmesh_example_requires(libMesh::default_solver_package() == PETSC_SOLVERS, <B><FONT COLOR="#BC8F8F">&quot;--enable-petsc&quot;</FONT></B>);

    GetPot infile(<B><FONT COLOR="#BC8F8F">&quot;systems_of_equations_ex7.in&quot;</FONT></B>);
    <B><FONT COLOR="#228B22">const</FONT></B> Real x_length = infile(<B><FONT COLOR="#BC8F8F">&quot;x_length&quot;</FONT></B>, 0.);
    <B><FONT COLOR="#228B22">const</FONT></B> Real y_length = infile(<B><FONT COLOR="#BC8F8F">&quot;y_length&quot;</FONT></B>, 0.);
    <B><FONT COLOR="#228B22">const</FONT></B> Real z_length = infile(<B><FONT COLOR="#BC8F8F">&quot;z_length&quot;</FONT></B>, 0.);
    <B><FONT COLOR="#228B22">const</FONT></B> Real n_elem_x = infile(<B><FONT COLOR="#BC8F8F">&quot;n_elem_x&quot;</FONT></B>, 0);
    <B><FONT COLOR="#228B22">const</FONT></B> Real n_elem_y = infile(<B><FONT COLOR="#BC8F8F">&quot;n_elem_y&quot;</FONT></B>, 0);
    <B><FONT COLOR="#228B22">const</FONT></B> Real n_elem_z = infile(<B><FONT COLOR="#BC8F8F">&quot;n_elem_z&quot;</FONT></B>, 0);
    <B><FONT COLOR="#228B22">const</FONT></B> std::string approx_order = infile(<B><FONT COLOR="#BC8F8F">&quot;approx_order&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;FIRST&quot;</FONT></B>);
    <B><FONT COLOR="#228B22">const</FONT></B> std::string fe_family = infile(<B><FONT COLOR="#BC8F8F">&quot;fe_family&quot;</FONT></B>, <B><FONT COLOR="#BC8F8F">&quot;LAGRANGE&quot;</FONT></B>);

    <B><FONT COLOR="#228B22">const</FONT></B> Real young_modulus = infile(<B><FONT COLOR="#BC8F8F">&quot;Young_modulus&quot;</FONT></B>, 1.0);
    <B><FONT COLOR="#228B22">const</FONT></B> Real poisson_ratio = infile(<B><FONT COLOR="#BC8F8F">&quot;poisson_ratio&quot;</FONT></B>, 0.3);
    <B><FONT COLOR="#228B22">const</FONT></B> Real forcing_magnitude = infile(<B><FONT COLOR="#BC8F8F">&quot;forcing_magnitude&quot;</FONT></B>, 0.001);

    <B><FONT COLOR="#228B22">const</FONT></B> Real nonlinear_abs_tol = infile(<B><FONT COLOR="#BC8F8F">&quot;nonlinear_abs_tol&quot;</FONT></B>, 1.e-8);
    <B><FONT COLOR="#228B22">const</FONT></B> Real nonlinear_rel_tol = infile(<B><FONT COLOR="#BC8F8F">&quot;nonlinear_rel_tol&quot;</FONT></B>, 1.e-8);
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> nonlinear_max_its = infile(<B><FONT COLOR="#BC8F8F">&quot;nonlinear_max_its&quot;</FONT></B>, 50);

    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n_solves = infile(<B><FONT COLOR="#BC8F8F">&quot;n_solves&quot;</FONT></B>, 10);
    <B><FONT COLOR="#228B22">const</FONT></B> Real force_scaling = infile(<B><FONT COLOR="#BC8F8F">&quot;force_scaling&quot;</FONT></B>, 5.0);

    Mesh mesh(init.comm());

    <B><FONT COLOR="#5F9EA0">MeshTools</FONT></B>::Generation::build_cube(mesh,
                                      n_elem_x,
                                      n_elem_y,
                                      n_elem_z,
                                      0., x_length,
                                      0., y_length,
                                      0., z_length,
                                      HEX27);

    mesh.print_info();

    EquationSystems equation_systems (mesh);
    LargeDeformationElasticity lde(equation_systems);

    NonlinearImplicitSystem &amp; system =
      equation_systems.add_system&lt;NonlinearImplicitSystem&gt; (<B><FONT COLOR="#BC8F8F">&quot;NonlinearElasticity&quot;</FONT></B>);

    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> u_var =
      system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;u&quot;</FONT></B>,
                          <B><FONT COLOR="#5F9EA0">Utility</FONT></B>::string_to_enum&lt;Order&gt;   (approx_order),
                          <B><FONT COLOR="#5F9EA0">Utility</FONT></B>::string_to_enum&lt;FEFamily&gt;(fe_family));

    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> v_var =
      system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;v&quot;</FONT></B>,
                          <B><FONT COLOR="#5F9EA0">Utility</FONT></B>::string_to_enum&lt;Order&gt;   (approx_order),
                          <B><FONT COLOR="#5F9EA0">Utility</FONT></B>::string_to_enum&lt;FEFamily&gt;(fe_family));

    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> w_var =
      system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;w&quot;</FONT></B>,
                          <B><FONT COLOR="#5F9EA0">Utility</FONT></B>::string_to_enum&lt;Order&gt;   (approx_order),
                          <B><FONT COLOR="#5F9EA0">Utility</FONT></B>::string_to_enum&lt;FEFamily&gt;(fe_family));

    ExplicitSystem &amp; stress_system =
      equation_systems.add_system&lt;ExplicitSystem&gt; (<B><FONT COLOR="#BC8F8F">&quot;StressSystem&quot;</FONT></B>);
    stress_system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;sigma_00&quot;</FONT></B>, CONSTANT, MONOMIAL);
    stress_system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;sigma_01&quot;</FONT></B>, CONSTANT, MONOMIAL);
    stress_system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;sigma_02&quot;</FONT></B>, CONSTANT, MONOMIAL);
    stress_system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;sigma_11&quot;</FONT></B>, CONSTANT, MONOMIAL);
    stress_system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;sigma_12&quot;</FONT></B>, CONSTANT, MONOMIAL);
    stress_system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;sigma_22&quot;</FONT></B>, CONSTANT, MONOMIAL);

    equation_systems.parameters.set&lt;Real&gt;         (<B><FONT COLOR="#BC8F8F">&quot;nonlinear solver absolute residual tolerance&quot;</FONT></B>) = nonlinear_abs_tol;
    equation_systems.parameters.set&lt;Real&gt;         (<B><FONT COLOR="#BC8F8F">&quot;nonlinear solver relative residual tolerance&quot;</FONT></B>) = nonlinear_rel_tol;
    equation_systems.parameters.set&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; (<B><FONT COLOR="#BC8F8F">&quot;nonlinear solver maximum iterations&quot;</FONT></B>)          = nonlinear_max_its;

    system.nonlinear_solver-&gt;residual_object = &amp;lde;
    system.nonlinear_solver-&gt;jacobian_object = &amp;lde;

    equation_systems.parameters.set&lt;Real&gt;(<B><FONT COLOR="#BC8F8F">&quot;young_modulus&quot;</FONT></B>) = young_modulus;
    equation_systems.parameters.set&lt;Real&gt;(<B><FONT COLOR="#BC8F8F">&quot;poisson_ratio&quot;</FONT></B>) = poisson_ratio;
    equation_systems.parameters.set&lt;Real&gt;(<B><FONT COLOR="#BC8F8F">&quot;forcing_magnitude&quot;</FONT></B>) = forcing_magnitude;

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::set&lt;boundary_id_type&gt; clamped_boundaries;
    clamped_boundaries.insert(BOUNDARY_ID_MIN_X);

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; uvw;
    uvw.push_back(u_var);
    uvw.push_back(v_var);
    uvw.push_back(w_var);

    ZeroFunction&lt;Number&gt; zero;

    system.get_dof_map().add_dirichlet_boundary(DirichletBoundary (clamped_boundaries, uvw, &amp;zero));

    equation_systems.init();
    equation_systems.print_info();

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> count=0; count&lt;n_solves; count++)
      {
        Real previous_forcing_magnitude = equation_systems.parameters.get&lt;Real&gt;(<B><FONT COLOR="#BC8F8F">&quot;forcing_magnitude&quot;</FONT></B>);
        equation_systems.parameters.set&lt;Real&gt;(<B><FONT COLOR="#BC8F8F">&quot;forcing_magnitude&quot;</FONT></B>) = previous_forcing_magnitude*force_scaling;

        <B><FONT COLOR="#5F9EA0">libMesh</FONT></B>::out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Performing solve &quot;</FONT></B>
                     &lt;&lt; count
                     &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;, forcing_magnitude: &quot;</FONT></B>
                     &lt;&lt; equation_systems.parameters.get&lt;Real&gt;(<B><FONT COLOR="#BC8F8F">&quot;forcing_magnitude&quot;</FONT></B>)
                     &lt;&lt; std::endl;

        system.solve();

        <B><FONT COLOR="#5F9EA0">libMesh</FONT></B>::out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;System solved at nonlinear iteration &quot;</FONT></B>
                     &lt;&lt; system.n_nonlinear_iterations()
                     &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot; , final nonlinear residual norm: &quot;</FONT></B>
                     &lt;&lt; system.final_nonlinear_residual()
                     &lt;&lt; std::endl
                     &lt;&lt; std::endl;

        <B><FONT COLOR="#5F9EA0">libMesh</FONT></B>::out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;Computing stresses...&quot;</FONT></B> &lt;&lt; std::endl;

        lde.compute_stresses();

        <B><FONT COLOR="#5F9EA0">std</FONT></B>::stringstream filename;
        filename &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;solution_&quot;</FONT></B> &lt;&lt; count &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;.exo&quot;</FONT></B>;
        ExodusII_IO (mesh).write_equation_systems(filename.str(), equation_systems);
      }

    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  }
</pre>
<a name="output"></a>
<br><br><br> <h1> The console output of the program: </h1>
<pre>
***************************************************************
* Running Example systems_of_equations_ex7:
*   example-opt -ksp_type cg -pc_type bjacobi -snes_linesearch_type basic
***************************************************************

 Mesh Information:
  elem_dimensions()={3}
  spatial_dimension()=3
  n_nodes()=525
    n_local_nodes()=525
  n_elem()=40
    n_local_elem()=40
    n_active_elem()=40
  n_subdomains()=1
  n_partitions()=1
  n_processors()=1
  n_threads()=1
  processor_id()=0

 EquationSystems
  n_systems()=2
   System #0, "NonlinearElasticity"
    Type "NonlinearImplicit"
    Variables={ "u" "v" "w" }
    Finite Element Types="LAGRANGE", "JACOBI_20_00"
    Infinite Element Mapping="CARTESIAN"
    Approximation Orders="FIRST", "THIRD"
    n_dofs()=297
    n_local_dofs()=297
    n_constrained_dofs()=27
    n_local_constrained_dofs()=27
    n_vectors()=1
    n_matrices()=1
    DofMap Sparsity
      Average  On-Processor Bandwidth <= 46.0303
      Average Off-Processor Bandwidth <= 0
      Maximum  On-Processor Bandwidth <= 81
      Maximum Off-Processor Bandwidth <= 0
    DofMap Constraints
      Number of DoF Constraints = 27
      Average DoF Constraint Length= 0
   System #1, "StressSystem"
    Type "Explicit"
    Variables={ "sigma_00" "sigma_01" "sigma_02" "sigma_11" "sigma_12" "sigma_22" }
    Finite Element Types="MONOMIAL", "JACOBI_20_00"
    Infinite Element Mapping="CARTESIAN"
    Approximation Orders="CONSTANT", "THIRD"
    n_dofs()=240
    n_local_dofs()=240
    n_constrained_dofs()=0
    n_local_constrained_dofs()=0
    n_vectors()=1
    n_matrices()=0
    DofMap Sparsity
      Average  On-Processor Bandwidth <= 0
      Average Off-Processor Bandwidth <= 0
      Maximum  On-Processor Bandwidth <= 0
      Maximum Off-Processor Bandwidth <= 0
    DofMap Constraints
      Number of DoF Constraints = 0

Performing solve 0, forcing_magnitude: 0.001
  NL step  0, |residual|_2 = 1.140518e-06
  NL step  1, |residual|_2 = 4.284515e-04
  NL step  2, |residual|_2 = 4.701990e-06
  NL step  3, |residual|_2 = 1.256769e-09
  NL step  4, |residual|_2 = 8.494494e-13
System solved at nonlinear iteration 4 , final nonlinear residual norm: 8.494494e-13

Computing stresses...

 -------------------------------------------------------------------------------------------------------------------
| Time:           Tue Apr 12 15:02:12 2016                                                                          |
| OS:             Darwin                                                                                            |
| HostName:       peterson-laptop.local                                                                             |
| OS Release:     15.0.0                                                                                            |
| OS Version:     Darwin Kernel Version 15.0.0: Sat Sep 19 15:53:46 PDT 2015; root:xnu-3247.10.11~1/RELEASE_X86_64  |
| Machine:        x86_64                                                                                            |
| Username:       petejw                                                                                            |
| Configuration:  ../configure  'INSTALL=/usr/bin/install -C'                                                       |
|  '--with-methods=opt dbg'                                                                                         |
|  '--prefix=/Users/petejw/projects/libmesh_git/installed'                                                          |
|  '--enable-perflog'                                                                                               |
|  '--enable-tracefiles'                                                                                            |
|  '--disable-blocked-storage'                                                                                      |
|  '--enable-default-comm-world'                                                                                    |
|  '--enable-tecio'                                                                                                 |
|  '--enable-unique-ptr'                                                                                            |
|  '--enable-ifem'                                                                                                  |
|  'PETSC_DIR=/opt/moose/petsc/mpich_petsc-3.6.1/clang-opt-superlu'                                                 |
|  'SLEPC_DIR=/opt/petejw/slepc/3.6.1'                                                                              |
|  'CPPFLAGS= '                                                                                                     |
|  'LIBS= '                                                                                                         |
|  'CPPFLAGS=  '                                                                                                    |
|  'LIBS=  '                                                                                                        |
|  '--disable-netcdf-4'                                                                                             |
|  '--disable-testsets'                                                                                             |
|  'CXX=mpicxx'                                                                                                     |
|  'CC=mpicc'                                                                                                       |
|  'F77=mpif77'                                                                                                     |
|  'FC=mpif90'                                                                                                      |
|  'CPPFLAGS=   '                                                                                                   |
|  'LIBS=   '                                                                                                       |
 -------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------
| libMesh Performance: Alive time=0.427341, Active time=0.156139                                                  |
 -----------------------------------------------------------------------------------------------------------------
| Event                              nCalls     Total Time  Avg Time    Total Time  Avg Time    % of Active Time  |
|                                               w/o Sub     w/o Sub     With Sub    With Sub    w/o S    With S   |
|-----------------------------------------------------------------------------------------------------------------|
|                                                                                                                 |
|                                                                                                                 |
| DofMap                                                                                                          |
|   add_neighbors_to_send_list()     2          0.0002      0.000081    0.0002      0.000081    0.10     0.10     |
|   build_constraint_matrix()        360        0.0002      0.000001    0.0002      0.000001    0.13     0.13     |
|   build_sparsity()                 1          0.0006      0.000573    0.0006      0.000631    0.37     0.40     |
|   constrain_elem_matrix()          160        0.0002      0.000001    0.0002      0.000001    0.13     0.13     |
|   constrain_elem_vector()          200        0.0001      0.000000    0.0001      0.000000    0.04     0.04     |
|   create_dof_constraints()         2          0.0006      0.000294    0.0007      0.000343    0.38     0.44     |
|   distribute_dofs()                2          0.0002      0.000097    0.0009      0.000458    0.12     0.59     |
|   dof_indices()                    2320       0.0012      0.000001    0.0012      0.000001    0.75     0.75     |
|   enforce_constraints_exactly()    10         0.0001      0.000008    0.0001      0.000008    0.05     0.05     |
|   prepare_send_list()              4          0.0000      0.000000    0.0000      0.000000    0.00     0.00     |
|   reinit()                         2          0.0007      0.000360    0.0007      0.000360    0.46     0.46     |
|                                                                                                                 |
| EquationSystems                                                                                                 |
|   build_solution_vector()          1          0.0008      0.000811    0.0010      0.000983    0.52     0.63     |
|                                                                                                                 |
| ExodusII_IO                                                                                                     |
|   write_nodal_data()               1          0.0014      0.001432    0.0014      0.001432    0.92     0.92     |
|                                                                                                                 |
| FE                                                                                                              |
|   compute_shape_functions()        400        0.0008      0.000002    0.0008      0.000002    0.53     0.53     |
|   init_shape_functions()           10         0.0001      0.000011    0.0001      0.000011    0.07     0.07     |
|                                                                                                                 |
| FEMap                                                                                                           |
|   compute_affine_map()             400        0.0008      0.000002    0.0008      0.000002    0.49     0.49     |
|   init_reference_to_physical_map() 10         0.0006      0.000057    0.0006      0.000057    0.36     0.36     |
|                                                                                                                 |
| Mesh                                                                                                            |
|   find_neighbors()                 1          0.0003      0.000265    0.0003      0.000265    0.17     0.17     |
|   renumber_nodes_and_elem()        2          0.0000      0.000010    0.0000      0.000010    0.01     0.01     |
|                                                                                                                 |
| MeshOutput                                                                                                      |
|   write_equation_systems()         1          0.0000      0.000014    0.0024      0.002429    0.01     1.56     |
|                                                                                                                 |
| MeshTools::Generation                                                                                           |
|   build_cube()                     1          0.0002      0.000230    0.0002      0.000230    0.15     0.15     |
|                                                                                                                 |
| Parallel                                                                                                        |
|   allgather()                      2          0.0000      0.000000    0.0000      0.000000    0.00     0.00     |
|                                                                                                                 |
| Partitioner                                                                                                     |
|   single_partition()               1          0.0000      0.000026    0.0000      0.000026    0.02     0.02     |
|                                                                                                                 |
| PetscNonlinearSolver                                                                                            |
|   jacobian()                       4          0.1372      0.034302    0.1388      0.034711    87.88    88.92    |
|   residual()                       5          0.0038      0.000764    0.0058      0.001165    2.45     3.73     |
|   solve()                          1          0.0056      0.005622    0.1503      0.150331    3.60     96.28    |
|                                                                                                                 |
| System                                                                                                          |
|   solve()                          1          0.0005      0.000461    0.1508      0.150792    0.30     96.58    |
 -----------------------------------------------------------------------------------------------------------------
| Totals:                            3904       0.1561                                          100.00            |
 -----------------------------------------------------------------------------------------------------------------


***************************************************************
* Done Running Example systems_of_equations_ex7:
*   example-opt -ksp_type cg -pc_type bjacobi -snes_linesearch_type basic
***************************************************************
</pre>
</div>

<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){
  $(window).on('scroll',function() {
    var scrolltop = $(this).scrollTop();

    if(scrolltop >= 215) {
      $('#fixedbar').fadeIn(250);
    }

    else if(scrolltop <= 210) {
      $('#fixedbar').fadeOut(250);
    }
  });
});
</script>

<!-- Google Analytics stuff -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-24978333-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</body>
</html>
