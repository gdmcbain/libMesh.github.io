<!doctype html>
<html lang="en-US">
<head>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
  <title>libMesh - A C++ Finite Element Library</title>
  <meta name="author" content="libMesh development team">
  <link rel="stylesheet" type="text/css" media="all" href="../styles.css">
  <link rel="stylesheet" type="text/css" media="all" href="../doxygen_stylesheet.css">
</head>

<body>
  <nav id="fixedbar">
    <ul id="fixednav">
      <li><a href="../index.html">Home</a></li>
      <li><a href="../support.html">About Us</a></li>
      <li><a href="../publications.html">Publications</a></li>
      <li><a href="https://github.com/libMesh/libmesh/graphs/contributors">Developers</a></li>
      <li><a href="../installation.html">Installation</a></li>
      <li><a href="../examples.html">Examples</a></li>
     <li><a href="../doxygen/index.html">Documentation</a></li>
    </ul>
  </nav>

  <div id="w">
    <header id="logo"><a href="../index.html"><span id="logobg">SomeWebsiteLogo</span></a></header>

    <nav id="navigation">
      <ul>
        <li><a href="../index.html">Home</a></li>
        <li><a href="../support.html">About Us</a></li>
        <li><a href="../publications.html">Publications</a></li>
        <li><a href="https://github.com/libMesh/libmesh/graphs/contributors">Developers</a></li>
        <li><a href="../installation.html">Installation</a></li>
        <li><a href="../examples.html">Examples</a></li>
        <li><a href="../doxygen/index.html">Documentation</a></li>
      </ul>
    </nav>

<div id="content">

<a name="comments"></a>
<br><br><br> <h1> The source file elasticity_system.h with comments: </h1>
<div class = "comment">
</div>

<div class ="fragment">
<pre>
        #include "libmesh/fem_system.h"

</pre>
</div>
<div class = "comment">
boundary IDs
</div>

<div class ="fragment">
<pre>
        #define BOUNDARY_ID_MIN_Z 0
        #define BOUNDARY_ID_MIN_Y 1
        #define BOUNDARY_ID_MAX_X 2
        #define BOUNDARY_ID_MAX_Y 3
        #define BOUNDARY_ID_MIN_X 4
        #define BOUNDARY_ID_MAX_Z 5
        #define NODE_BOUNDARY_ID 10
        #define EDGE_BOUNDARY_ID 20

        using namespace libMesh;

</pre>
</div>
<div class = "comment">
The Navier-Stokes system class.
FEMSystem, TimeSolver and  NewtonSolver will handle most tasks,
but we must specify element residuals
</div>

<div class ="fragment">
<pre>
        class ElasticitySystem : public FEMSystem
        {
        public:
</pre>
</div>
<div class = "comment">
Constructor
</div>

<div class ="fragment">
<pre>
          ElasticitySystem(EquationSystems & es,
                           const std::string & name_in,
                           const unsigned int number_in)
            : FEMSystem(es, name_in, number_in),
              _rho(1.0)
          {}

</pre>
</div>
<div class = "comment">
System initialization
</div>

<div class ="fragment">
<pre>
          virtual void init_data ();

</pre>
</div>
<div class = "comment">
Context initialization
</div>

<div class ="fragment">
<pre>
          virtual void init_context(DiffContext & context);

</pre>
</div>
<div class = "comment">
Element residual and jacobian calculations
Time dependent parts
</div>

<div class ="fragment">
<pre>
          virtual bool element_time_derivative (bool request_jacobian,
                                                DiffContext & context);

          virtual bool side_time_derivative (bool request_jacobian,
                                             DiffContext & context);

</pre>
</div>
<div class = "comment">
Mass matrix part
</div>

<div class ="fragment">
<pre>
          virtual bool mass_residual (bool request_jacobian,
                                      DiffContext & context);

        private:

</pre>
</div>
<div class = "comment">
Indices for each variable;
</div>

<div class ="fragment">
<pre>
          unsigned int u_var, v_var, w_var;

          Real _rho;

          Real kronecker_delta(unsigned int i, unsigned int j)
          {
            return i == j ? 1. : 0.;
          }

          Real elasticity_tensor(unsigned int i, unsigned int j, unsigned int k, unsigned int l);
        };
</pre>
</div>

<a name="comments"></a>
<br><br><br> <h1> The source file elasticity_system.C with comments: </h1>
<div class = "comment">
</div>

<div class ="fragment">
<pre>
        #include "elasticity_system.h"

        #include "libmesh/dof_map.h"
        #include "libmesh/fe_base.h"
        #include "libmesh/fem_context.h"
        #include "libmesh/zero_function.h"
        #include "libmesh/dirichlet_boundaries.h"
        #include "libmesh/quadrature.h"

        using namespace libMesh;

        void ElasticitySystem::init_data()
        {
          u_var = this-&gt;add_variable ("u", FIRST, LAGRANGE);
          v_var = this-&gt;add_variable ("v", FIRST, LAGRANGE);
          w_var = this-&gt;add_variable ("w", FIRST, LAGRANGE);

          this-&gt;time_evolving(u_var);
          this-&gt;time_evolving(v_var);
          this-&gt;time_evolving(w_var);

          std::set&lt;boundary_id_type&gt; boundary_ids;
          boundary_ids.insert(BOUNDARY_ID_MIN_X);
          boundary_ids.insert(NODE_BOUNDARY_ID);
          boundary_ids.insert(EDGE_BOUNDARY_ID);

          std::vector&lt;unsigned int&gt; variables;
          variables.push_back(u_var);
          variables.push_back(v_var);
          variables.push_back(w_var);

          ZeroFunction&lt;&gt; zf;

          DirichletBoundary dirichlet_bc(boundary_ids,
                                         variables,
                                         &zf);

          this-&gt;get_dof_map().add_dirichlet_boundary(dirichlet_bc);

</pre>
</div>
<div class = "comment">
Do the parent's initialization after variables and boundary constraints are defined
</div>

<div class ="fragment">
<pre>
          FEMSystem::init_data();
        }

        void ElasticitySystem::init_context(DiffContext & context)
        {
          FEMContext & c = cast_ref&lt;FEMContext &&gt;(context);

          FEBase * u_elem_fe;
          FEBase * u_side_fe;

          c.get_element_fe(u_var, u_elem_fe);
          c.get_side_fe(u_var, u_side_fe);

</pre>
</div>
<div class = "comment">
We should prerequest all the data
we will need to build the residuals.
</div>

<div class ="fragment">
<pre>
          u_elem_fe-&gt;get_JxW();
          u_elem_fe-&gt;get_phi();
          u_elem_fe-&gt;get_dphi();

          u_side_fe-&gt;get_JxW();
          u_side_fe-&gt;get_phi();
        }

        bool ElasticitySystem::element_time_derivative(bool request_jacobian,
                                                       DiffContext & context)
        {
          FEMContext & c = cast_ref&lt;FEMContext &&gt;(context);

          FEBase * u_elem_fe;
          c.get_element_fe(u_var, u_elem_fe);

</pre>
</div>
<div class = "comment">
The number of local degrees of freedom in each variable
</div>

<div class ="fragment">
<pre>
          const unsigned int n_u_dofs = c.get_dof_indices(u_var).size();

</pre>
</div>
<div class = "comment">
Element Jacobian * quadrature weights for interior integration
</div>

<div class ="fragment">
<pre>
          const std::vector&lt;Real&gt; & JxW = u_elem_fe-&gt;get_JxW();

          const std::vector&lt;std::vector&lt;Real&gt; &gt; & phi = u_elem_fe-&gt;get_phi();
          const std::vector&lt;std::vector&lt;RealGradient&gt; &gt; & grad_phi = u_elem_fe-&gt;get_dphi();

          DenseSubVector&lt;Number&gt; & Fu = c.get_elem_residual(u_var);
          DenseSubVector&lt;Number&gt; & Fv = c.get_elem_residual(v_var);
          DenseSubVector&lt;Number&gt; & Fw = c.get_elem_residual(w_var);

          DenseSubMatrix&lt;Number&gt; & Kuu = c.get_elem_jacobian(u_var, u_var);
          DenseSubMatrix&lt;Number&gt; & Kvv = c.get_elem_jacobian(v_var, v_var);
          DenseSubMatrix&lt;Number&gt; & Kww = c.get_elem_jacobian(w_var, w_var);
          DenseSubMatrix&lt;Number&gt; & Kuv = c.get_elem_jacobian(u_var, v_var);
          DenseSubMatrix&lt;Number&gt; & Kuw = c.get_elem_jacobian(u_var, w_var);
          DenseSubMatrix&lt;Number&gt; & Kvu = c.get_elem_jacobian(v_var, u_var);
          DenseSubMatrix&lt;Number&gt; & Kvw = c.get_elem_jacobian(v_var, w_var);
          DenseSubMatrix&lt;Number&gt; & Kwu = c.get_elem_jacobian(w_var, u_var);
          DenseSubMatrix&lt;Number&gt; & Kwv = c.get_elem_jacobian(w_var, v_var);

          unsigned int n_qpoints = c.get_element_qrule().n_points();

          Gradient body_force(0.0, 0.0, -1.0);

          for (unsigned int qp=0; qp != n_qpoints; qp++)
            {
              Gradient grad_u, grad_v, grad_w;
              c.interior_gradient(u_var, qp, grad_u);
              c.interior_gradient(v_var, qp, grad_v);
              c.interior_gradient(w_var, qp, grad_w);

</pre>
</div>
<div class = "comment">
Convenience
</div>

<div class ="fragment">
<pre>
              Tensor grad_U (grad_u, grad_v, grad_w);

              Tensor tau;
              for (unsigned int i = 0; i &lt; 3; i++)
                for (unsigned int j = 0; j &lt; 3; j++)
                  for (unsigned int k = 0; k &lt; 3; k++)
                    for (unsigned int l = 0; l &lt; 3; l++)
                      tau(i,j) += elasticity_tensor(i,j,k,l)*grad_U(k,l);

              for (unsigned int i=0; i != n_u_dofs; i++)
                {
                  for (unsigned int alpha = 0; alpha &lt; 3; alpha++)
                    {
                      Fu(i) += (tau(0,alpha)*grad_phi[i][qp](alpha) - body_force(0)*phi[i][qp])*JxW[qp];
                      Fv(i) += (tau(1,alpha)*grad_phi[i][qp](alpha) - body_force(1)*phi[i][qp])*JxW[qp];
                      Fw(i) += (tau(2,alpha)*grad_phi[i][qp](alpha) - body_force(2)*phi[i][qp])*JxW[qp];

                      if (request_jacobian)
                        {
                          for (unsigned int j=0; j != n_u_dofs; j++)
                            {
                              for (unsigned int beta = 0; beta &lt; 3; beta++)
                                {
</pre>
</div>
<div class = "comment">
Convenience
</div>

<div class ="fragment">
<pre>
                                  const Real c0 = grad_phi[j][qp](beta)*c.get_elem_solution_derivative();

                                  Real dtau_uu = elasticity_tensor(0, alpha, 0, beta)*c0;
                                  Real dtau_uv = elasticity_tensor(0, alpha, 1, beta)*c0;
                                  Real dtau_uw = elasticity_tensor(0, alpha, 2, beta)*c0;
                                  Real dtau_vu = elasticity_tensor(1, alpha, 0, beta)*c0;
                                  Real dtau_vv = elasticity_tensor(1, alpha, 1, beta)*c0;
                                  Real dtau_vw = elasticity_tensor(1, alpha, 2, beta)*c0;
                                  Real dtau_wu = elasticity_tensor(2, alpha, 0, beta)*c0;
                                  Real dtau_wv = elasticity_tensor(2, alpha, 1, beta)*c0;
                                  Real dtau_ww = elasticity_tensor(2, alpha, 2, beta)*c0;

                                  Kuu(i,j) += dtau_uu*grad_phi[i][qp](alpha)*JxW[qp];
                                  Kuv(i,j) += dtau_uv*grad_phi[i][qp](alpha)*JxW[qp];
                                  Kuw(i,j) += dtau_uw*grad_phi[i][qp](alpha)*JxW[qp];
                                  Kvu(i,j) += dtau_vu*grad_phi[i][qp](alpha)*JxW[qp];
                                  Kvv(i,j) += dtau_vv*grad_phi[i][qp](alpha)*JxW[qp];
                                  Kvw(i,j) += dtau_vw*grad_phi[i][qp](alpha)*JxW[qp];
                                  Kwu(i,j) += dtau_wu*grad_phi[i][qp](alpha)*JxW[qp];
                                  Kwv(i,j) += dtau_wv*grad_phi[i][qp](alpha)*JxW[qp];
                                  Kww(i,j) += dtau_ww*grad_phi[i][qp](alpha)*JxW[qp];
                                }
                            }
                        }
                    }
                }

            } // qp loop

</pre>
</div>
<div class = "comment">
If the Jacobian was requested, we computed it. Otherwise, we didn't.
</div>

<div class ="fragment">
<pre>
          return request_jacobian;
        }

        bool ElasticitySystem::side_time_derivative (bool request_jacobian,
                                                     DiffContext & context)
        {
          FEMContext & c = cast_ref&lt;FEMContext &&gt;(context);

</pre>
</div>
<div class = "comment">
If we're on the correct side, apply the traction
</div>

<div class ="fragment">
<pre>
          if (c.has_side_boundary_id(BOUNDARY_ID_MAX_X))
            {
              FEBase * u_side_fe;
              c.get_side_fe(u_var, u_side_fe);

</pre>
</div>
<div class = "comment">
The number of local degrees of freedom in each variable
</div>

<div class ="fragment">
<pre>
              const unsigned int n_u_dofs = c.get_dof_indices(u_var).size();

              DenseSubVector&lt;Number&gt; & Fu = c.get_elem_residual(u_var);
              DenseSubVector&lt;Number&gt; & Fv = c.get_elem_residual(v_var);
              DenseSubVector&lt;Number&gt; & Fw = c.get_elem_residual(w_var);

</pre>
</div>
<div class = "comment">
Element Jacobian * quadrature weights for interior integration
</div>

<div class ="fragment">
<pre>
              const std::vector&lt;Real&gt; & JxW = u_side_fe-&gt;get_JxW();

              const std::vector&lt;std::vector&lt;Real&gt; &gt; & phi = u_side_fe-&gt;get_phi();

              unsigned int n_qpoints = c.get_side_qrule().n_points();

              Gradient traction(0.0, 0.0, -1.0);

              for (unsigned int qp=0; qp != n_qpoints; qp++)
                {
                  for (unsigned int i=0; i != n_u_dofs; i++)
                    {
                      Fu(i) -= traction(0)*phi[i][qp]*JxW[qp];
                      Fv(i) -= traction(1)*phi[i][qp]*JxW[qp];
                      Fw(i) -= traction(2)*phi[i][qp]*JxW[qp];
                    }
                }
            }

</pre>
</div>
<div class = "comment">
If the Jacobian was requested, we computed it (in this case it's zero).
Otherwise, we didn't.
</div>

<div class ="fragment">
<pre>
          return request_jacobian;
        }

        bool ElasticitySystem::mass_residual(bool request_jacobian,
                                             DiffContext & context)
        {
          FEMContext & c = cast_ref&lt;FEMContext &&gt;(context);

          FEBase * u_elem_fe;
          c.get_element_fe(u_var, u_elem_fe);

</pre>
</div>
<div class = "comment">
The number of local degrees of freedom in each variable
</div>

<div class ="fragment">
<pre>
          const unsigned int n_u_dofs = c.get_dof_indices(u_var).size();

</pre>
</div>
<div class = "comment">
Element Jacobian * quadrature weights for interior integration
</div>

<div class ="fragment">
<pre>
          const std::vector&lt;Real&gt; & JxW = u_elem_fe-&gt;get_JxW();

          const std::vector&lt;std::vector&lt;Real&gt; &gt; & phi = u_elem_fe-&gt;get_phi();

</pre>
</div>
<div class = "comment">
Residuals that we're populating
</div>

<div class ="fragment">
<pre>
          libMesh::DenseSubVector&lt;libMesh::Number&gt; & Fu = c.get_elem_residual(u_var);
          libMesh::DenseSubVector&lt;libMesh::Number&gt; & Fv = c.get_elem_residual(v_var);
          libMesh::DenseSubVector&lt;libMesh::Number&gt; & Fw = c.get_elem_residual(w_var);

          libMesh::DenseSubMatrix&lt;libMesh::Number&gt; & Kuu = c.get_elem_jacobian(u_var, u_var);
          libMesh::DenseSubMatrix&lt;libMesh::Number&gt; & Kvv = c.get_elem_jacobian(v_var, v_var);
          libMesh::DenseSubMatrix&lt;libMesh::Number&gt; & Kww = c.get_elem_jacobian(w_var, w_var);

          unsigned int n_qpoints = c.get_element_qrule().n_points();

          for (unsigned int qp=0; qp != n_qpoints; qp++)
            {
              libMesh::Number u_ddot, v_ddot, w_ddot;
              c.interior_accel(u_var, qp, u_ddot);
              c.interior_accel(v_var, qp, v_ddot);
              c.interior_accel(w_var, qp, w_ddot);

              for (unsigned int i=0; i != n_u_dofs; i++)
                {
                  Fu(i) += _rho*u_ddot*phi[i][qp]*JxW[qp];
                  Fv(i) += _rho*v_ddot*phi[i][qp]*JxW[qp];
                  Fw(i) += _rho*w_ddot*phi[i][qp]*JxW[qp];

                  if (request_jacobian)
                    {
                      for (unsigned int j=0; j != n_u_dofs; j++)
                        {
                          libMesh::Real jac_term = _rho*phi[i][qp]*phi[j][qp]*JxW[qp];
                          jac_term *= context.get_elem_solution_accel_derivative();

                          Kuu(i,j) += jac_term;
                          Kvv(i,j) += jac_term;
                          Kww(i,j) += jac_term;
                        }
                    }
                }
            }

</pre>
</div>
<div class = "comment">
If the Jacobian was requested, we computed it. Otherwise, we didn't.
</div>

<div class ="fragment">
<pre>
          return request_jacobian;
        }

        Real ElasticitySystem::elasticity_tensor(unsigned int i, unsigned int j, unsigned int k, unsigned int l)
        {
</pre>
</div>
<div class = "comment">
Hard code material parameters for the sake of simplicity
</div>

<div class ="fragment">
<pre>
          const Real poisson_ratio = 0.3;
          const Real young_modulus = 1.0e2;

</pre>
</div>
<div class = "comment">
Define the Lame constants
</div>

<div class ="fragment">
<pre>
          const Real lambda_1 = (young_modulus*poisson_ratio)/((1.+poisson_ratio)*(1.-2.*poisson_ratio));
          const Real lambda_2 = young_modulus/(2.*(1.+poisson_ratio));

          return
            lambda_1 * kronecker_delta(i, j) * kronecker_delta(k, l) +
            lambda_2 * (kronecker_delta(i, k) * kronecker_delta(j, l) + kronecker_delta(i, l) * kronecker_delta(j, k));
        }
</pre>
</div>

<a name="comments"></a>
<br><br><br> <h1> The source file fem_system_ex3.C with comments: </h1>
<div class = "comment">
</div>

<div class ="fragment">
<pre>
        #include &lt;iomanip&gt;

</pre>
</div>
<div class = "comment">
Basic include files
</div>

<div class ="fragment">
<pre>
        #include "libmesh/equation_systems.h"
        #include "libmesh/error_vector.h"
        #include "libmesh/getpot.h"
        #include "libmesh/exodusII_io.h"
        #include "libmesh/kelly_error_estimator.h"
        #include "libmesh/mesh.h"
        #include "libmesh/mesh_generation.h"

</pre>
</div>
<div class = "comment">
The systems and solvers we may use
</div>

<div class ="fragment">
<pre>
        #include "elasticity_system.h"
        #include "libmesh/diff_solver.h"
        #include "libmesh/newmark_solver.h"
        #include "libmesh/steady_solver.h"
        #include "libmesh/elem.h"

        #define x_scaling 1.3

</pre>
</div>
<div class = "comment">
Bring in everything from the libMesh namespace
</div>

<div class ="fragment">
<pre>
        using namespace libMesh;

</pre>
</div>
<div class = "comment">
The main program.
</div>

<div class ="fragment">
<pre>
        int main (int argc, char ** argv)
        {
</pre>
</div>
<div class = "comment">
Initialize libMesh.
</div>

<div class ="fragment">
<pre>
          LibMeshInit init (argc, argv);

</pre>
</div>
<div class = "comment">
Parse the input file
</div>

<div class ="fragment">
<pre>
          GetPot infile("fem_system_ex3.in");

</pre>
</div>
<div class = "comment">
Read in parameters from the input file
</div>

<div class ="fragment">
<pre>
          const bool transient        = infile("transient", true);
          const Real deltat           = infile("deltat", 0.25);
          unsigned int n_timesteps    = infile("n_timesteps", 25);

        #ifdef LIBMESH_HAVE_EXODUS_API
          const unsigned int write_interval    = infile("write_interval", 1);
        #endif

</pre>
</div>
<div class = "comment">
Initialize the cantilever mesh
</div>

<div class ="fragment">
<pre>
          const unsigned int dim = 3;

</pre>
</div>
<div class = "comment">
Make sure libMesh was compiled for 3D
</div>

<div class ="fragment">
<pre>
          libmesh_example_requires(dim == LIBMESH_DIM, "3D support");

</pre>
</div>
<div class = "comment">
Create a 3D mesh distributed across the default MPI communicator.
</div>

<div class ="fragment">
<pre>
          Mesh mesh(init.comm(), dim);
          MeshTools::Generation::build_cube (mesh,
                                             40,
                                             10,
                                             5,
                                             0., 1.*x_scaling,
                                             0., 0.3,
                                             0., 0.1,
                                             HEX8);


</pre>
</div>
<div class = "comment">
Print information about the mesh to the screen.
</div>

<div class ="fragment">
<pre>
          mesh.print_info();

</pre>
</div>
<div class = "comment">
Let's add some node and edge boundary conditions
</div>

<div class ="fragment">
<pre>
          MeshBase::const_element_iterator       el     = mesh.active_local_elements_begin();
          const MeshBase::const_element_iterator end_el = mesh.active_local_elements_end();
          for ( ; el != end_el; ++el)
            {
              const Elem * elem = *el;

              unsigned int
                side_max_x = 0, side_min_y = 0,
                side_max_y = 0, side_max_z = 0;
              bool
                found_side_max_x = false, found_side_max_y = false,
                found_side_min_y = false, found_side_max_z = false;
              for (unsigned int side=0; side&lt;elem-&gt;n_sides(); side++)
                {
                  if (mesh.get_boundary_info().has_boundary_id(elem, side, BOUNDARY_ID_MAX_X))
                    {
                      side_max_x = side;
                      found_side_max_x = true;
                    }

                  if (mesh.get_boundary_info().has_boundary_id(elem, side, BOUNDARY_ID_MIN_Y))
                    {
                      side_min_y = side;
                      found_side_min_y = true;
                    }

                  if (mesh.get_boundary_info().has_boundary_id(elem, side, BOUNDARY_ID_MAX_Y))
                    {
                      side_max_y = side;
                      found_side_max_y = true;
                    }

                  if (mesh.get_boundary_info().has_boundary_id(elem, side, BOUNDARY_ID_MAX_Z))
                    {
                      side_max_z = side;
                      found_side_max_z = true;
                    }
                }

</pre>
</div>
<div class = "comment">
If elem has sides on boundaries
BOUNDARY_ID_MAX_X, BOUNDARY_ID_MAX_Y, BOUNDARY_ID_MAX_Z
then let's set a node boundary condition
</div>

<div class ="fragment">
<pre>
              if (found_side_max_x && found_side_max_y && found_side_max_z)
                for (unsigned int n=0; n&lt;elem-&gt;n_nodes(); n++)
                  if (elem-&gt;is_node_on_side(n, side_max_x) &&
                      elem-&gt;is_node_on_side(n, side_max_y) &&
                      elem-&gt;is_node_on_side(n, side_max_z))
                    mesh.get_boundary_info().add_node(elem-&gt;get_node(n), NODE_BOUNDARY_ID);

</pre>
</div>
<div class = "comment">
If elem has sides on boundaries
BOUNDARY_ID_MAX_X and BOUNDARY_ID_MIN_Y
then let's set an edge boundary condition
</div>

<div class ="fragment">
<pre>
              if (found_side_max_x && found_side_min_y)
                for (unsigned int e=0; e&lt;elem-&gt;n_edges(); e++)
                  if (elem-&gt;is_edge_on_side(e, side_max_x) &&
                      elem-&gt;is_edge_on_side(e, side_min_y))
                    mesh.get_boundary_info().add_edge(elem, e, EDGE_BOUNDARY_ID);
            }

</pre>
</div>
<div class = "comment">
Create an equation systems object.
</div>

<div class ="fragment">
<pre>
          EquationSystems equation_systems (mesh);

</pre>
</div>
<div class = "comment">
Declare the system "Navier-Stokes" and its variables.
</div>

<div class ="fragment">
<pre>
          ElasticitySystem & system =
            equation_systems.add_system&lt;ElasticitySystem&gt; ("Linear Elasticity");

</pre>
</div>
<div class = "comment">
Create ExplicitSystem to help output velocity
</div>

<div class ="fragment">
<pre>
          ExplicitSystem & v_system =
            equation_systems.add_system&lt;ExplicitSystem&gt; ("Velocity");
          v_system.add_variable("u_vel", FIRST, LAGRANGE);
          v_system.add_variable("v_vel", FIRST, LAGRANGE);
          v_system.add_variable("w_vel", FIRST, LAGRANGE);

</pre>
</div>
<div class = "comment">
Create ExplicitSystem to help output acceleration
</div>

<div class ="fragment">
<pre>
          ExplicitSystem & a_system =
            equation_systems.add_system&lt;ExplicitSystem&gt; ("Acceleration");
          a_system.add_variable("u_accel", FIRST, LAGRANGE);
          a_system.add_variable("v_accel", FIRST, LAGRANGE);
          a_system.add_variable("w_accel", FIRST, LAGRANGE);

</pre>
</div>
<div class = "comment">
Solve this as a time-dependent or steady system
</div>

<div class ="fragment">
<pre>
          if (transient)
            system.time_solver =
              UniquePtr&lt;NewmarkSolver&gt;(new NewmarkSolver(system));
          else
            {
              system.time_solver =
                UniquePtr&lt;TimeSolver&gt;(new SteadySolver(system));
              libmesh_assert_equal_to (n_timesteps, 1);
            }

</pre>
</div>
<div class = "comment">
Initialize the system
</div>

<div class ="fragment">
<pre>
          equation_systems.init ();

</pre>
</div>
<div class = "comment">
Set the time stepping options
</div>

<div class ="fragment">
<pre>
          system.deltat = deltat;

</pre>
</div>
<div class = "comment">
And the nonlinear solver options
</div>

<div class ="fragment">
<pre>
          DiffSolver & solver = *(system.time_solver-&gt;diff_solver().get());
          solver.quiet = infile("solver_quiet", true);
          solver.verbose = !solver.quiet;
          solver.max_nonlinear_iterations = infile("max_nonlinear_iterations", 15);
          solver.relative_step_tolerance = infile("relative_step_tolerance", 1.e-3);
          solver.relative_residual_tolerance = infile("relative_residual_tolerance", 0.0);
          solver.absolute_residual_tolerance = infile("absolute_residual_tolerance", 0.0);

</pre>
</div>
<div class = "comment">
And the linear solver options
</div>

<div class ="fragment">
<pre>
          solver.max_linear_iterations = infile("max_linear_iterations", 50000);
          solver.initial_linear_tolerance = infile("initial_linear_tolerance", 1.e-3);

</pre>
</div>
<div class = "comment">
Print information about the system to the screen.
</div>

<div class ="fragment">
<pre>
          equation_systems.print_info();

          NewmarkSolver * newmark = cast_ptr&lt;NewmarkSolver*&gt;(system.time_solver.get());
          newmark-&gt;compute_initial_accel();

</pre>
</div>
<div class = "comment">
Copy over initial velocity and acceleration for output.
Note we can do this because of the matching variables/FE spaces
</div>

<div class ="fragment">
<pre>
          (*v_system.solution) = system.get_vector("_old_solution_rate");
          (*a_system.solution) = system.get_vector("_old_solution_accel");

        #ifdef LIBMESH_HAVE_EXODUS_API
</pre>
</div>
<div class = "comment">
Output initial state
</div>

<div class ="fragment">
<pre>
          {
            std::ostringstream file_name;

</pre>
</div>
<div class = "comment">
We write the file in the ExodusII format.
</div>

<div class ="fragment">
<pre>
            file_name &lt;&lt; "out.e-s."
                      &lt;&lt; std::setw(3)
                      &lt;&lt; std::setfill('0')
                      &lt;&lt; std::right
                      &lt;&lt; 0;

            ExodusII_IO(mesh).write_timestep(file_name.str(),
                                             equation_systems,
                                             1, // This number indicates how many time steps
</pre>
</div>
<div class = "comment">
are being written to the file
</div>

<div class ="fragment">
<pre>
                                             system.time);
          }
        #endif // #ifdef LIBMESH_HAVE_EXODUS_API

</pre>
</div>
<div class = "comment">
Now we begin the timestep loop to compute the time-accurate
solution of the equations.
</div>

<div class ="fragment">
<pre>
          for (unsigned int t_step=0; t_step != n_timesteps; ++t_step)
            {
</pre>
</div>
<div class = "comment">
A pretty update message
</div>

<div class ="fragment">
<pre>
              libMesh::out &lt;&lt; "\n\nSolving time step "
                           &lt;&lt; t_step
                           &lt;&lt; ", time = "
                           &lt;&lt; system.time
                           &lt;&lt; std::endl;

              system.solve();

</pre>
</div>
<div class = "comment">
Advance to the next timestep in a transient problem
</div>

<div class ="fragment">
<pre>
              system.time_solver-&gt;advance_timestep();

</pre>
</div>
<div class = "comment">
Copy over updated velocity and acceleration for output.
Note we can do this because of the matching variables/FE spaces
</div>

<div class ="fragment">
<pre>
              (*v_system.solution) = system.get_vector("_old_solution_rate");
              (*a_system.solution) = system.get_vector("_old_solution_accel");

        #ifdef LIBMESH_HAVE_EXODUS_API
</pre>
</div>
<div class = "comment">
Write out this timestep if we're requested to
</div>

<div class ="fragment">
<pre>
              if ((t_step+1)%write_interval == 0)
                {
                  std::ostringstream file_name;

</pre>
</div>
<div class = "comment">
We write the file in the ExodusII format.
</div>

<div class ="fragment">
<pre>
                  file_name &lt;&lt; "out.e-s."
                            &lt;&lt; std::setw(3)
                            &lt;&lt; std::setfill('0')
                            &lt;&lt; std::right
                            &lt;&lt; t_step+1;

                  ExodusII_IO(mesh).write_timestep(file_name.str(),
                                                   equation_systems,
                                                   1, // This number indicates how many time steps
</pre>
</div>
<div class = "comment">
are being written to the file
</div>

<div class ="fragment">
<pre>
                                                   system.time);
                }
        #endif // #ifdef LIBMESH_HAVE_EXODUS_API
            }

</pre>
</div>
<div class = "comment">
All done.
</div>

<div class ="fragment">
<pre>
          return 0;
        }
</pre>
</div>

<a name="nocomments"></a>
<br><br><br> <h1> The source file elasticity_system.h without comments: </h1>
<pre>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/fem_system.h&quot;</FONT></B>

  #define BOUNDARY_ID_MIN_Z 0
  #define BOUNDARY_ID_MIN_Y 1
  #define BOUNDARY_ID_MAX_X 2
  #define BOUNDARY_ID_MAX_Y 3
  #define BOUNDARY_ID_MIN_X 4
  #define BOUNDARY_ID_MAX_Z 5
  #define NODE_BOUNDARY_ID 10
  #define EDGE_BOUNDARY_ID 20

  using namespace libMesh;

  <B><FONT COLOR="#228B22">class</FONT></B> ElasticitySystem : <B><FONT COLOR="#228B22">public</FONT></B> FEMSystem
  {
  <B><FONT COLOR="#228B22">public</FONT></B>:
    ElasticitySystem(EquationSystems &amp; es,
                     <B><FONT COLOR="#228B22">const</FONT></B> std::string &amp; name_in,
                     <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> number_in)
      : FEMSystem(es, name_in, number_in),
        _rho(1.0)
    {}

    <B><FONT COLOR="#228B22">virtual</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> init_data ();

    <B><FONT COLOR="#228B22">virtual</FONT></B> <B><FONT COLOR="#228B22">void</FONT></B> init_context(DiffContext &amp; context);

    <B><FONT COLOR="#228B22">virtual</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> element_time_derivative (<B><FONT COLOR="#228B22">bool</FONT></B> request_jacobian,
                                          DiffContext &amp; context);

    <B><FONT COLOR="#228B22">virtual</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> side_time_derivative (<B><FONT COLOR="#228B22">bool</FONT></B> request_jacobian,
                                       DiffContext &amp; context);

    <B><FONT COLOR="#228B22">virtual</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> mass_residual (<B><FONT COLOR="#228B22">bool</FONT></B> request_jacobian,
                                DiffContext &amp; context);

  <B><FONT COLOR="#228B22">private</FONT></B>:

    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> u_var, v_var, w_var;

    Real _rho;

    Real kronecker_delta(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i, <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j)
    {
      <B><FONT COLOR="#A020F0">return</FONT></B> i == j ? 1. : 0.;
    }

    Real elasticity_tensor(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i, <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j, <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> k, <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> l);
  };
</pre>
<a name="nocomments"></a>
<br><br><br> <h1> The source file elasticity_system.C without comments: </h1>
<pre>
  #include <B><FONT COLOR="#BC8F8F">&quot;elasticity_system.h&quot;</FONT></B>

  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/dof_map.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/fe_base.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/fem_context.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/zero_function.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/dirichlet_boundaries.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/quadrature.h&quot;</FONT></B>

  using namespace libMesh;

  <B><FONT COLOR="#228B22">void</FONT></B> ElasticitySystem::init_data()
  {
    u_var = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;add_variable (<B><FONT COLOR="#BC8F8F">&quot;u&quot;</FONT></B>, FIRST, LAGRANGE);
    v_var = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;add_variable (<B><FONT COLOR="#BC8F8F">&quot;v&quot;</FONT></B>, FIRST, LAGRANGE);
    w_var = <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;add_variable (<B><FONT COLOR="#BC8F8F">&quot;w&quot;</FONT></B>, FIRST, LAGRANGE);

    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;time_evolving(u_var);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;time_evolving(v_var);
    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;time_evolving(w_var);

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::set&lt;boundary_id_type&gt; boundary_ids;
    boundary_ids.insert(BOUNDARY_ID_MIN_X);
    boundary_ids.insert(NODE_BOUNDARY_ID);
    boundary_ids.insert(EDGE_BOUNDARY_ID);

    <B><FONT COLOR="#5F9EA0">std</FONT></B>::vector&lt;<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>&gt; variables;
    variables.push_back(u_var);
    variables.push_back(v_var);
    variables.push_back(w_var);

    ZeroFunction&lt;&gt; zf;

    DirichletBoundary dirichlet_bc(boundary_ids,
                                   variables,
                                   &amp;zf);

    <B><FONT COLOR="#A020F0">this</FONT></B>-&gt;get_dof_map().add_dirichlet_boundary(dirichlet_bc);

    <B><FONT COLOR="#5F9EA0">FEMSystem</FONT></B>::init_data();
  }

  <B><FONT COLOR="#228B22">void</FONT></B> ElasticitySystem::init_context(DiffContext &amp; context)
  {
    FEMContext &amp; c = cast_ref&lt;FEMContext &amp;&gt;(context);

    FEBase * u_elem_fe;
    FEBase * u_side_fe;

    c.get_element_fe(u_var, u_elem_fe);
    c.get_side_fe(u_var, u_side_fe);

    u_elem_fe-&gt;get_JxW();
    u_elem_fe-&gt;get_phi();
    u_elem_fe-&gt;get_dphi();

    u_side_fe-&gt;get_JxW();
    u_side_fe-&gt;get_phi();
  }

  <B><FONT COLOR="#228B22">bool</FONT></B> ElasticitySystem::element_time_derivative(<B><FONT COLOR="#228B22">bool</FONT></B> request_jacobian,
                                                 DiffContext &amp; context)
  {
    FEMContext &amp; c = cast_ref&lt;FEMContext &amp;&gt;(context);

    FEBase * u_elem_fe;
    c.get_element_fe(u_var, u_elem_fe);

    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n_u_dofs = c.get_dof_indices(u_var).size();

    <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;Real&gt; &amp; JxW = u_elem_fe-&gt;get_JxW();

    <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;Real&gt; &gt; &amp; phi = u_elem_fe-&gt;get_phi();
    <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;RealGradient&gt; &gt; &amp; grad_phi = u_elem_fe-&gt;get_dphi();

    DenseSubVector&lt;Number&gt; &amp; Fu = c.get_elem_residual(u_var);
    DenseSubVector&lt;Number&gt; &amp; Fv = c.get_elem_residual(v_var);
    DenseSubVector&lt;Number&gt; &amp; Fw = c.get_elem_residual(w_var);

    DenseSubMatrix&lt;Number&gt; &amp; Kuu = c.get_elem_jacobian(u_var, u_var);
    DenseSubMatrix&lt;Number&gt; &amp; Kvv = c.get_elem_jacobian(v_var, v_var);
    DenseSubMatrix&lt;Number&gt; &amp; Kww = c.get_elem_jacobian(w_var, w_var);
    DenseSubMatrix&lt;Number&gt; &amp; Kuv = c.get_elem_jacobian(u_var, v_var);
    DenseSubMatrix&lt;Number&gt; &amp; Kuw = c.get_elem_jacobian(u_var, w_var);
    DenseSubMatrix&lt;Number&gt; &amp; Kvu = c.get_elem_jacobian(v_var, u_var);
    DenseSubMatrix&lt;Number&gt; &amp; Kvw = c.get_elem_jacobian(v_var, w_var);
    DenseSubMatrix&lt;Number&gt; &amp; Kwu = c.get_elem_jacobian(w_var, u_var);
    DenseSubMatrix&lt;Number&gt; &amp; Kwv = c.get_elem_jacobian(w_var, v_var);

    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n_qpoints = c.get_element_qrule().n_points();

    Gradient body_force(0.0, 0.0, -1.0);

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> qp=0; qp != n_qpoints; qp++)
      {
        Gradient grad_u, grad_v, grad_w;
        c.interior_gradient(u_var, qp, grad_u);
        c.interior_gradient(v_var, qp, grad_v);
        c.interior_gradient(w_var, qp, grad_w);

        Tensor grad_U (grad_u, grad_v, grad_w);

        Tensor tau;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i = 0; i &lt; 3; i++)
          <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j = 0; j &lt; 3; j++)
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> k = 0; k &lt; 3; k++)
              <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> l = 0; l &lt; 3; l++)
                tau(i,j) += elasticity_tensor(i,j,k,l)*grad_U(k,l);

        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i != n_u_dofs; i++)
          {
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> alpha = 0; alpha &lt; 3; alpha++)
              {
                Fu(i) += (tau(0,alpha)*grad_phi[i][qp](alpha) - body_force(0)*phi[i][qp])*JxW[qp];
                Fv(i) += (tau(1,alpha)*grad_phi[i][qp](alpha) - body_force(1)*phi[i][qp])*JxW[qp];
                Fw(i) += (tau(2,alpha)*grad_phi[i][qp](alpha) - body_force(2)*phi[i][qp])*JxW[qp];

                <B><FONT COLOR="#A020F0">if</FONT></B> (request_jacobian)
                  {
                    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j != n_u_dofs; j++)
                      {
                        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> beta = 0; beta &lt; 3; beta++)
                          {
                            <B><FONT COLOR="#228B22">const</FONT></B> Real c0 = grad_phi[j][qp](beta)*c.get_elem_solution_derivative();

                            Real dtau_uu = elasticity_tensor(0, alpha, 0, beta)*c0;
                            Real dtau_uv = elasticity_tensor(0, alpha, 1, beta)*c0;
                            Real dtau_uw = elasticity_tensor(0, alpha, 2, beta)*c0;
                            Real dtau_vu = elasticity_tensor(1, alpha, 0, beta)*c0;
                            Real dtau_vv = elasticity_tensor(1, alpha, 1, beta)*c0;
                            Real dtau_vw = elasticity_tensor(1, alpha, 2, beta)*c0;
                            Real dtau_wu = elasticity_tensor(2, alpha, 0, beta)*c0;
                            Real dtau_wv = elasticity_tensor(2, alpha, 1, beta)*c0;
                            Real dtau_ww = elasticity_tensor(2, alpha, 2, beta)*c0;

                            Kuu(i,j) += dtau_uu*grad_phi[i][qp](alpha)*JxW[qp];
                            Kuv(i,j) += dtau_uv*grad_phi[i][qp](alpha)*JxW[qp];
                            Kuw(i,j) += dtau_uw*grad_phi[i][qp](alpha)*JxW[qp];
                            Kvu(i,j) += dtau_vu*grad_phi[i][qp](alpha)*JxW[qp];
                            Kvv(i,j) += dtau_vv*grad_phi[i][qp](alpha)*JxW[qp];
                            Kvw(i,j) += dtau_vw*grad_phi[i][qp](alpha)*JxW[qp];
                            Kwu(i,j) += dtau_wu*grad_phi[i][qp](alpha)*JxW[qp];
                            Kwv(i,j) += dtau_wv*grad_phi[i][qp](alpha)*JxW[qp];
                            Kww(i,j) += dtau_ww*grad_phi[i][qp](alpha)*JxW[qp];
                          }
                      }
                  }
              }
          }

      } <I><FONT COLOR="#B22222">// qp loop
</FONT></I>
    <B><FONT COLOR="#A020F0">return</FONT></B> request_jacobian;
  }

  <B><FONT COLOR="#228B22">bool</FONT></B> ElasticitySystem::side_time_derivative (<B><FONT COLOR="#228B22">bool</FONT></B> request_jacobian,
                                               DiffContext &amp; context)
  {
    FEMContext &amp; c = cast_ref&lt;FEMContext &amp;&gt;(context);

    <B><FONT COLOR="#A020F0">if</FONT></B> (c.has_side_boundary_id(BOUNDARY_ID_MAX_X))
      {
        FEBase * u_side_fe;
        c.get_side_fe(u_var, u_side_fe);

        <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n_u_dofs = c.get_dof_indices(u_var).size();

        DenseSubVector&lt;Number&gt; &amp; Fu = c.get_elem_residual(u_var);
        DenseSubVector&lt;Number&gt; &amp; Fv = c.get_elem_residual(v_var);
        DenseSubVector&lt;Number&gt; &amp; Fw = c.get_elem_residual(w_var);

        <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;Real&gt; &amp; JxW = u_side_fe-&gt;get_JxW();

        <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;Real&gt; &gt; &amp; phi = u_side_fe-&gt;get_phi();

        <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n_qpoints = c.get_side_qrule().n_points();

        Gradient traction(0.0, 0.0, -1.0);

        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> qp=0; qp != n_qpoints; qp++)
          {
            <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i != n_u_dofs; i++)
              {
                Fu(i) -= traction(0)*phi[i][qp]*JxW[qp];
                Fv(i) -= traction(1)*phi[i][qp]*JxW[qp];
                Fw(i) -= traction(2)*phi[i][qp]*JxW[qp];
              }
          }
      }

    <B><FONT COLOR="#A020F0">return</FONT></B> request_jacobian;
  }

  <B><FONT COLOR="#228B22">bool</FONT></B> ElasticitySystem::mass_residual(<B><FONT COLOR="#228B22">bool</FONT></B> request_jacobian,
                                       DiffContext &amp; context)
  {
    FEMContext &amp; c = cast_ref&lt;FEMContext &amp;&gt;(context);

    FEBase * u_elem_fe;
    c.get_element_fe(u_var, u_elem_fe);

    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n_u_dofs = c.get_dof_indices(u_var).size();

    <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;Real&gt; &amp; JxW = u_elem_fe-&gt;get_JxW();

    <B><FONT COLOR="#228B22">const</FONT></B> std::vector&lt;std::vector&lt;Real&gt; &gt; &amp; phi = u_elem_fe-&gt;get_phi();

    <B><FONT COLOR="#5F9EA0">libMesh</FONT></B>::DenseSubVector&lt;libMesh::Number&gt; &amp; Fu = c.get_elem_residual(u_var);
    <B><FONT COLOR="#5F9EA0">libMesh</FONT></B>::DenseSubVector&lt;libMesh::Number&gt; &amp; Fv = c.get_elem_residual(v_var);
    <B><FONT COLOR="#5F9EA0">libMesh</FONT></B>::DenseSubVector&lt;libMesh::Number&gt; &amp; Fw = c.get_elem_residual(w_var);

    <B><FONT COLOR="#5F9EA0">libMesh</FONT></B>::DenseSubMatrix&lt;libMesh::Number&gt; &amp; Kuu = c.get_elem_jacobian(u_var, u_var);
    <B><FONT COLOR="#5F9EA0">libMesh</FONT></B>::DenseSubMatrix&lt;libMesh::Number&gt; &amp; Kvv = c.get_elem_jacobian(v_var, v_var);
    <B><FONT COLOR="#5F9EA0">libMesh</FONT></B>::DenseSubMatrix&lt;libMesh::Number&gt; &amp; Kww = c.get_elem_jacobian(w_var, w_var);

    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n_qpoints = c.get_element_qrule().n_points();

    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> qp=0; qp != n_qpoints; qp++)
      {
        <B><FONT COLOR="#5F9EA0">libMesh</FONT></B>::Number u_ddot, v_ddot, w_ddot;
        c.interior_accel(u_var, qp, u_ddot);
        c.interior_accel(v_var, qp, v_ddot);
        c.interior_accel(w_var, qp, w_ddot);

        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i=0; i != n_u_dofs; i++)
          {
            Fu(i) += _rho*u_ddot*phi[i][qp]*JxW[qp];
            Fv(i) += _rho*v_ddot*phi[i][qp]*JxW[qp];
            Fw(i) += _rho*w_ddot*phi[i][qp]*JxW[qp];

            <B><FONT COLOR="#A020F0">if</FONT></B> (request_jacobian)
              {
                <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j=0; j != n_u_dofs; j++)
                  {
                    <B><FONT COLOR="#5F9EA0">libMesh</FONT></B>::Real jac_term = _rho*phi[i][qp]*phi[j][qp]*JxW[qp];
                    jac_term *= context.get_elem_solution_accel_derivative();

                    Kuu(i,j) += jac_term;
                    Kvv(i,j) += jac_term;
                    Kww(i,j) += jac_term;
                  }
              }
          }
      }

    <B><FONT COLOR="#A020F0">return</FONT></B> request_jacobian;
  }

  Real ElasticitySystem::elasticity_tensor(<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> i, <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> j, <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> k, <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> l)
  {
    <B><FONT COLOR="#228B22">const</FONT></B> Real poisson_ratio = 0.3;
    <B><FONT COLOR="#228B22">const</FONT></B> Real young_modulus = 1.0e2;

    <B><FONT COLOR="#228B22">const</FONT></B> Real lambda_1 = (young_modulus*poisson_ratio)/((1.+poisson_ratio)*(1.-2.*poisson_ratio));
    <B><FONT COLOR="#228B22">const</FONT></B> Real lambda_2 = young_modulus/(2.*(1.+poisson_ratio));

    <B><FONT COLOR="#A020F0">return</FONT></B>
      lambda_1 * kronecker_delta(i, j) * kronecker_delta(k, l) +
      lambda_2 * (kronecker_delta(i, k) * kronecker_delta(j, l) + kronecker_delta(i, l) * kronecker_delta(j, k));
  }
</pre>
<a name="nocomments"></a>
<br><br><br> <h1> The source file fem_system_ex3.C without comments: </h1>
<pre>
  #include &lt;iomanip&gt;

  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/equation_systems.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/error_vector.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/getpot.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/exodusII_io.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/kelly_error_estimator.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/mesh.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/mesh_generation.h&quot;</FONT></B>

  #include <B><FONT COLOR="#BC8F8F">&quot;elasticity_system.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/diff_solver.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/newmark_solver.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/steady_solver.h&quot;</FONT></B>
  #include <B><FONT COLOR="#BC8F8F">&quot;libmesh/elem.h&quot;</FONT></B>

  #define x_scaling 1.3

  using namespace libMesh;

  <B><FONT COLOR="#228B22">int</FONT></B> main (<B><FONT COLOR="#228B22">int</FONT></B> argc, <B><FONT COLOR="#228B22">char</FONT></B> ** argv)
  {
    LibMeshInit init (argc, argv);

    GetPot infile(<B><FONT COLOR="#BC8F8F">&quot;fem_system_ex3.in&quot;</FONT></B>);

    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">bool</FONT></B> transient        = infile(<B><FONT COLOR="#BC8F8F">&quot;transient&quot;</FONT></B>, true);
    <B><FONT COLOR="#228B22">const</FONT></B> Real deltat           = infile(<B><FONT COLOR="#BC8F8F">&quot;deltat&quot;</FONT></B>, 0.25);
    <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n_timesteps    = infile(<B><FONT COLOR="#BC8F8F">&quot;n_timesteps&quot;</FONT></B>, 25);

  #ifdef LIBMESH_HAVE_EXODUS_API
    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> write_interval    = infile(<B><FONT COLOR="#BC8F8F">&quot;write_interval&quot;</FONT></B>, 1);
  #endif

    <B><FONT COLOR="#228B22">const</FONT></B> <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> dim = 3;

    libmesh_example_requires(dim == LIBMESH_DIM, <B><FONT COLOR="#BC8F8F">&quot;3D support&quot;</FONT></B>);

    Mesh mesh(init.comm(), dim);
    <B><FONT COLOR="#5F9EA0">MeshTools</FONT></B>::Generation::build_cube (mesh,
                                       40,
                                       10,
                                       5,
                                       0., 1.*x_scaling,
                                       0., 0.3,
                                       0., 0.1,
                                       HEX8);


    mesh.print_info();

    <B><FONT COLOR="#5F9EA0">MeshBase</FONT></B>::const_element_iterator       el     = mesh.active_local_elements_begin();
    <B><FONT COLOR="#228B22">const</FONT></B> MeshBase::const_element_iterator end_el = mesh.active_local_elements_end();
    <B><FONT COLOR="#A020F0">for</FONT></B> ( ; el != end_el; ++el)
      {
        <B><FONT COLOR="#228B22">const</FONT></B> Elem * elem = *el;

        <B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B>
          side_max_x = 0, side_min_y = 0,
          side_max_y = 0, side_max_z = 0;
        <B><FONT COLOR="#228B22">bool</FONT></B>
          found_side_max_x = false, found_side_max_y = false,
          found_side_min_y = false, found_side_max_z = false;
        <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> side=0; side&lt;elem-&gt;n_sides(); side++)
          {
            <B><FONT COLOR="#A020F0">if</FONT></B> (mesh.get_boundary_info().has_boundary_id(elem, side, BOUNDARY_ID_MAX_X))
              {
                side_max_x = side;
                found_side_max_x = true;
              }

            <B><FONT COLOR="#A020F0">if</FONT></B> (mesh.get_boundary_info().has_boundary_id(elem, side, BOUNDARY_ID_MIN_Y))
              {
                side_min_y = side;
                found_side_min_y = true;
              }

            <B><FONT COLOR="#A020F0">if</FONT></B> (mesh.get_boundary_info().has_boundary_id(elem, side, BOUNDARY_ID_MAX_Y))
              {
                side_max_y = side;
                found_side_max_y = true;
              }

            <B><FONT COLOR="#A020F0">if</FONT></B> (mesh.get_boundary_info().has_boundary_id(elem, side, BOUNDARY_ID_MAX_Z))
              {
                side_max_z = side;
                found_side_max_z = true;
              }
          }

        <B><FONT COLOR="#A020F0">if</FONT></B> (found_side_max_x &amp;&amp; found_side_max_y &amp;&amp; found_side_max_z)
          <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> n=0; n&lt;elem-&gt;n_nodes(); n++)
            <B><FONT COLOR="#A020F0">if</FONT></B> (elem-&gt;is_node_on_side(n, side_max_x) &amp;&amp;
                elem-&gt;is_node_on_side(n, side_max_y) &amp;&amp;
                elem-&gt;is_node_on_side(n, side_max_z))
              mesh.get_boundary_info().add_node(elem-&gt;get_node(n), NODE_BOUNDARY_ID);

        <B><FONT COLOR="#A020F0">if</FONT></B> (found_side_max_x &amp;&amp; found_side_min_y)
          <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> e=0; e&lt;elem-&gt;n_edges(); e++)
            <B><FONT COLOR="#A020F0">if</FONT></B> (elem-&gt;is_edge_on_side(e, side_max_x) &amp;&amp;
                elem-&gt;is_edge_on_side(e, side_min_y))
              mesh.get_boundary_info().add_edge(elem, e, EDGE_BOUNDARY_ID);
      }

    EquationSystems equation_systems (mesh);

    ElasticitySystem &amp; system =
      equation_systems.add_system&lt;ElasticitySystem&gt; (<B><FONT COLOR="#BC8F8F">&quot;Linear Elasticity&quot;</FONT></B>);

    ExplicitSystem &amp; v_system =
      equation_systems.add_system&lt;ExplicitSystem&gt; (<B><FONT COLOR="#BC8F8F">&quot;Velocity&quot;</FONT></B>);
    v_system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;u_vel&quot;</FONT></B>, FIRST, LAGRANGE);
    v_system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;v_vel&quot;</FONT></B>, FIRST, LAGRANGE);
    v_system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;w_vel&quot;</FONT></B>, FIRST, LAGRANGE);

    ExplicitSystem &amp; a_system =
      equation_systems.add_system&lt;ExplicitSystem&gt; (<B><FONT COLOR="#BC8F8F">&quot;Acceleration&quot;</FONT></B>);
    a_system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;u_accel&quot;</FONT></B>, FIRST, LAGRANGE);
    a_system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;v_accel&quot;</FONT></B>, FIRST, LAGRANGE);
    a_system.add_variable(<B><FONT COLOR="#BC8F8F">&quot;w_accel&quot;</FONT></B>, FIRST, LAGRANGE);

    <B><FONT COLOR="#A020F0">if</FONT></B> (transient)
      system.time_solver =
        UniquePtr&lt;NewmarkSolver&gt;(<B><FONT COLOR="#A020F0">new</FONT></B> NewmarkSolver(system));
    <B><FONT COLOR="#A020F0">else</FONT></B>
      {
        system.time_solver =
          UniquePtr&lt;TimeSolver&gt;(<B><FONT COLOR="#A020F0">new</FONT></B> SteadySolver(system));
        libmesh_assert_equal_to (n_timesteps, 1);
      }

    equation_systems.init ();

    system.deltat = deltat;

    DiffSolver &amp; solver = *(system.time_solver-&gt;diff_solver().get());
    solver.quiet = infile(<B><FONT COLOR="#BC8F8F">&quot;solver_quiet&quot;</FONT></B>, true);
    solver.verbose = !solver.quiet;
    solver.max_nonlinear_iterations = infile(<B><FONT COLOR="#BC8F8F">&quot;max_nonlinear_iterations&quot;</FONT></B>, 15);
    solver.relative_step_tolerance = infile(<B><FONT COLOR="#BC8F8F">&quot;relative_step_tolerance&quot;</FONT></B>, 1.e-3);
    solver.relative_residual_tolerance = infile(<B><FONT COLOR="#BC8F8F">&quot;relative_residual_tolerance&quot;</FONT></B>, 0.0);
    solver.absolute_residual_tolerance = infile(<B><FONT COLOR="#BC8F8F">&quot;absolute_residual_tolerance&quot;</FONT></B>, 0.0);

    solver.max_linear_iterations = infile(<B><FONT COLOR="#BC8F8F">&quot;max_linear_iterations&quot;</FONT></B>, 50000);
    solver.initial_linear_tolerance = infile(<B><FONT COLOR="#BC8F8F">&quot;initial_linear_tolerance&quot;</FONT></B>, 1.e-3);

    equation_systems.print_info();

    NewmarkSolver * newmark = cast_ptr&lt;NewmarkSolver*&gt;(system.time_solver.get());
    newmark-&gt;compute_initial_accel();

    (*v_system.solution) = system.get_vector(<B><FONT COLOR="#BC8F8F">&quot;_old_solution_rate&quot;</FONT></B>);
    (*a_system.solution) = system.get_vector(<B><FONT COLOR="#BC8F8F">&quot;_old_solution_accel&quot;</FONT></B>);

  #ifdef LIBMESH_HAVE_EXODUS_API
    {
      <B><FONT COLOR="#5F9EA0">std</FONT></B>::ostringstream file_name;

      file_name &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;out.e-s.&quot;</FONT></B>
                &lt;&lt; std::setw(3)
                &lt;&lt; std::setfill(<B><FONT COLOR="#BC8F8F">'0'</FONT></B>)
                &lt;&lt; std::right
                &lt;&lt; 0;

      ExodusII_IO(mesh).write_timestep(file_name.str(),
                                       equation_systems,
                                       1, <I><FONT COLOR="#B22222">// This number indicates how many time steps
</FONT></I>                                       system.time);
    }
  #endif <I><FONT COLOR="#B22222">// #ifdef LIBMESH_HAVE_EXODUS_API
</FONT></I>
    <B><FONT COLOR="#A020F0">for</FONT></B> (<B><FONT COLOR="#228B22">unsigned</FONT></B> <B><FONT COLOR="#228B22">int</FONT></B> t_step=0; t_step != n_timesteps; ++t_step)
      {
        <B><FONT COLOR="#5F9EA0">libMesh</FONT></B>::out &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;\n\nSolving time step &quot;</FONT></B>
                     &lt;&lt; t_step
                     &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;, time = &quot;</FONT></B>
                     &lt;&lt; system.time
                     &lt;&lt; std::endl;

        system.solve();

        system.time_solver-&gt;advance_timestep();

        (*v_system.solution) = system.get_vector(<B><FONT COLOR="#BC8F8F">&quot;_old_solution_rate&quot;</FONT></B>);
        (*a_system.solution) = system.get_vector(<B><FONT COLOR="#BC8F8F">&quot;_old_solution_accel&quot;</FONT></B>);

  #ifdef LIBMESH_HAVE_EXODUS_API
        <B><FONT COLOR="#A020F0">if</FONT></B> ((t_step+1)%write_interval == 0)
          {
            <B><FONT COLOR="#5F9EA0">std</FONT></B>::ostringstream file_name;

            file_name &lt;&lt; <B><FONT COLOR="#BC8F8F">&quot;out.e-s.&quot;</FONT></B>
                      &lt;&lt; std::setw(3)
                      &lt;&lt; std::setfill(<B><FONT COLOR="#BC8F8F">'0'</FONT></B>)
                      &lt;&lt; std::right
                      &lt;&lt; t_step+1;

            ExodusII_IO(mesh).write_timestep(file_name.str(),
                                             equation_systems,
                                             1, <I><FONT COLOR="#B22222">// This number indicates how many time steps
</FONT></I>                                             system.time);
          }
  #endif <I><FONT COLOR="#B22222">// #ifdef LIBMESH_HAVE_EXODUS_API
</FONT></I>      }

    <B><FONT COLOR="#A020F0">return</FONT></B> 0;
  }
</pre>
<a name="output"></a>
<br><br><br> <h1> The console output of the program: </h1>
<pre>
***************************************************************
* Running Example fem_system_ex3:
*   example-opt -ksp_type cg -pc_type jacobi
***************************************************************

 Mesh Information:
  elem_dimensions()={3}
  spatial_dimension()=3
  n_nodes()=2706
    n_local_nodes()=2706
  n_elem()=2000
    n_local_elem()=2000
    n_active_elem()=2000
  n_subdomains()=1
  n_partitions()=1
  n_processors()=1
  n_threads()=1
  processor_id()=0

 EquationSystems
  n_systems()=3
   System #2, "Acceleration"
    Type "Explicit"
    Variables={ "u_accel" "v_accel" "w_accel" }
    Finite Element Types="LAGRANGE", "JACOBI_20_00"
    Infinite Element Mapping="CARTESIAN"
    Approximation Orders="FIRST", "THIRD"
    n_dofs()=8118
    n_local_dofs()=8118
    n_constrained_dofs()=0
    n_local_constrained_dofs()=0
    n_vectors()=1
    n_matrices()=0
    DofMap Sparsity
      Average  On-Processor Bandwidth <= 0
      Average Off-Processor Bandwidth <= 0
      Maximum  On-Processor Bandwidth <= 0
      Maximum Off-Processor Bandwidth <= 0
    DofMap Constraints
      Number of DoF Constraints = 0
   System #0, "Linear Elasticity"
    Type "Implicit"
    Variables={ "u" "v" "w" }
    Finite Element Types="LAGRANGE", "JACOBI_20_00"
    Infinite Element Mapping="CARTESIAN"
    Approximation Orders="FIRST", "THIRD"
    n_dofs()=8118
    n_local_dofs()=8118
    n_constrained_dofs()=219
    n_local_constrained_dofs()=219
    n_vectors()=4
    n_matrices()=1
    DofMap Sparsity
      Average  On-Processor Bandwidth <= 66.5366
      Average Off-Processor Bandwidth <= 0
      Maximum  On-Processor Bandwidth <= 81
      Maximum Off-Processor Bandwidth <= 0
    DofMap Constraints
      Number of DoF Constraints = 219
      Average DoF Constraint Length= 0
   System #1, "Velocity"
    Type "Explicit"
    Variables={ "u_vel" "v_vel" "w_vel" }
    Finite Element Types="LAGRANGE", "JACOBI_20_00"
    Infinite Element Mapping="CARTESIAN"
    Approximation Orders="FIRST", "THIRD"
    n_dofs()=8118
    n_local_dofs()=8118
    n_constrained_dofs()=0
    n_local_constrained_dofs()=0
    n_vectors()=1
    n_matrices()=0
    DofMap Sparsity
      Average  On-Processor Bandwidth <= 0
      Average Off-Processor Bandwidth <= 0
      Maximum  On-Processor Bandwidth <= 0
      Maximum Off-Processor Bandwidth <= 0
    DofMap Constraints
      Number of DoF Constraints = 0

Assembling the System
Nonlinear Residual: 0.00470772
Linear solve starting, tolerance 4.70772e-06
Linear solve finished, step 23, residual 0.00704013
Trying full Newton step
  Current Residual: 3.18113e-08
  Nonlinear solver converged, step 0, residual reduction 6.75726e-06 < 0.001
  Nonlinear solver relative step size inf > 0.001


Solving time step 0, time = 0
Assembling the System
Nonlinear Residual: 0.00941544
Linear solve starting, tolerance 9.41544e-06
Linear solve finished, step 561, residual 2.5637e-08
Trying full Newton step
  Current Residual: 1.04479e-07
  Nonlinear solver converged, step 0, residual reduction 1.10965e-05 < 0.001
  Nonlinear solver relative step size inf > 0.001


Solving time step 1, time = 0.25
Assembling the System
Nonlinear Residual: 0.0129921
Linear solve starting, tolerance 1.29921e-05
Linear solve finished, step 560, residual 3.66363e-08
Trying full Newton step
  Current Residual: 1.48431e-07
  Nonlinear solver converged, step 0, residual reduction 1.14247e-05 < 0.001
  Nonlinear solver relative step size 2.4554 > 0.001


Solving time step 2, time = 0.5
Assembling the System
Nonlinear Residual: 0.0143024
Linear solve starting, tolerance 1.43024e-05
Linear solve finished, step 554, residual 4.35063e-08
Trying full Newton step
  Current Residual: 1.79685e-07
  Nonlinear solver converged, step 0, residual reduction 1.25632e-05 < 0.001
  Nonlinear solver relative step size 0.802374 > 0.001


Solving time step 3, time = 0.75
Assembling the System
Nonlinear Residual: 0.0115535
Linear solve starting, tolerance 1.15535e-05
Linear solve finished, step 587, residual 2.50194e-08
Trying full Newton step
  Current Residual: 1.10282e-07
  Nonlinear solver converged, step 0, residual reduction 7.71074e-06 < 0.001
  Nonlinear solver relative step size 0.280681 > 0.001


Solving time step 4, time = 1
Assembling the System
Nonlinear Residual: 0.00879077
Linear solve starting, tolerance 8.79077e-06
Linear solve finished, step 586, residual 1.84969e-08
Trying full Newton step
  Current Residual: 7.93832e-08
  Nonlinear solver converged, step 0, residual reduction 5.55033e-06 < 0.001
  Nonlinear solver relative step size 0.0252965 > 0.001

 -------------------------------------------------------------------------------------------------------------------
| Time:           Tue Apr 12 15:27:55 2016                                                                          |
| OS:             Darwin                                                                                            |
| HostName:       peterson-laptop.local                                                                             |
| OS Release:     15.0.0                                                                                            |
| OS Version:     Darwin Kernel Version 15.0.0: Sat Sep 19 15:53:46 PDT 2015; root:xnu-3247.10.11~1/RELEASE_X86_64  |
| Machine:        x86_64                                                                                            |
| Username:       petejw                                                                                            |
| Configuration:  ../configure  'INSTALL=/usr/bin/install -C'                                                       |
|  '--with-methods=opt dbg'                                                                                         |
|  '--prefix=/Users/petejw/projects/libmesh_git/installed'                                                          |
|  '--enable-perflog'                                                                                               |
|  '--enable-tracefiles'                                                                                            |
|  '--disable-blocked-storage'                                                                                      |
|  '--enable-default-comm-world'                                                                                    |
|  '--enable-tecio'                                                                                                 |
|  '--enable-unique-ptr'                                                                                            |
|  '--enable-ifem'                                                                                                  |
|  'PETSC_DIR=/opt/moose/petsc/mpich_petsc-3.6.1/clang-opt-superlu'                                                 |
|  'SLEPC_DIR=/opt/petejw/slepc/3.6.1'                                                                              |
|  'CPPFLAGS= '                                                                                                     |
|  'LIBS= '                                                                                                         |
|  'CPPFLAGS=  '                                                                                                    |
|  'LIBS=  '                                                                                                        |
|  '--disable-netcdf-4'                                                                                             |
|  '--disable-testsets'                                                                                             |
|  'CXX=mpicxx'                                                                                                     |
|  'CC=mpicc'                                                                                                       |
|  'F77=mpif77'                                                                                                     |
|  'FC=mpif90'                                                                                                      |
|  'CPPFLAGS=   '                                                                                                   |
|  'LIBS=   '                                                                                                       |
 -------------------------------------------------------------------------------------------------------------------
 -----------------------------------------------------------------------------------------------------------------
| libMesh Performance: Alive time=3.53313, Active time=3.48255                                                    |
 -----------------------------------------------------------------------------------------------------------------
| Event                              nCalls     Total Time  Avg Time    Total Time  Avg Time    % of Active Time  |
|                                               w/o Sub     w/o Sub     With Sub    With Sub    w/o S    With S   |
|-----------------------------------------------------------------------------------------------------------------|
|                                                                                                                 |
|                                                                                                                 |
| DofMap                                                                                                          |
|   add_neighbors_to_send_list()     3          0.0024      0.000787    0.0024      0.000787    0.07     0.07     |
|   build_constraint_matrix()        24000      0.0112      0.000000    0.0112      0.000000    0.32     0.32     |
|   build_sparsity()                 1          0.0209      0.020897    0.0222      0.022185    0.60     0.64     |
|   cnstrn_elem_mat_vec()            12000      0.0042      0.000000    0.0042      0.000000    0.12     0.12     |
|   constrain_elem_vector()          12000      0.0024      0.000000    0.0024      0.000000    0.07     0.07     |
|   create_dof_constraints()         3          0.0105      0.003489    0.0125      0.004168    0.30     0.36     |
|   distribute_dofs()                3          0.0010      0.000341    0.0077      0.002563    0.03     0.22     |
|   dof_indices()                    212000     0.0503      0.000000    0.0503      0.000000    1.44     1.44     |
|   enforce_constraints_exactly()    18         0.0012      0.000069    0.0012      0.000069    0.04     0.04     |
|   prepare_send_list()              6          0.0000      0.000000    0.0000      0.000000    0.00     0.00     |
|   reinit()                         3          0.0067      0.002222    0.0067      0.002222    0.19     0.19     |
|                                                                                                                 |
| EquationSystems                                                                                                 |
|   build_solution_vector()          6          0.0649      0.010817    0.0943      0.015715    1.86     2.71     |
|                                                                                                                 |
| ExodusII_IO                                                                                                     |
|   write_nodal_data()               6          0.0240      0.004006    0.0240      0.004006    0.69     0.69     |
|                                                                                                                 |
| FE                                                                                                              |
|   compute_shape_functions()        39615      0.0650      0.000002    0.0650      0.000002    1.87     1.87     |
|   init_shape_functions()           15627      0.0020      0.000000    0.0020      0.000000    0.06     0.06     |
|   inverse_map()                    30         0.0001      0.000002    0.0001      0.000002    0.00     0.00     |
|                                                                                                                 |
| FEMSystem                                                                                                       |
|   assembly()                       6          1.4183      0.236379    2.0042      0.334042    40.73    57.55    |
|   assembly(get_residual)           6          0.1250      0.020827    0.2397      0.039944    3.59     6.88     |
|   numerical_elem_jacobian()        2000       0.4046      0.000202    0.4046      0.000202    11.62    11.62    |
|   numerical_side_jacobian()        1300       0.0595      0.000046    0.0595      0.000046    1.71     1.71     |
|                                                                                                                 |
| FEMap                                                                                                           |
|   compute_affine_map()             39615      0.0321      0.000001    0.0321      0.000001    0.92     0.92     |
|   compute_edge_map()               15         0.0000      0.000001    0.0000      0.000001    0.00     0.00     |
|   compute_face_map()               15600      0.0070      0.000000    0.0070      0.000000    0.20     0.20     |
|   init_edge_shape_functions()      15         0.0000      0.000001    0.0000      0.000001    0.00     0.00     |
|   init_face_shape_functions()      12         0.0001      0.000004    0.0001      0.000004    0.00     0.00     |
|   init_reference_to_physical_map() 15627      0.0636      0.000004    0.0636      0.000004    1.83     1.83     |
|                                                                                                                 |
| Mesh                                                                                                            |
|   find_neighbors()                 1          0.0054      0.005424    0.0054      0.005424    0.16     0.16     |
|   renumber_nodes_and_elem()        2          0.0001      0.000059    0.0001      0.000059    0.00     0.00     |
|                                                                                                                 |
| MeshOutput                                                                                                      |
|   write_equation_systems()         6          0.0001      0.000015    0.1184      0.019735    0.00     3.40     |
|                                                                                                                 |
| MeshTools::Generation                                                                                           |
|   build_cube()                     1          0.0008      0.000830    0.0008      0.000830    0.02     0.02     |
|                                                                                                                 |
| NewtonSolver                                                                                                    |
|   solve()                          6          0.0015      0.000255    3.3442      0.557374    0.04     96.03    |
|                                                                                                                 |
| Parallel                                                                                                        |
|   allgather()                      3          0.0000      0.000000    0.0000      0.000000    0.00     0.00     |
|                                                                                                                 |
| Partitioner                                                                                                     |
|   single_partition()               1          0.0001      0.000114    0.0001      0.000114    0.00     0.00     |
|                                                                                                                 |
| PetscLinearSolver                                                                                               |
|   solve()                          6          1.0976      0.182926    1.0976      0.182926    31.52    31.52    |
 -----------------------------------------------------------------------------------------------------------------
| Totals:                            389543     3.4826                                          100.00            |
 -----------------------------------------------------------------------------------------------------------------


***************************************************************
* Done Running Example fem_system_ex3:
*   example-opt -ksp_type cg -pc_type jacobi
***************************************************************
</pre>
</div>

<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.1/jquery.min.js"></script>
<script type="text/javascript">
$(document).ready(function(){
  $(window).on('scroll',function() {
    var scrolltop = $(this).scrollTop();

    if(scrolltop >= 215) {
      $('#fixedbar').fadeIn(250);
    }

    else if(scrolltop <= 210) {
      $('#fixedbar').fadeOut(250);
    }
  });
});
</script>

<!-- Google Analytics stuff -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-24978333-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>

</body>
</html>
