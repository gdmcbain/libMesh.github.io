<!-- HTML header for doxygen -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libMesh: libMesh::AdjointRefinementEstimator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="../styles.css" rel="stylesheet" type="text/css" />
<link href="doxygen_stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <nav id="fixedbar">
    <ul id="fixednav">
      <li><a href="../index.html">Home</a></li>
      <li><a href="../support.html">About Us</a></li>
      <li><a href="../publications.html">Publications</a></li>
      <li><a href="../developers.html">Developers</a></li>
      <li><a href="../installation.html">Installation</a></li>
      <li><a href="../examples.html">Examples</a></li>
      <li><a href="../doxygen/index.html">Documentation</a></li>
    </ul>
  </nav>
  <div id="w">
    <header id="logo"><a href="index.html"><span id="logobg">SomeWebsiteLogo</span></a></header>
    <nav id="navigation">
      <ul>
        <li><a href="../index.html">Home</a></li>
        <li><a href="../support.html">About Us</a></li>
        <li><a href="../publications.html">Publications</a></li>
        <li><a href="../developers.html">Developers</a></li>
        <li><a href="../installation.html">Installation</a></li>
        <li><a href="../examples.html">Examples</a></li>
        <li><a href="../doxygen/index.html">Documentation</a></li>
      </ul>
    </nav>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- <\!--BEGIN TITLEAREA-\-> -->
<!-- <div id="titlearea"> -->
<!-- <table cellspacing="0" cellpadding="0"> -->
<!--  <tbody> -->
<!--  <tr style="height: 56px;"> -->
<!--   <\!--BEGIN PROJECT_LOGO-\-> -->
<!--   <td id="projectlogo"><img alt="Logo" src=""/></td> -->
<!--   <\!--END PROJECT_LOGO-\-> -->
<!--   <\!--BEGIN PROJECT_NAME-\-> -->
<!--   <td style="padding-left: 0.5em;"> -->
<!--    <div id="projectname">libMesh -->
<!--    <\!--BEGIN PROJECT_NUMBER-\->&#160;<span id="projectnumber"></span><\!--END PROJECT_NUMBER-\-> -->
<!--    </div> -->
<!--    <\!--BEGIN PROJECT_BRIEF-\-><div id="projectbrief"></div><\!--END PROJECT_BRIEF-\-> -->
<!--   </td> -->
<!--   <\!--END PROJECT_NAME-\-> -->
<!--   <\!--BEGIN !PROJECT_NAME-\-> -->
<!--    <\!--BEGIN PROJECT_BRIEF-\-> -->
<!--     <td style="padding-left: 0.5em;"> -->
<!--     <div id="projectbrief"></div> -->
<!--     </td> -->
<!--    <\!--END PROJECT_BRIEF-\-> -->
<!--   <\!--END !PROJECT_NAME-\-> -->
<!--   <\!--BEGIN DISABLE_INDEX-\-> -->
<!--    <\!--BEGIN SEARCHENGINE-\-> -->
<!--    <td></td> -->
<!--    <\!--END SEARCHENGINE-\-> -->
<!--   <\!--END DISABLE_INDEX-\-> -->
<!--  </tr> -->
<!--  </tbody> -->
<!-- </table> -->
<!-- </div> -->
<!-- <\!--END TITLEAREA-\-> -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibMesh.html">libMesh</a></li><li class="navelem"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html">AdjointRefinementEstimator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classlibMesh_1_1AdjointRefinementEstimator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">libMesh::AdjointRefinementEstimator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for libMesh::AdjointRefinementEstimator:</div>
<div class="dyncontent">
<div class="center"><img src="classlibMesh_1_1AdjointRefinementEstimator__inherit__graph.png" border="0" usemap="#libMesh_1_1AdjointRefinementEstimator_inherit__map" alt="Inheritance graph"/></div>
<map name="libMesh_1_1AdjointRefinementEstimator_inherit__map" id="libMesh_1_1AdjointRefinementEstimator_inherit__map">
<area shape="rect" id="node2" href="classlibMesh_1_1ErrorEstimator.html" title="libMesh::ErrorEstimator" alt="" coords="17,5,188,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a838c11d53f37d85b33a827a355819c94"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; std::pair<br class="typebreak" />
&lt; const <a class="el" href="classlibMesh_1_1System.html">System</a> *, unsigned int &gt;<br class="typebreak" />
, <a class="el" href="classlibMesh_1_1ErrorVector.html">ErrorVector</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ErrorEstimator.html#a838c11d53f37d85b33a827a355819c94">ErrorMap</a></td></tr>
<tr class="separator:a838c11d53f37d85b33a827a355819c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:afcdf4f028e2e69d7457d052cb8b27540"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#afcdf4f028e2e69d7457d052cb8b27540">AdjointRefinementEstimator</a> ()</td></tr>
<tr class="separator:afcdf4f028e2e69d7457d052cb8b27540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe91c49a0c78d780403574eeaee5b3a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#acfe91c49a0c78d780403574eeaee5b3a">~AdjointRefinementEstimator</a> ()</td></tr>
<tr class="separator:acfe91c49a0c78d780403574eeaee5b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aca6ed2c5e83a66cbea3fb745d42bb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1QoISet.html">QoISet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#a0aca6ed2c5e83a66cbea3fb745d42bb6">qoi_set</a> ()</td></tr>
<tr class="separator:a0aca6ed2c5e83a66cbea3fb745d42bb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcdc392b69087dc11dc56fe15b29708a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classlibMesh_1_1QoISet.html">QoISet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#afcdc392b69087dc11dc56fe15b29708a">qoi_set</a> () const </td></tr>
<tr class="separator:afcdc392b69087dc11dc56fe15b29708a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88133f5a181d748fd67d537e37fb944c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#a88133f5a181d748fd67d537e37fb944c">estimate_error</a> (const <a class="el" href="classlibMesh_1_1System.html">System</a> &amp;system, <a class="el" href="classlibMesh_1_1ErrorVector.html">ErrorVector</a> &amp;error_per_cell, const <a class="el" href="classlibMesh_1_1NumericVector.html">NumericVector</a>&lt; <a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &gt; *solution_vector=NULL, bool estimate_parent_error=false)</td></tr>
<tr class="separator:a88133f5a181d748fd67d537e37fb944c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0143c56bd2fdc236700dd3b1262d7097"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#a0143c56bd2fdc236700dd3b1262d7097">get_global_QoI_error_estimate</a> (unsigned int qoi_index)</td></tr>
<tr class="separator:a0143c56bd2fdc236700dd3b1262d7097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d34dfeddc8a1991cd9d01e401b6d779"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ErrorEstimator.html#a8d34dfeddc8a1991cd9d01e401b6d779">estimate_errors</a> (const <a class="el" href="classlibMesh_1_1EquationSystems.html">EquationSystems</a> &amp;equation_systems, <a class="el" href="classlibMesh_1_1ErrorVector.html">ErrorVector</a> &amp;error_per_cell, const std::map&lt; const <a class="el" href="classlibMesh_1_1System.html">System</a> *, <a class="el" href="classlibMesh_1_1SystemNorm.html">SystemNorm</a> &gt; &amp;error_norms, const std::map&lt; const <a class="el" href="classlibMesh_1_1System.html">System</a> *, const <a class="el" href="classlibMesh_1_1NumericVector.html">NumericVector</a>&lt; <a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &gt; * &gt; *solution_vectors=NULL, bool estimate_parent_error=false)</td></tr>
<tr class="separator:a8d34dfeddc8a1991cd9d01e401b6d779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6154704639951f51a2749af773c7ea6d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ErrorEstimator.html#a6154704639951f51a2749af773c7ea6d">estimate_errors</a> (const <a class="el" href="classlibMesh_1_1EquationSystems.html">EquationSystems</a> &amp;equation_systems, <a class="el" href="classlibMesh_1_1ErrorEstimator.html#a838c11d53f37d85b33a827a355819c94">ErrorMap</a> &amp;errors_per_cell, const std::map&lt; const <a class="el" href="classlibMesh_1_1System.html">System</a> *, const <a class="el" href="classlibMesh_1_1NumericVector.html">NumericVector</a>&lt; <a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &gt; * &gt; *solution_vectors=NULL, bool estimate_parent_error=false)</td></tr>
<tr class="separator:a6154704639951f51a2749af773c7ea6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a4437c7888b7459952e06a9157bf61ffe"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">number_h_refinements</a></td></tr>
<tr class="separator:a4437c7888b7459952e06a9157bf61ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abff7ac97985f693cd3cc7a8311a24558"><td class="memItemLeft" align="right" valign="top">unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#abff7ac97985f693cd3cc7a8311a24558">number_p_refinements</a></td></tr>
<tr class="separator:abff7ac97985f693cd3cc7a8311a24558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d626496b0b6f99f679c4ef4f0a5e46e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1SystemNorm.html">SystemNorm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">error_norm</a></td></tr>
<tr class="separator:a9d626496b0b6f99f679c4ef4f0a5e46e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a3e03d60b2e3261e2485d3530ea8e0140"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1ErrorEstimator.html#a3e03d60b2e3261e2485d3530ea8e0140">reduce_error</a> (std::vector&lt; float &gt; &amp;error_per_cell, const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Parallel::Communicator</a> &amp;<a class="el" href="namespacelibMesh.html#ac58d93c086340dd1c4e8071081728d18">comm</a> LIBMESH_CAN_DEFAULT_TO_COMMWORLD) const </td></tr>
<tr class="separator:a3e03d60b2e3261e2485d3530ea8e0140"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:af635c66743cb57b7ffc0c16343055a8d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#af635c66743cb57b7ffc0c16343055a8d">computed_global_QoI_errors</a></td></tr>
<tr class="separator:af635c66743cb57b7ffc0c16343055a8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad51061a9299eba61c328edca03b0cd20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1QoISet.html">QoISet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a></td></tr>
<tr class="separator:ad51061a9299eba61c328edca03b0cd20"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implements a ``brute force'' goal-oriented error estimator which computes an estimate of error in a quantity of interest based on the residual of the current coarse grid primal solution as weighted against an adjoint solution on a uniformly refined (in h and/or p, for an arbitrary number of levels) grid.</p>
<dl class="section author"><dt>Author</dt><dd>Roy H. Stogner, 2009. </dd></dl>

<p>Definition at line <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00046">46</a> of file <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a838c11d53f37d85b33a827a355819c94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;std::pair&lt;const <a class="el" href="classlibMesh_1_1System.html">System</a>*, unsigned int&gt;, <a class="el" href="classlibMesh_1_1ErrorVector.html">ErrorVector</a>*&gt; <a class="el" href="classlibMesh_1_1ErrorEstimator.html#a838c11d53f37d85b33a827a355819c94">libMesh::ErrorEstimator::ErrorMap</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When calculating many error vectors at once, we need a data structure to hold them all </p>

<p>Definition at line <a class="el" href="error__estimator_8h_source.html#l00110">110</a> of file <a class="el" href="error__estimator_8h_source.html">error_estimator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="afcdf4f028e2e69d7457d052cb8b27540"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::AdjointRefinementEstimator::AdjointRefinementEstimator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. Sets the most common default parameter values. </p>

<p>Definition at line <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00053">53</a> of file <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a>.</p>

<p>References <a class="el" href="error__estimator_8h_source.html#l00142">libMesh::ErrorEstimator::error_norm</a>, and <a class="el" href="enum__norm__type_8h_source.html#l00063">libMesh::INVALID_NORM</a>.</p>
<div class="fragment"><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;                               :</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;    <a class="code" href="classlibMesh_1_1ErrorEstimator.html#ac4e2a7f658fb05f57ca690a42c2765fb">ErrorEstimator</a>(),</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;    <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">number_h_refinements</a>(1),</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;    <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#abff7ac97985f693cd3cc7a8311a24558">number_p_refinements</a>(0),</div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;    <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>(QoISet())</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;  {</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;    <span class="comment">// We&#39;re not actually going to use error_norm; our norms are</span></div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;    <span class="comment">// absolute values of QoI error.</span></div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;    <a class="code" href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">error_norm</a> = <a class="code" href="namespacelibMesh.html#acbb31be4fb2eb8a2a862c0c0b263948dad57b0f1b145c48bd9cafec20cca415bc">INVALID_NORM</a>;</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;  }</div>
<div class="ttc" id="classlibMesh_1_1ErrorEstimator_html_a9d626496b0b6f99f679c4ef4f0a5e46e"><div class="ttname"><a href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">libMesh::ErrorEstimator::error_norm</a></div><div class="ttdeci">SystemNorm error_norm</div><div class="ttdef"><b>Definition:</b> <a href="error__estimator_8h_source.html#l00142">error_estimator.h:142</a></div></div>
<div class="ttc" id="classlibMesh_1_1ErrorEstimator_html_ac4e2a7f658fb05f57ca690a42c2765fb"><div class="ttname"><a href="classlibMesh_1_1ErrorEstimator.html#ac4e2a7f658fb05f57ca690a42c2765fb">libMesh::ErrorEstimator::ErrorEstimator</a></div><div class="ttdeci">ErrorEstimator()</div><div class="ttdef"><b>Definition:</b> <a href="error__estimator_8h_source.html#l00061">error_estimator.h:61</a></div></div>
<div class="ttc" id="namespacelibMesh_html_acbb31be4fb2eb8a2a862c0c0b263948dad57b0f1b145c48bd9cafec20cca415bc"><div class="ttname"><a href="namespacelibMesh.html#acbb31be4fb2eb8a2a862c0c0b263948dad57b0f1b145c48bd9cafec20cca415bc">libMesh::INVALID_NORM</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__norm__type_8h_source.html#l00063">enum_norm_type.h:63</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_ad51061a9299eba61c328edca03b0cd20"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">libMesh::AdjointRefinementEstimator::_qoi_set</a></div><div class="ttdeci">QoISet _qoi_set</div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00140">adjoint_refinement_estimator.h:140</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_a4437c7888b7459952e06a9157bf61ffe"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">libMesh::AdjointRefinementEstimator::number_h_refinements</a></div><div class="ttdeci">unsigned char number_h_refinements</div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00114">adjoint_refinement_estimator.h:114</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_abff7ac97985f693cd3cc7a8311a24558"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#abff7ac97985f693cd3cc7a8311a24558">libMesh::AdjointRefinementEstimator::number_p_refinements</a></div><div class="ttdeci">unsigned char number_p_refinements</div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00119">adjoint_refinement_estimator.h:119</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="acfe91c49a0c78d780403574eeaee5b3a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">libMesh::AdjointRefinementEstimator::~AdjointRefinementEstimator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

<p>Definition at line <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00067">67</a> of file <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;{}</div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a88133f5a181d748fd67d537e37fb944c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::AdjointRefinementEstimator::estimate_error </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1System.html">System</a> &amp;&#160;</td>
          <td class="paramname"><em>system</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1ErrorVector.html">ErrorVector</a> &amp;&#160;</td>
          <td class="paramname"><em>error_per_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1NumericVector.html">NumericVector</a>&lt; <a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &gt; *&#160;</td>
          <td class="paramname"><em>solution_vector</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>estimate_parent_error</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function does uniform refinements and an adjoint solve to get an adjoint solution on each cell, then estimates the error by finding the weighted residual of the coarse solution with the fine adjoint solution.</p>
<p>system.solve() and system.assembly() must be called, and so should have no side effects.</p>
<p>Only the provided system is solved on the refined mesh; we don't support adjoint solves on loosely coupled collections of Systems.</p>
<p>The estimated error is output in the vector <code>error_per_cell</code> </p>

<p>Implements <a class="el" href="classlibMesh_1_1ErrorEstimator.html#a4e8751ba26dfeb9e692d92e10f1cbd28">libMesh::ErrorEstimator</a>.</p>

<p>Definition at line <a class="el" href="adjoint__refinement__estimator_8C_source.html#l00069">69</a> of file <a class="el" href="adjoint__refinement__estimator_8C_source.html">adjoint_refinement_estimator.C</a>.</p>

<p>References <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00140">_qoi_set</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a99742bad0b034a29ccae8c5a90c6f4aa">libMesh::MeshBase::active_local_elements_begin()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a2e27f54d33f7539c0c06b36adae36cda">libMesh::MeshBase::active_local_elements_end()</a>, <a class="el" href="system_8C_source.html#l00681">libMesh::System::add_vector()</a>, <a class="el" href="system_8h_source.html#l02205">libMesh::System::adjoint_solve()</a>, <a class="el" href="mesh__base_8h_source.html#l00539">libMesh::MeshBase::allow_renumbering()</a>, <a class="el" href="numeric__vector_8C_source.html#l00046">libMesh::NumericVector&lt; T &gt;::build()</a>, <a class="el" href="numeric__vector_8h_source.html#l00748">libMesh::NumericVector&lt; T &gt;::clear()</a>, <a class="el" href="classlibMesh_1_1NumericVector.html#a42ea91bba70b3e7b27dad2a636ad31ae">libMesh::NumericVector&lt; T &gt;::close()</a>, <a class="el" href="parallel__object_8h_source.html#l00086">libMesh::ParallelObject::comm()</a>, <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00124">computed_global_QoI_errors</a>, <a class="el" href="system_8h_source.html#l01518">libMesh::System::current_local_solution</a>, <a class="el" href="dof__map_8C_source.html#l01785">libMesh::DofMap::dof_indices()</a>, <a class="el" href="exact__error__estimator_8C_source.html#l00222">libMesh::dof_map</a>, <a class="el" href="classlibMesh_1_1NumericVector.html#a1f522c421b32b75ea4dc3de6d1a95000">libMesh::NumericVector&lt; T &gt;::dot()</a>, <a class="el" href="dof__map__constraints_8C_source.html#l01897">libMesh::DofMap::enforce_constraints_exactly()</a>, <a class="el" href="libmesh__common_8h_source.html#l00183">libMesh::ErrorVectorReal</a>, <a class="el" href="elem_8C_source.html#l00605">libMesh::Elem::find_point_neighbors()</a>, <a class="el" href="system_8C_source.html#l00988">libMesh::System::get_adjoint_solution()</a>, <a class="el" href="system_8h_source.html#l01968">libMesh::System::get_dof_map()</a>, <a class="el" href="system_8h_source.html#l00706">libMesh::System::get_equation_systems()</a>, <a class="el" href="equation__systems_8h_source.html#l00509">libMesh::EquationSystems::get_mesh()</a>, <a class="el" href="elem_8h_source.html#l01375">libMesh::Elem::get_node()</a>, <a class="el" href="dof__map_8h_source.html#l00316">libMesh::DofMap::get_send_list()</a>, <a class="el" href="system_8C_source.html#l00793">libMesh::System::get_vector()</a>, <a class="el" href="enum__parallel__type_8h_source.html#l00033">libMesh::GHOSTED</a>, <a class="el" href="dof__map__constraints_8C_source.html#l03784">libMesh::DofMap::has_adjoint_dirichlet_boundaries()</a>, <a class="el" href="qoi__set_8h_source.html#l00217">libMesh::QoISet::has_index()</a>, <a class="el" href="dof__object_8h_source.html#l00618">libMesh::DofObject::id()</a>, <a class="el" href="classlibMesh_1_1NumericVector.html#aa477345d6d326ea09134e32de003947c">libMesh::NumericVector&lt; T &gt;::init()</a>, <a class="el" href="namespacelibMesh.html#ac03a5d846eeb24a13168f6b5358f86e3">libMesh::libmesh_assert()</a>, <a class="el" href="libmesh__common_8h_source.html#l00149">libMesh::libmesh_real()</a>, <a class="el" href="classlibMesh_1_1NumericVector.html#a7348b5b027adf716016354847e0df0b6">libMesh::NumericVector&lt; T &gt;::localize()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a807e5541b5e0608c8847daf6f3ffc1cf">libMesh::MeshBase::max_elem_id()</a>, <a class="el" href="mesh__communication_8C_source.html#l00824">mesh</a>, <a class="el" href="system_8C_source.html#l00140">libMesh::System::n_dofs()</a>, <a class="el" href="classlibMesh_1_1MeshBase.html#a190e556d3be87f5ccd8d4fc98d1779d3">libMesh::MeshBase::n_elem()</a>, <a class="el" href="system_8C_source.html#l00177">libMesh::System::n_local_dofs()</a>, <a class="el" href="classlibMesh_1_1Elem.html#a3a1e00b1906b0f6cf0cc1760c9a7da1f">libMesh::Elem::n_nodes()</a>, <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00114">number_h_refinements</a>, <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00119">number_p_refinements</a>, <a class="el" href="elem_8h_source.html#l01654">libMesh::Elem::parent()</a>, <a class="el" href="mesh__base_8h_source.html#l00108">libMesh::MeshBase::partitioner()</a>, <a class="el" href="system_8h_source.html#l00788">libMesh::System::project_solution_on_reinit()</a>, <a class="el" href="system_8h_source.html#l01537">libMesh::System::qoi</a>, <a class="el" href="libmesh__common_8h_source.html#l00119">libMesh::Real</a>, <a class="el" href="error__estimator_8C_source.html#l00033">libMesh::ErrorEstimator::reduce_error()</a>, <a class="el" href="equation__systems_8C_source.html#l00131">libMesh::EquationSystems::reinit()</a>, <a class="el" href="system_8h_source.html#l01506">libMesh::System::solution</a>, <a class="el" href="numeric__vector_8h_source.html#l00851">libMesh::NumericVector&lt; T &gt;::swap()</a>, <a class="el" href="numeric__vector_8h_source.html#l00134">libMesh::NumericVector&lt; T &gt;::type()</a>, <a class="el" href="mesh__refinement_8C_source.html#l01766">libMesh::MeshRefinement::uniformly_coarsen()</a>, <a class="el" href="mesh__refinement_8C_source.html#l01716">libMesh::MeshRefinement::uniformly_p_coarsen()</a>, <a class="el" href="mesh__refinement_8C_source.html#l01697">libMesh::MeshRefinement::uniformly_p_refine()</a>, <a class="el" href="mesh__refinement_8C_source.html#l01738">libMesh::MeshRefinement::uniformly_refine()</a>, <a class="el" href="system_8C_source.html#l00412">libMesh::System::update()</a>, <a class="el" href="system_8h_source.html#l02156">libMesh::System::vectors_begin()</a>, <a class="el" href="system_8h_source.html#l02168">libMesh::System::vectors_end()</a>, and <a class="el" href="qoi__set_8h_source.html#l00236">libMesh::QoISet::weight()</a>.</p>
<div class="fragment"><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;{</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;  <span class="comment">// We have to break the rules here, because we can&#39;t refine a const System</span></div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;  System&amp; system = <span class="keyword">const_cast&lt;</span>System&amp;<span class="keyword">&gt;</span>(_system);</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;  <span class="comment">// An EquationSystems reference will be convenient.</span></div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;  EquationSystems&amp; es = system.get_equation_systems();</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;  <span class="comment">// The current mesh</span></div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;  MeshBase&amp; <a class="code" href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a> = es.get_mesh();</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;  <span class="comment">// Resize the error_per_cell vector to be</span></div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  <span class="comment">// the number of elements, initialized to 0.</span></div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;  error_per_cell.clear();</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;  error_per_cell.resize (mesh.max_elem_id(), 0.);</div>
<div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;</div>
<div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;  <span class="comment">// We&#39;ll want to back up all coarse grid vectors</span></div>
<div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;  std::map&lt;std::string, NumericVector&lt;Number&gt; *&gt; coarse_vectors;</div>
<div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classlibMesh_1_1System.html#a6a75b971c5614203f50d5a922df9253c">System::vectors_iterator</a> vec = system.vectors_begin(); vec !=</div>
<div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;         system.vectors_end(); ++vec)</div>
<div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;    {</div>
<div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;      <span class="comment">// The (string) name of this vector</span></div>
<div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;      <span class="keyword">const</span> std::string&amp; var_name = vec-&gt;first;</div>
<div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;</div>
<div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;      coarse_vectors[var_name] = vec-&gt;second-&gt;clone().release();</div>
<div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;    }</div>
<div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;  <span class="comment">// Back up the coarse solution and coarse local solution</span></div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  NumericVector&lt;Number&gt; * coarse_solution =</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;    system.solution-&gt;clone().release();</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;  NumericVector&lt;Number&gt; * coarse_local_solution =</div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;    system.current_local_solution-&gt;clone().release();</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;  <span class="comment">// And we&#39;ll need to temporarily change solution projection settings</span></div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;  <span class="keywordtype">bool</span> old_projection_setting;</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;  old_projection_setting = system.project_solution_on_reinit();</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;  <span class="comment">// Make sure the solution is projected when we refine the mesh</span></div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;  system.project_solution_on_reinit() = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;</div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;  <span class="comment">// And it&#39;ll be best to avoid any repartitioning</span></div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;  AutoPtr&lt;Partitioner&gt; old_partitioner = mesh.partitioner();</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;  mesh.partitioner().reset(NULL);</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;  <span class="comment">// And we can&#39;t allow any renumbering</span></div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;  <span class="keyword">const</span> <span class="keywordtype">bool</span> old_renumbering_setting = mesh.allow_renumbering();</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;  mesh.allow_renumbering(<span class="keyword">false</span>);</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;  <span class="comment">// Use a non-standard solution vector if necessary</span></div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;  <span class="keywordflow">if</span> (solution_vector &amp;&amp; solution_vector != system.solution.<a class="code" href="classlibMesh_1_1NumericVector.html#a1faf15332fde021fd0067d31cdad74e8">get</a>())</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;    {</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;      NumericVector&lt;Number&gt; *newsol =</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;        <span class="keyword">const_cast&lt;</span>NumericVector&lt;Number&gt;*<span class="keyword">&gt;</span> (solution_vector);</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;      newsol-&gt;swap(*system.solution);</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;      system.update();</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;    }</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;</div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;  <span class="comment">// Get coarse grid adjoint solutions.  This should be a relatively</span></div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;  <span class="comment">// quick (especially with preconditioner reuse) way to get a good</span></div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;  <span class="comment">// initial guess for the fine grid adjoint solutions.  More</span></div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;  <span class="comment">// importantly, subtracting off a coarse adjoint approximation gives</span></div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;  <span class="comment">// us better local error indication, and subtracting off *some* lift</span></div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;  <span class="comment">// function is necessary for correctness if we have heterogeneous</span></div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;  <span class="comment">// adjoint Dirichlet conditions.</span></div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;</div>
<div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;  <span class="comment">// Solve the adjoint problem(s) on the coarse FE space</span></div>
<div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;  system.adjoint_solve(<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>);</div>
<div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;</div>
<div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;</div>
<div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;  <span class="comment">// Loop over all the adjoint problems and, if any have heterogenous</span></div>
<div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;  <span class="comment">// Dirichlet conditions, get the corresponding coarse lift</span></div>
<div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;  <span class="comment">// function(s)</span></div>
<div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j != system.qoi.size(); j++)</div>
<div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;    {</div>
<div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;      <span class="comment">// Skip this QoI if it is not in the QoI Set or if there are no</span></div>
<div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;      <span class="comment">// heterogeneous Dirichlet boundaries for it</span></div>
<div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>.<a class="code" href="classlibMesh_1_1QoISet.html#adcfff89b353ad16cb93a89d7af779fc0">has_index</a>(j) &amp;&amp;</div>
<div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;          system.get_dof_map().has_adjoint_dirichlet_boundaries(j))</div>
<div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;        {</div>
<div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;          std::ostringstream liftfunc_name;</div>
<div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;          liftfunc_name &lt;&lt; <span class="stringliteral">&quot;adjoint_lift_function&quot;</span> &lt;&lt; j;</div>
<div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;          NumericVector&lt;Number&gt; &amp;liftvec =</div>
<div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;            system.add_vector(liftfunc_name.str());</div>
<div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;</div>
<div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;          system.get_dof_map().enforce_constraints_exactly</div>
<div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;            (system, &amp;liftvec, <span class="keyword">true</span>);</div>
<div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;        }</div>
<div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;    }</div>
<div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;</div>
<div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;<span class="preprocessor">#ifndef NDEBUG</span></div>
<div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;  <span class="comment">// n_coarse_elem is only used in an assertion later so</span></div>
<div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;  <span class="comment">// avoid declaring it unless asserts are active.</span></div>
<div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;  <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> n_coarse_elem = mesh.n_elem();</div>
<div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;<span class="preprocessor">#endif</span></div>
<div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;</div>
<div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;  <span class="comment">// Uniformly refine the mesh</span></div>
<div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;  MeshRefinement mesh_refinement(mesh);</div>
<div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;</div>
<div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;  <a class="code" href="namespacelibMesh.html#ac03a5d846eeb24a13168f6b5358f86e3">libmesh_assert</a> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">number_h_refinements</a> &gt; 0 || <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#abff7ac97985f693cd3cc7a8311a24558">number_p_refinements</a> &gt; 0);</div>
<div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;</div>
<div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;  <span class="comment">// FIXME: this may break if there is more than one System</span></div>
<div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;  <span class="comment">// on this mesh but estimate_error was still called instead of</span></div>
<div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;  <span class="comment">// estimate_errors</span></div>
<div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i != <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">number_h_refinements</a>; ++i)</div>
<div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;    {</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;      mesh_refinement.uniformly_refine(1);</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;      es.reinit();</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;    }</div>
<div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;</div>
<div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i != <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#abff7ac97985f693cd3cc7a8311a24558">number_p_refinements</a>; ++i)</div>
<div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;    {</div>
<div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;      mesh_refinement.uniformly_p_refine(1);</div>
<div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;      es.reinit();</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;    }</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;</div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;  <span class="comment">// Copy the projected coarse grid solutions, which will be</span></div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;  <span class="comment">// overwritten by solve()</span></div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;  std::vector&lt;NumericVector&lt;Number&gt; *&gt; coarse_adjoints;</div>
<div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j != system.qoi.size(); j++)</div>
<div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;    {</div>
<div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>.<a class="code" href="classlibMesh_1_1QoISet.html#adcfff89b353ad16cb93a89d7af779fc0">has_index</a>(j))</div>
<div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;        {</div>
<div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;          NumericVector&lt;Number&gt; *coarse_adjoint =</div>
<div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;            <a class="code" href="classlibMesh_1_1NumericVector.html#a57578a53c85eb3b003df5ca4249bdef5">NumericVector&lt;Number&gt;::build</a>(mesh.comm()).release();</div>
<div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;</div>
<div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;          <span class="comment">// Can do &quot;fast&quot; init since we&#39;re overwriting this in a sec</span></div>
<div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;          coarse_adjoint-&gt;init(system.solution-&gt;size(),</div>
<div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;                               system.solution-&gt;local_size(),</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;                               <span class="keyword">true</span>,</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;                               system.get_adjoint_solution(j).type());</div>
<div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;</div>
<div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;          *coarse_adjoint = system.get_adjoint_solution(j);</div>
<div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;</div>
<div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;          coarse_adjoints.push_back(coarse_adjoint);</div>
<div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;        }</div>
<div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;        coarse_adjoints.push_back(NULL);</div>
<div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;    }</div>
<div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;</div>
<div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;  <span class="comment">// Rebuild the rhs with the projected primal solution</span></div>
<div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;  (<span class="keyword">dynamic_cast&lt;</span>ImplicitSystem&amp;<span class="keyword">&gt;</span>(system)).assembly(<span class="keyword">true</span>, <span class="keyword">false</span>);</div>
<div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;  NumericVector&lt;Number&gt; &amp; projected_residual = (<span class="keyword">dynamic_cast&lt;</span>ExplicitSystem&amp;<span class="keyword">&gt;</span>(system)).get_vector(<span class="stringliteral">&quot;RHS Vector&quot;</span>);</div>
<div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;  projected_residual.close();</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;  <span class="comment">// Solve the adjoint problem(s) on the refined FE space</span></div>
<div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;  system.adjoint_solve(<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>);</div>
<div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;</div>
<div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;  <span class="comment">// Now that we have the refined adjoint solution and the projected primal solution,</span></div>
<div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;  <span class="comment">// we first compute the global QoI error estimate</span></div>
<div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;</div>
<div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;  <span class="comment">// Resize the computed_global_QoI_errors vector to hold the error estimates for each QoI</span></div>
<div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;  <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af635c66743cb57b7ffc0c16343055a8d">computed_global_QoI_errors</a>.resize(system.qoi.size());</div>
<div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;</div>
<div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;  <span class="comment">// Loop over all the adjoint solutions and get the QoI error</span></div>
<div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;  <span class="comment">// contributions from all of them.  While we&#39;re looping anyway we&#39;ll</span></div>
<div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;  <span class="comment">// pull off the coarse adjoints</span></div>
<div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j != system.qoi.size(); j++)</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    {</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;      <span class="comment">// Skip this QoI if not in the QoI Set</span></div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>.<a class="code" href="classlibMesh_1_1QoISet.html#adcfff89b353ad16cb93a89d7af779fc0">has_index</a>(j))</div>
<div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;        {</div>
<div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;          <span class="comment">// If the adjoint solution has heterogeneous dirichlet</span></div>
<div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;          <span class="comment">// values, then to get a proper error estimate here we need</span></div>
<div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;          <span class="comment">// to subtract off a coarse grid lift function.  In any case</span></div>
<div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;          <span class="comment">// we can get a better error estimate by separating off a</span></div>
<div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;          <span class="comment">// coarse representation of the adjoint solution, so we&#39;ll</span></div>
<div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;          <span class="comment">// use that for our lift function.</span></div>
<div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;          system.get_adjoint_solution(j) -= *coarse_adjoints[j];</div>
<div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;</div>
<div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;          <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af635c66743cb57b7ffc0c16343055a8d">computed_global_QoI_errors</a>[j] = projected_residual.dot(system.get_adjoint_solution(j));</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;        }</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    }</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;  <span class="comment">// Done with the global error estimates, now construct the element wise error indicators</span></div>
<div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;  <span class="comment">// We ought to account for &#39;spill-over&#39; effects while computing the</span></div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;  <span class="comment">// element error indicators This happens because the same dof is</span></div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;  <span class="comment">// shared by multiple elements, one way of mitigating this is to</span></div>
<div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;  <span class="comment">// scale the contribution from each dof by the number of elements it</span></div>
<div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;  <span class="comment">// belongs to We first obtain the number of elements each node</span></div>
<div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;  <span class="comment">// belongs to</span></div>
<div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;</div>
<div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;  <span class="comment">// A map that relates a node id to an int that will tell us how many elements it is a node of</span></div>
<div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;  LIBMESH_BEST_UNORDERED_MAP&lt;dof_id_type, unsigned int&gt;shared_element_count;</div>
<div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;  <span class="comment">// To fill this map, we will loop over elements, and then in each element, we will loop</span></div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;  <span class="comment">// over the nodes each element contains, and then query it for the number of coarse</span></div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;  <span class="comment">// grid elements it was a node of</span></div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;  <span class="comment">// Keep track of which nodes we have already dealt with</span></div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;  LIBMESH_BEST_UNORDERED_SET&lt;dof_id_type&gt; processed_node_ids;</div>
<div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;</div>
<div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;  <span class="comment">// We will be iterating over all the active elements in the fine mesh that live on</span></div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;  <span class="comment">// this processor</span></div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;  {</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;    MeshBase::const_element_iterator elem_it = mesh.active_local_elements_begin();</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;    <span class="keyword">const</span> MeshBase::const_element_iterator elem_end = mesh.active_local_elements_end();</div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;    <span class="comment">// Start loop over elems</span></div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;    <span class="keywordflow">for</span>(; elem_it != elem_end; ++elem_it)</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;      {</div>
<div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;        <span class="comment">// Pointer to this element</span></div>
<div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;        <span class="keyword">const</span> Elem* elem = *elem_it;</div>
<div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;</div>
<div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;        <span class="comment">// Loop over the nodes in the element</span></div>
<div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;        <span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n=0; n != elem-&gt;n_nodes(); ++n)</div>
<div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;          {</div>
<div class="line"><a name="l00281"></a><span class="lineno">  281</span>&#160;            <span class="comment">// Get a pointer to the current node</span></div>
<div class="line"><a name="l00282"></a><span class="lineno">  282</span>&#160;            Node* node = elem-&gt;get_node(n);</div>
<div class="line"><a name="l00283"></a><span class="lineno">  283</span>&#160;</div>
<div class="line"><a name="l00284"></a><span class="lineno">  284</span>&#160;            <span class="comment">// Get the id of this node</span></div>
<div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;            <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> node_id = node-&gt;id();</div>
<div class="line"><a name="l00286"></a><span class="lineno">  286</span>&#160;</div>
<div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;            <span class="comment">// If we havent already processed this node, do so now</span></div>
<div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;            <span class="keywordflow">if</span>(processed_node_ids.find(node_id) == processed_node_ids.end())</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;              {</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;                <span class="comment">// Declare a neighbor_set to be filled by the find_point_neighbors</span></div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;                std::set&lt;const Elem *&gt; fine_grid_neighbor_set;</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;                <span class="comment">// Call find_point_neighbors to fill the neighbor_set</span></div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;                elem-&gt;find_point_neighbors(*node, fine_grid_neighbor_set);</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;</div>
<div class="line"><a name="l00296"></a><span class="lineno">  296</span>&#160;                <span class="comment">// A vector to hold the coarse grid parents neighbors</span></div>
<div class="line"><a name="l00297"></a><span class="lineno">  297</span>&#160;                std::vector&lt;dof_id_type&gt; coarse_grid_neighbors;</div>
<div class="line"><a name="l00298"></a><span class="lineno">  298</span>&#160;</div>
<div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;                <span class="comment">// Iterators over the fine grid neighbors set</span></div>
<div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;                std::set&lt;const Elem*&gt;::iterator fine_neighbor_it = fine_grid_neighbor_set.begin();</div>
<div class="line"><a name="l00301"></a><span class="lineno">  301</span>&#160;                <span class="keyword">const</span> std::set&lt;const Elem*&gt;::iterator fine_neighbor_end = fine_grid_neighbor_set.end();</div>
<div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;</div>
<div class="line"><a name="l00303"></a><span class="lineno">  303</span>&#160;                <span class="comment">// Loop over all the fine neighbors of this node</span></div>
<div class="line"><a name="l00304"></a><span class="lineno">  304</span>&#160;                <span class="keywordflow">for</span>(; fine_neighbor_it != fine_neighbor_end ; ++fine_neighbor_it)</div>
<div class="line"><a name="l00305"></a><span class="lineno">  305</span>&#160;                  {</div>
<div class="line"><a name="l00306"></a><span class="lineno">  306</span>&#160;                    <span class="comment">// Pointer to the current fine neighbor element</span></div>
<div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;                    <span class="keyword">const</span> Elem* fine_elem = *fine_neighbor_it;</div>
<div class="line"><a name="l00308"></a><span class="lineno">  308</span>&#160;</div>
<div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;                    <span class="comment">// Find the element id for the corresponding coarse grid element</span></div>
<div class="line"><a name="l00310"></a><span class="lineno">  310</span>&#160;                    <span class="keyword">const</span> Elem* coarse_elem = fine_elem;</div>
<div class="line"><a name="l00311"></a><span class="lineno">  311</span>&#160;                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j != <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">number_h_refinements</a>; ++j)</div>
<div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;                      {</div>
<div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;                        <a class="code" href="namespacelibMesh.html#ac03a5d846eeb24a13168f6b5358f86e3">libmesh_assert</a> (coarse_elem-&gt;parent());</div>
<div class="line"><a name="l00314"></a><span class="lineno">  314</span>&#160;</div>
<div class="line"><a name="l00315"></a><span class="lineno">  315</span>&#160;                        coarse_elem = coarse_elem-&gt;parent();</div>
<div class="line"><a name="l00316"></a><span class="lineno">  316</span>&#160;                      }</div>
<div class="line"><a name="l00317"></a><span class="lineno">  317</span>&#160;</div>
<div class="line"><a name="l00318"></a><span class="lineno">  318</span>&#160;                    <span class="comment">// Loop over the existing coarse neighbors and check if this one is</span></div>
<div class="line"><a name="l00319"></a><span class="lineno">  319</span>&#160;                    <span class="comment">// already in there</span></div>
<div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;                    <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> coarse_id = coarse_elem-&gt;id();</div>
<div class="line"><a name="l00321"></a><span class="lineno">  321</span>&#160;                    std::size_t j = 0;</div>
<div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;                    <span class="keywordflow">for</span> (; j != coarse_grid_neighbors.size(); j++)</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;                      {</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;                        <span class="comment">// If the set already contains this element break out of the loop</span></div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;                        <span class="keywordflow">if</span>(coarse_grid_neighbors[j] == coarse_id)</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;                          {</div>
<div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;                            <span class="keywordflow">break</span>;</div>
<div class="line"><a name="l00328"></a><span class="lineno">  328</span>&#160;                          }</div>
<div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;                      }</div>
<div class="line"><a name="l00330"></a><span class="lineno">  330</span>&#160;</div>
<div class="line"><a name="l00331"></a><span class="lineno">  331</span>&#160;                    <span class="comment">// If we didn&#39;t leave the loop even at the last element,</span></div>
<div class="line"><a name="l00332"></a><span class="lineno">  332</span>&#160;                    <span class="comment">// this is a new neighbour, put in the coarse_grid_neighbor_set</span></div>
<div class="line"><a name="l00333"></a><span class="lineno">  333</span>&#160;                    <span class="keywordflow">if</span>(j == coarse_grid_neighbors.size())</div>
<div class="line"><a name="l00334"></a><span class="lineno">  334</span>&#160;                      {</div>
<div class="line"><a name="l00335"></a><span class="lineno">  335</span>&#160;                        coarse_grid_neighbors.push_back(coarse_id);</div>
<div class="line"><a name="l00336"></a><span class="lineno">  336</span>&#160;                      }</div>
<div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;                  } <span class="comment">// End loop over fine neighbors</span></div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;                <span class="comment">// Set the shared_neighbour index for this node to the</span></div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;                <span class="comment">// size of the coarse grid neighbor set</span></div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;                shared_element_count[node_id] =</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;                  cast_int&lt;unsigned int&gt;(coarse_grid_neighbors.size());</div>
<div class="line"><a name="l00344"></a><span class="lineno">  344</span>&#160;</div>
<div class="line"><a name="l00345"></a><span class="lineno">  345</span>&#160;                <span class="comment">// Add this node to processed_node_ids vector</span></div>
<div class="line"><a name="l00346"></a><span class="lineno">  346</span>&#160;                processed_node_ids.insert(node_id);</div>
<div class="line"><a name="l00347"></a><span class="lineno">  347</span>&#160;</div>
<div class="line"><a name="l00348"></a><span class="lineno">  348</span>&#160;              } <span class="comment">// End if not processed node</span></div>
<div class="line"><a name="l00349"></a><span class="lineno">  349</span>&#160;</div>
<div class="line"><a name="l00350"></a><span class="lineno">  350</span>&#160;          } <span class="comment">// End loop over nodes</span></div>
<div class="line"><a name="l00351"></a><span class="lineno">  351</span>&#160;</div>
<div class="line"><a name="l00352"></a><span class="lineno">  352</span>&#160;      }  <span class="comment">// End loop over elems</span></div>
<div class="line"><a name="l00353"></a><span class="lineno">  353</span>&#160;  }</div>
<div class="line"><a name="l00354"></a><span class="lineno">  354</span>&#160;</div>
<div class="line"><a name="l00355"></a><span class="lineno">  355</span>&#160;  <span class="comment">// Get a DoF map, will be used to get the nodal dof_indices for each element</span></div>
<div class="line"><a name="l00356"></a><span class="lineno">  356</span>&#160;  DofMap &amp;<a class="code" href="namespacelibMesh.html#a39353fe8a8facf9ff79837b89ea15170">dof_map</a> = system.get_dof_map();</div>
<div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;</div>
<div class="line"><a name="l00358"></a><span class="lineno">  358</span>&#160;  <span class="comment">// The global DOF indices, we will use these later on when we compute the element wise indicators</span></div>
<div class="line"><a name="l00359"></a><span class="lineno">  359</span>&#160;  std::vector&lt;dof_id_type&gt; dof_indices;</div>
<div class="line"><a name="l00360"></a><span class="lineno">  360</span>&#160;</div>
<div class="line"><a name="l00361"></a><span class="lineno">  361</span>&#160;  <span class="comment">// Localize the global rhs and adjoint solution vectors (which might be shared on multiple processsors) onto a</span></div>
<div class="line"><a name="l00362"></a><span class="lineno">  362</span>&#160;  <span class="comment">// local ghosted vector, this ensures each processor has all the dof_indices to compute an error indicator for</span></div>
<div class="line"><a name="l00363"></a><span class="lineno">  363</span>&#160;  <span class="comment">// an element it owns</span></div>
<div class="line"><a name="l00364"></a><span class="lineno">  364</span>&#160;  AutoPtr&lt;NumericVector&lt;Number&gt; &gt; localized_projected_residual = <a class="code" href="classlibMesh_1_1NumericVector.html#a57578a53c85eb3b003df5ca4249bdef5">NumericVector&lt;Number&gt;::build</a>(system.comm());</div>
<div class="line"><a name="l00365"></a><span class="lineno">  365</span>&#160;  localized_projected_residual-&gt;init(system.n_dofs(), system.n_local_dofs(), system.get_dof_map().get_send_list(), <span class="keyword">false</span>, <a class="code" href="namespacelibMesh.html#a29f261e38c002cf7661170b0fa4e8c74a7ad89a14059d5c662d16a35675f8370d">GHOSTED</a>);</div>
<div class="line"><a name="l00366"></a><span class="lineno">  366</span>&#160;  projected_residual.localize(*localized_projected_residual, system.get_dof_map().get_send_list());</div>
<div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;  <span class="comment">// Each adjoint solution will also require ghosting; for efficiency we&#39;ll reuse the same memory</span></div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;  AutoPtr&lt;NumericVector&lt;Number&gt; &gt; localized_adjoint_solution = <a class="code" href="classlibMesh_1_1NumericVector.html#a57578a53c85eb3b003df5ca4249bdef5">NumericVector&lt;Number&gt;::build</a>(system.comm());</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;  localized_adjoint_solution-&gt;init(system.n_dofs(), system.n_local_dofs(), system.get_dof_map().get_send_list(), <span class="keyword">false</span>, <a class="code" href="namespacelibMesh.html#a29f261e38c002cf7661170b0fa4e8c74a7ad89a14059d5c662d16a35675f8370d">GHOSTED</a>);</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;  <span class="comment">// We will loop over each adjoint solution, localize that adjoint</span></div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;  <span class="comment">// solution and then loop over local elements</span></div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i != system.qoi.size(); i++)</div>
<div class="line"><a name="l00375"></a><span class="lineno">  375</span>&#160;    {</div>
<div class="line"><a name="l00376"></a><span class="lineno">  376</span>&#160;      <span class="comment">// Skip this QoI if not in the QoI Set</span></div>
<div class="line"><a name="l00377"></a><span class="lineno">  377</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>.<a class="code" href="classlibMesh_1_1QoISet.html#adcfff89b353ad16cb93a89d7af779fc0">has_index</a>(i))</div>
<div class="line"><a name="l00378"></a><span class="lineno">  378</span>&#160;        {</div>
<div class="line"><a name="l00379"></a><span class="lineno">  379</span>&#160;          <span class="comment">// Get the weight for the current QoI</span></div>
<div class="line"><a name="l00380"></a><span class="lineno">  380</span>&#160;          <a class="code" href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">Real</a> error_weight = <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>.<a class="code" href="classlibMesh_1_1QoISet.html#abfcf1c89b78ec1ff01f3b6064b910401">weight</a>(i);</div>
<div class="line"><a name="l00381"></a><span class="lineno">  381</span>&#160;</div>
<div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;          (system.get_adjoint_solution(i)).localize(*localized_adjoint_solution, system.get_dof_map().get_send_list());</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;          <span class="comment">// Loop over elements</span></div>
<div class="line"><a name="l00385"></a><span class="lineno">  385</span>&#160;          MeshBase::const_element_iterator elem_it = mesh.active_local_elements_begin();</div>
<div class="line"><a name="l00386"></a><span class="lineno">  386</span>&#160;          <span class="keyword">const</span> MeshBase::const_element_iterator elem_end = mesh.active_local_elements_end();</div>
<div class="line"><a name="l00387"></a><span class="lineno">  387</span>&#160;</div>
<div class="line"><a name="l00388"></a><span class="lineno">  388</span>&#160;          <span class="keywordflow">for</span>(; elem_it != elem_end; ++elem_it)</div>
<div class="line"><a name="l00389"></a><span class="lineno">  389</span>&#160;            {</div>
<div class="line"><a name="l00390"></a><span class="lineno">  390</span>&#160;              <span class="comment">// Pointer to the element</span></div>
<div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;              <span class="keyword">const</span> Elem* elem = *elem_it;</div>
<div class="line"><a name="l00392"></a><span class="lineno">  392</span>&#160;</div>
<div class="line"><a name="l00393"></a><span class="lineno">  393</span>&#160;              <span class="comment">// Go up number_h_refinements levels up to find the coarse parent</span></div>
<div class="line"><a name="l00394"></a><span class="lineno">  394</span>&#160;              <span class="keyword">const</span> Elem* coarse = elem;</div>
<div class="line"><a name="l00395"></a><span class="lineno">  395</span>&#160;</div>
<div class="line"><a name="l00396"></a><span class="lineno">  396</span>&#160;              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j != <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">number_h_refinements</a>; ++j)</div>
<div class="line"><a name="l00397"></a><span class="lineno">  397</span>&#160;                {</div>
<div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;                  <a class="code" href="namespacelibMesh.html#ac03a5d846eeb24a13168f6b5358f86e3">libmesh_assert</a> (coarse-&gt;parent());</div>
<div class="line"><a name="l00399"></a><span class="lineno">  399</span>&#160;</div>
<div class="line"><a name="l00400"></a><span class="lineno">  400</span>&#160;                  coarse = coarse-&gt;parent();</div>
<div class="line"><a name="l00401"></a><span class="lineno">  401</span>&#160;                }</div>
<div class="line"><a name="l00402"></a><span class="lineno">  402</span>&#160;</div>
<div class="line"><a name="l00403"></a><span class="lineno">  403</span>&#160;              <span class="keyword">const</span> <a class="code" href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">dof_id_type</a> e_id = coarse-&gt;id();</div>
<div class="line"><a name="l00404"></a><span class="lineno">  404</span>&#160;</div>
<div class="line"><a name="l00405"></a><span class="lineno">  405</span>&#160;              <span class="comment">// Get the local to global degree of freedom maps for this element</span></div>
<div class="line"><a name="l00406"></a><span class="lineno">  406</span>&#160;              dof_map.dof_indices (elem, dof_indices);</div>
<div class="line"><a name="l00407"></a><span class="lineno">  407</span>&#160;</div>
<div class="line"><a name="l00408"></a><span class="lineno">  408</span>&#160;              <span class="comment">// We will have to manually do the dot products.</span></div>
<div class="line"><a name="l00409"></a><span class="lineno">  409</span>&#160;              <a class="code" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> local_contribution = 0.;</div>
<div class="line"><a name="l00410"></a><span class="lineno">  410</span>&#160;</div>
<div class="line"><a name="l00411"></a><span class="lineno">  411</span>&#160;              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j != dof_indices.size(); j++)</div>
<div class="line"><a name="l00412"></a><span class="lineno">  412</span>&#160;                {</div>
<div class="line"><a name="l00413"></a><span class="lineno">  413</span>&#160;                  <span class="comment">// The contribution to the error indicator for this element from the current QoI</span></div>
<div class="line"><a name="l00414"></a><span class="lineno">  414</span>&#160;                  local_contribution += (*localized_projected_residual)(dof_indices[j]) * (*localized_adjoint_solution)(dof_indices[j]);</div>
<div class="line"><a name="l00415"></a><span class="lineno">  415</span>&#160;                }</div>
<div class="line"><a name="l00416"></a><span class="lineno">  416</span>&#160;</div>
<div class="line"><a name="l00417"></a><span class="lineno">  417</span>&#160;              <span class="comment">// Multiply by the error weight for this QoI</span></div>
<div class="line"><a name="l00418"></a><span class="lineno">  418</span>&#160;              local_contribution *= error_weight;</div>
<div class="line"><a name="l00419"></a><span class="lineno">  419</span>&#160;</div>
<div class="line"><a name="l00420"></a><span class="lineno">  420</span>&#160;              <span class="comment">// FIXME: we&#39;re throwing away information in the</span></div>
<div class="line"><a name="l00421"></a><span class="lineno">  421</span>&#160;              <span class="comment">// --enable-complex case</span></div>
<div class="line"><a name="l00422"></a><span class="lineno">  422</span>&#160;              error_per_cell[e_id] += <span class="keyword">static_cast&lt;</span><a class="code" href="namespacelibMesh.html#a26acf05f075521cbfb223db57e63d6d0">ErrorVectorReal</a><span class="keyword">&gt;</span></div>
<div class="line"><a name="l00423"></a><span class="lineno">  423</span>&#160;                (<a class="code" href="namespacelibMesh.html#a4f64766e155cef44a8f66b8411b3725a">libmesh_real</a>(local_contribution));</div>
<div class="line"><a name="l00424"></a><span class="lineno">  424</span>&#160;</div>
<div class="line"><a name="l00425"></a><span class="lineno">  425</span>&#160;            } <span class="comment">// End loop over elements</span></div>
<div class="line"><a name="l00426"></a><span class="lineno">  426</span>&#160;</div>
<div class="line"><a name="l00427"></a><span class="lineno">  427</span>&#160;        } <span class="comment">// End if belong to QoI set</span></div>
<div class="line"><a name="l00428"></a><span class="lineno">  428</span>&#160;</div>
<div class="line"><a name="l00429"></a><span class="lineno">  429</span>&#160;    } <span class="comment">// End loop over QoIs</span></div>
<div class="line"><a name="l00430"></a><span class="lineno">  430</span>&#160;</div>
<div class="line"><a name="l00431"></a><span class="lineno">  431</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j != system.qoi.size(); j++)</div>
<div class="line"><a name="l00432"></a><span class="lineno">  432</span>&#160;    {</div>
<div class="line"><a name="l00433"></a><span class="lineno">  433</span>&#160;      <span class="keywordflow">if</span> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>.<a class="code" href="classlibMesh_1_1QoISet.html#adcfff89b353ad16cb93a89d7af779fc0">has_index</a>(j))</div>
<div class="line"><a name="l00434"></a><span class="lineno">  434</span>&#160;        {</div>
<div class="line"><a name="l00435"></a><span class="lineno">  435</span>&#160;          <span class="keyword">delete</span> coarse_adjoints[j];</div>
<div class="line"><a name="l00436"></a><span class="lineno">  436</span>&#160;        }</div>
<div class="line"><a name="l00437"></a><span class="lineno">  437</span>&#160;    }</div>
<div class="line"><a name="l00438"></a><span class="lineno">  438</span>&#160;</div>
<div class="line"><a name="l00439"></a><span class="lineno">  439</span>&#160;  <span class="comment">// Don&#39;t bother projecting the solution; we&#39;ll restore from backup</span></div>
<div class="line"><a name="l00440"></a><span class="lineno">  440</span>&#160;  <span class="comment">// after coarsening</span></div>
<div class="line"><a name="l00441"></a><span class="lineno">  441</span>&#160;  system.project_solution_on_reinit() = <span class="keyword">false</span>;</div>
<div class="line"><a name="l00442"></a><span class="lineno">  442</span>&#160;</div>
<div class="line"><a name="l00443"></a><span class="lineno">  443</span>&#160;  <span class="comment">// Uniformly coarsen the mesh, without projecting the solution</span></div>
<div class="line"><a name="l00444"></a><span class="lineno">  444</span>&#160;  <a class="code" href="namespacelibMesh.html#ac03a5d846eeb24a13168f6b5358f86e3">libmesh_assert</a> (<a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">number_h_refinements</a> &gt; 0 || <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#abff7ac97985f693cd3cc7a8311a24558">number_p_refinements</a> &gt; 0);</div>
<div class="line"><a name="l00445"></a><span class="lineno">  445</span>&#160;</div>
<div class="line"><a name="l00446"></a><span class="lineno">  446</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i != <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">number_h_refinements</a>; ++i)</div>
<div class="line"><a name="l00447"></a><span class="lineno">  447</span>&#160;    {</div>
<div class="line"><a name="l00448"></a><span class="lineno">  448</span>&#160;      mesh_refinement.uniformly_coarsen(1);</div>
<div class="line"><a name="l00449"></a><span class="lineno">  449</span>&#160;      <span class="comment">// FIXME - should the reinits here be necessary? - RHS</span></div>
<div class="line"><a name="l00450"></a><span class="lineno">  450</span>&#160;      es.reinit();</div>
<div class="line"><a name="l00451"></a><span class="lineno">  451</span>&#160;    }</div>
<div class="line"><a name="l00452"></a><span class="lineno">  452</span>&#160;</div>
<div class="line"><a name="l00453"></a><span class="lineno">  453</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i != <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#abff7ac97985f693cd3cc7a8311a24558">number_p_refinements</a>; ++i)</div>
<div class="line"><a name="l00454"></a><span class="lineno">  454</span>&#160;    {</div>
<div class="line"><a name="l00455"></a><span class="lineno">  455</span>&#160;      mesh_refinement.uniformly_p_coarsen(1);</div>
<div class="line"><a name="l00456"></a><span class="lineno">  456</span>&#160;      es.reinit();</div>
<div class="line"><a name="l00457"></a><span class="lineno">  457</span>&#160;    }</div>
<div class="line"><a name="l00458"></a><span class="lineno">  458</span>&#160;</div>
<div class="line"><a name="l00459"></a><span class="lineno">  459</span>&#160;  <span class="comment">// We should be back where we started</span></div>
<div class="line"><a name="l00460"></a><span class="lineno">  460</span>&#160;  libmesh_assert_equal_to (n_coarse_elem, mesh.n_elem());</div>
<div class="line"><a name="l00461"></a><span class="lineno">  461</span>&#160;</div>
<div class="line"><a name="l00462"></a><span class="lineno">  462</span>&#160;  <span class="comment">// Restore old solutions and clean up the heap</span></div>
<div class="line"><a name="l00463"></a><span class="lineno">  463</span>&#160;  system.project_solution_on_reinit() = old_projection_setting;</div>
<div class="line"><a name="l00464"></a><span class="lineno">  464</span>&#160;</div>
<div class="line"><a name="l00465"></a><span class="lineno">  465</span>&#160;  <span class="comment">// Restore the coarse solution vectors and delete their copies</span></div>
<div class="line"><a name="l00466"></a><span class="lineno">  466</span>&#160;  *system.solution = *coarse_solution;</div>
<div class="line"><a name="l00467"></a><span class="lineno">  467</span>&#160;  <span class="keyword">delete</span> coarse_solution;</div>
<div class="line"><a name="l00468"></a><span class="lineno">  468</span>&#160;  *system.current_local_solution = *coarse_local_solution;</div>
<div class="line"><a name="l00469"></a><span class="lineno">  469</span>&#160;  <span class="keyword">delete</span> coarse_local_solution;</div>
<div class="line"><a name="l00470"></a><span class="lineno">  470</span>&#160;</div>
<div class="line"><a name="l00471"></a><span class="lineno">  471</span>&#160;  <span class="keywordflow">for</span> (<a class="code" href="classlibMesh_1_1System.html#a6a75b971c5614203f50d5a922df9253c">System::vectors_iterator</a> vec = system.vectors_begin(); vec !=</div>
<div class="line"><a name="l00472"></a><span class="lineno">  472</span>&#160;         system.vectors_end(); ++vec)</div>
<div class="line"><a name="l00473"></a><span class="lineno">  473</span>&#160;    {</div>
<div class="line"><a name="l00474"></a><span class="lineno">  474</span>&#160;      <span class="comment">// The (string) name of this vector</span></div>
<div class="line"><a name="l00475"></a><span class="lineno">  475</span>&#160;      <span class="keyword">const</span> std::string&amp; var_name = vec-&gt;first;</div>
<div class="line"><a name="l00476"></a><span class="lineno">  476</span>&#160;</div>
<div class="line"><a name="l00477"></a><span class="lineno">  477</span>&#160;      <span class="comment">// If it&#39;s a vector we already had (and not a newly created</span></div>
<div class="line"><a name="l00478"></a><span class="lineno">  478</span>&#160;      <span class="comment">// vector like an adjoint rhs), we need to restore it.</span></div>
<div class="line"><a name="l00479"></a><span class="lineno">  479</span>&#160;      std::map&lt;std::string, NumericVector&lt;Number&gt; *&gt;::iterator it =</div>
<div class="line"><a name="l00480"></a><span class="lineno">  480</span>&#160;        coarse_vectors.find(var_name);</div>
<div class="line"><a name="l00481"></a><span class="lineno">  481</span>&#160;      <span class="keywordflow">if</span> (it != coarse_vectors.end())</div>
<div class="line"><a name="l00482"></a><span class="lineno">  482</span>&#160;        {</div>
<div class="line"><a name="l00483"></a><span class="lineno">  483</span>&#160;          NumericVector&lt;Number&gt; *coarsevec = it-&gt;second;</div>
<div class="line"><a name="l00484"></a><span class="lineno">  484</span>&#160;          system.get_vector(var_name) = *coarsevec;</div>
<div class="line"><a name="l00485"></a><span class="lineno">  485</span>&#160;</div>
<div class="line"><a name="l00486"></a><span class="lineno">  486</span>&#160;          coarsevec-&gt;clear();</div>
<div class="line"><a name="l00487"></a><span class="lineno">  487</span>&#160;          <span class="keyword">delete</span> coarsevec;</div>
<div class="line"><a name="l00488"></a><span class="lineno">  488</span>&#160;        }</div>
<div class="line"><a name="l00489"></a><span class="lineno">  489</span>&#160;    }</div>
<div class="line"><a name="l00490"></a><span class="lineno">  490</span>&#160;</div>
<div class="line"><a name="l00491"></a><span class="lineno">  491</span>&#160;  <span class="comment">// Restore old partitioner and renumbering settings</span></div>
<div class="line"><a name="l00492"></a><span class="lineno">  492</span>&#160;  mesh.partitioner() = old_partitioner;</div>
<div class="line"><a name="l00493"></a><span class="lineno">  493</span>&#160;  mesh.allow_renumbering(old_renumbering_setting);</div>
<div class="line"><a name="l00494"></a><span class="lineno">  494</span>&#160;</div>
<div class="line"><a name="l00495"></a><span class="lineno">  495</span>&#160;  <span class="comment">// Fiinally sum the vector of estimated error values.</span></div>
<div class="line"><a name="l00496"></a><span class="lineno">  496</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#a3e03d60b2e3261e2485d3530ea8e0140">reduce_error</a>(error_per_cell, system.comm());</div>
<div class="line"><a name="l00497"></a><span class="lineno">  497</span>&#160;</div>
<div class="line"><a name="l00498"></a><span class="lineno">  498</span>&#160;  <span class="comment">// We don&#39;t take a square root here; this is a goal-oriented</span></div>
<div class="line"><a name="l00499"></a><span class="lineno">  499</span>&#160;  <span class="comment">// estimate not a Hilbert norm estimate.</span></div>
<div class="line"><a name="l00500"></a><span class="lineno">  500</span>&#160;} <span class="comment">// end estimate_error function</span></div>
<div class="ttc" id="namespacelibMesh_html_a4f64766e155cef44a8f66b8411b3725a"><div class="ttname"><a href="namespacelibMesh.html#a4f64766e155cef44a8f66b8411b3725a">libMesh::libmesh_real</a></div><div class="ttdeci">T libmesh_real(T a)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00149">libmesh_common.h:149</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ac03a5d846eeb24a13168f6b5358f86e3"><div class="ttname"><a href="namespacelibMesh.html#ac03a5d846eeb24a13168f6b5358f86e3">libMesh::libmesh_assert</a></div><div class="ttdeci">libmesh_assert(remote_elem)</div></div>
<div class="ttc" id="classlibMesh_1_1NumericVector_html_a57578a53c85eb3b003df5ca4249bdef5"><div class="ttname"><a href="classlibMesh_1_1NumericVector.html#a57578a53c85eb3b003df5ca4249bdef5">libMesh::NumericVector::build</a></div><div class="ttdeci">static AutoPtr&lt; NumericVector&lt; T &gt; &gt; build(const Parallel::Communicator &amp;comm, const SolverPackage solver_package=libMesh::default_solver_package())</div><div class="ttdef"><b>Definition:</b> <a href="numeric__vector_8C_source.html#l00046">numeric_vector.C:46</a></div></div>
<div class="ttc" id="classlibMesh_1_1ErrorEstimator_html_a3e03d60b2e3261e2485d3530ea8e0140"><div class="ttname"><a href="classlibMesh_1_1ErrorEstimator.html#a3e03d60b2e3261e2485d3530ea8e0140">libMesh::ErrorEstimator::reduce_error</a></div><div class="ttdeci">void reduce_error(std::vector&lt; float &gt; &amp;error_per_cell, const Parallel::Communicator &amp;comm LIBMESH_CAN_DEFAULT_TO_COMMWORLD) const </div><div class="ttdef"><b>Definition:</b> <a href="error__estimator_8C_source.html#l00033">error_estimator.C:33</a></div></div>
<div class="ttc" id="classlibMesh_1_1NumericVector_html_a1faf15332fde021fd0067d31cdad74e8"><div class="ttname"><a href="classlibMesh_1_1NumericVector.html#a1faf15332fde021fd0067d31cdad74e8">libMesh::NumericVector::get</a></div><div class="ttdeci">virtual void get(const std::vector&lt; numeric_index_type &gt; &amp;index, std::vector&lt; T &gt; &amp;values) const </div><div class="ttdef"><b>Definition:</b> <a href="numeric__vector_8h_source.html#l00758">numeric_vector.h:758</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a29f261e38c002cf7661170b0fa4e8c74a7ad89a14059d5c662d16a35675f8370d"><div class="ttname"><a href="namespacelibMesh.html#a29f261e38c002cf7661170b0fa4e8c74a7ad89a14059d5c662d16a35675f8370d">libMesh::GHOSTED</a></div><div class="ttdef"><b>Definition:</b> <a href="enum__parallel__type_8h_source.html#l00033">enum_parallel_type.h:33</a></div></div>
<div class="ttc" id="mesh__communication_8C_html_afaa03b874c297f4693d9cdef7f50f3c6"><div class="ttname"><a href="mesh__communication_8C.html#afaa03b874c297f4693d9cdef7f50f3c6">mesh</a></div><div class="ttdeci">MeshBase &amp; mesh</div><div class="ttdef"><b>Definition:</b> <a href="mesh__communication_8C_source.html#l00824">mesh_communication.C:824</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_ad51061a9299eba61c328edca03b0cd20"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">libMesh::AdjointRefinementEstimator::_qoi_set</a></div><div class="ttdeci">QoISet _qoi_set</div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00140">adjoint_refinement_estimator.h:140</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a26acf05f075521cbfb223db57e63d6d0"><div class="ttname"><a href="namespacelibMesh.html#a26acf05f075521cbfb223db57e63d6d0">libMesh::ErrorVectorReal</a></div><div class="ttdeci">DIE A HORRIBLE DEATH HERE typedef float ErrorVectorReal</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00183">libmesh_common.h:183</a></div></div>
<div class="ttc" id="classlibMesh_1_1QoISet_html_abfcf1c89b78ec1ff01f3b6064b910401"><div class="ttname"><a href="classlibMesh_1_1QoISet.html#abfcf1c89b78ec1ff01f3b6064b910401">libMesh::QoISet::weight</a></div><div class="ttdeci">Real weight(unsigned int) const </div><div class="ttdef"><b>Definition:</b> <a href="qoi__set_8h_source.html#l00236">qoi_set.h:236</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_af635c66743cb57b7ffc0c16343055a8d"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#af635c66743cb57b7ffc0c16343055a8d">libMesh::AdjointRefinementEstimator::computed_global_QoI_errors</a></div><div class="ttdeci">std::vector&lt; Number &gt; computed_global_QoI_errors</div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00124">adjoint_refinement_estimator.h:124</a></div></div>
<div class="ttc" id="namespacelibMesh_html_aef28359fb4851abec08fc99cfbac118d"><div class="ttname"><a href="namespacelibMesh.html#aef28359fb4851abec08fc99cfbac118d">libMesh::Real</a></div><div class="ttdeci">DIE A HORRIBLE DEATH HERE typedef LIBMESH_DEFAULT_SCALAR_TYPE Real</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00119">libmesh_common.h:119</a></div></div>
<div class="ttc" id="classlibMesh_1_1System_html_a6a75b971c5614203f50d5a922df9253c"><div class="ttname"><a href="classlibMesh_1_1System.html#a6a75b971c5614203f50d5a922df9253c">libMesh::System::vectors_iterator</a></div><div class="ttdeci">std::map&lt; std::string, NumericVector&lt; Number &gt; * &gt;::iterator vectors_iterator</div><div class="ttdef"><b>Definition:</b> <a href="system_8h_source.html#l00742">system.h:742</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a39353fe8a8facf9ff79837b89ea15170"><div class="ttname"><a href="namespacelibMesh.html#a39353fe8a8facf9ff79837b89ea15170">libMesh::dof_map</a></div><div class="ttdeci">const DofMap &amp; dof_map</div><div class="ttdef"><b>Definition:</b> <a href="exact__error__estimator_8C_source.html#l00222">exact_error_estimator.C:222</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a8b17bf24a15bc292850c3a3894e2e8f9"><div class="ttname"><a href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">libMesh::Number</a></div><div class="ttdeci">Real Number</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00172">libmesh_common.h:172</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_a4437c7888b7459952e06a9157bf61ffe"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#a4437c7888b7459952e06a9157bf61ffe">libMesh::AdjointRefinementEstimator::number_h_refinements</a></div><div class="ttdeci">unsigned char number_h_refinements</div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00114">adjoint_refinement_estimator.h:114</a></div></div>
<div class="ttc" id="classlibMesh_1_1QoISet_html_adcfff89b353ad16cb93a89d7af779fc0"><div class="ttname"><a href="classlibMesh_1_1QoISet.html#adcfff89b353ad16cb93a89d7af779fc0">libMesh::QoISet::has_index</a></div><div class="ttdeci">bool has_index(unsigned int) const </div><div class="ttdef"><b>Definition:</b> <a href="qoi__set_8h_source.html#l00217">qoi_set.h:217</a></div></div>
<div class="ttc" id="namespacelibMesh_html_ab4541d74809228310a715b11c40587fc"><div class="ttname"><a href="namespacelibMesh.html#ab4541d74809228310a715b11c40587fc">libMesh::dof_id_type</a></div><div class="ttdeci">uint8_t dof_id_type</div><div class="ttdef"><b>Definition:</b> <a href="id__types_8h_source.html#l00064">id_types.h:64</a></div></div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_abff7ac97985f693cd3cc7a8311a24558"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#abff7ac97985f693cd3cc7a8311a24558">libMesh::AdjointRefinementEstimator::number_p_refinements</a></div><div class="ttdeci">unsigned char number_p_refinements</div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00119">adjoint_refinement_estimator.h:119</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8d34dfeddc8a1991cd9d01e401b6d779"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::ErrorEstimator::estimate_errors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1EquationSystems.html">EquationSystems</a> &amp;&#160;</td>
          <td class="paramname"><em>equation_systems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1ErrorVector.html">ErrorVector</a> &amp;&#160;</td>
          <td class="paramname"><em>error_per_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; const <a class="el" href="classlibMesh_1_1System.html">System</a> *, <a class="el" href="classlibMesh_1_1SystemNorm.html">SystemNorm</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>error_norms</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; const <a class="el" href="classlibMesh_1_1System.html">System</a> *, const <a class="el" href="classlibMesh_1_1NumericVector.html">NumericVector</a>&lt; <a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &gt; * &gt; *&#160;</td>
          <td class="paramname"><em>solution_vectors</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>estimate_parent_error</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This virtual function can be redefined in derived classes, but by default computes the sum of the error_per_cell for each system in the equation_systems.</p>
<p>Currently this function ignores the error_norm member variable, and uses the function argument error_norms instead.</p>
<p>This function is named estimate_errors instead of estimate_error because otherwise C++ can get confused. </p>

<p>Reimplemented in <a class="el" href="classlibMesh_1_1UniformRefinementEstimator.html#ab2f27d4c0a8cd9964cd44458e08ee1f4">libMesh::UniformRefinementEstimator</a>.</p>

<p>Definition at line <a class="el" href="error__estimator_8C_source.html#l00048">48</a> of file <a class="el" href="error__estimator_8C_source.html">error_estimator.C</a>.</p>

<p>References <a class="el" href="error__estimator_8h_source.html#l00142">libMesh::ErrorEstimator::error_norm</a>, <a class="el" href="classlibMesh_1_1ErrorEstimator.html#a4e8751ba26dfeb9e692d92e10f1cbd28">libMesh::ErrorEstimator::estimate_error()</a>, <a class="el" href="equation__systems_8h_source.html#l00647">libMesh::EquationSystems::get_system()</a>, <a class="el" href="equation__systems_8h_source.html#l00546">libMesh::EquationSystems::n_systems()</a>, and <a class="el" href="petsc__diff__solver_8C_source.html#l00154">libMesh::sys</a>.</p>
<div class="fragment"><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;{</div>
<div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;  SystemNorm old_error_norm = this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">error_norm</a>;</div>
<div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;</div>
<div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;  <span class="comment">// Sum the error values from each system</span></div>
<div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> s = 0; s != equation_systems.n_systems(); ++s)</div>
<div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;    {</div>
<div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;      ErrorVector system_error_per_cell;</div>
<div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;      <span class="keyword">const</span> System &amp;<a class="code" href="namespacelibMesh.html#a13b55b2e3e43370c0ccf466d8615ccea">sys</a> = equation_systems.get_system(s);</div>
<div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;      <span class="keywordflow">if</span> (error_norms.find(&amp;sys) == error_norms.end())</div>
<div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;        this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">error_norm</a> = old_error_norm;</div>
<div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;        this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">error_norm</a> = error_norms.find(&amp;sys)-&gt;second;</div>
<div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;</div>
<div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;      <span class="keyword">const</span> NumericVector&lt;Number&gt;* solution_vector = NULL;</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;      <span class="keywordflow">if</span> (solution_vectors &amp;&amp;</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;          solution_vectors-&gt;find(&amp;sys) != solution_vectors-&gt;end())</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;        solution_vector = solution_vectors-&gt;find(&amp;sys)-&gt;second;</div>
<div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div>
<div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;      this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#a4e8751ba26dfeb9e692d92e10f1cbd28">estimate_error</a>(sys, system_error_per_cell,</div>
<div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;                           solution_vector, estimate_parent_error);</div>
<div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;</div>
<div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;      <span class="keywordflow">if</span> (s)</div>
<div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;        {</div>
<div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;          libmesh_assert_equal_to (error_per_cell.size(), system_error_per_cell.size());</div>
<div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i != error_per_cell.size(); ++i)</div>
<div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;            error_per_cell[i] += system_error_per_cell[i];</div>
<div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;        }</div>
<div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;      <span class="keywordflow">else</span></div>
<div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;        error_per_cell = system_error_per_cell;</div>
<div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;    }</div>
<div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;</div>
<div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;  <span class="comment">// Restore our old state before returning</span></div>
<div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">error_norm</a> = old_error_norm;</div>
<div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1ErrorEstimator_html_a9d626496b0b6f99f679c4ef4f0a5e46e"><div class="ttname"><a href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">libMesh::ErrorEstimator::error_norm</a></div><div class="ttdeci">SystemNorm error_norm</div><div class="ttdef"><b>Definition:</b> <a href="error__estimator_8h_source.html#l00142">error_estimator.h:142</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a13b55b2e3e43370c0ccf466d8615ccea"><div class="ttname"><a href="namespacelibMesh.html#a13b55b2e3e43370c0ccf466d8615ccea">libMesh::sys</a></div><div class="ttdeci">ImplicitSystem &amp; sys</div><div class="ttdef"><b>Definition:</b> <a href="petsc__diff__solver_8C_source.html#l00154">petsc_diff_solver.C:154</a></div></div>
<div class="ttc" id="classlibMesh_1_1ErrorEstimator_html_a4e8751ba26dfeb9e692d92e10f1cbd28"><div class="ttname"><a href="classlibMesh_1_1ErrorEstimator.html#a4e8751ba26dfeb9e692d92e10f1cbd28">libMesh::ErrorEstimator::estimate_error</a></div><div class="ttdeci">virtual void estimate_error(const System &amp;system, ErrorVector &amp;error_per_cell, const NumericVector&lt; Number &gt; *solution_vector=NULL, bool estimate_parent_error=false)=0</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6154704639951f51a2749af773c7ea6d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::ErrorEstimator::estimate_errors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1EquationSystems.html">EquationSystems</a> &amp;&#160;</td>
          <td class="paramname"><em>equation_systems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1ErrorEstimator.html#a838c11d53f37d85b33a827a355819c94">ErrorMap</a> &amp;&#160;</td>
          <td class="paramname"><em>errors_per_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; const <a class="el" href="classlibMesh_1_1System.html">System</a> *, const <a class="el" href="classlibMesh_1_1NumericVector.html">NumericVector</a>&lt; <a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a> &gt; * &gt; *&#160;</td>
          <td class="paramname"><em>solution_vectors</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>estimate_parent_error</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This virtual function can be redefined in derived classes, but by default it calls estimate_error repeatedly to calculate the requested error vectors.</p>
<p>Currently this function ignores the <a class="el" href="namespacelibMesh_1_1MeshTools.html#a0701de7f01fd5eced3da4a332ff5ae51">error_norm.weight()</a> values because it calculates each variable's error individually, unscaled.</p>
<p>The user selects which errors get computed by filling a map with error vectors: If errors_per_cell[&amp;system][v] exists, it will be filled with the error values in variable <code>v</code> of <code>system</code> </p>
<p>FIXME: This is a default implementation - derived classes should reimplement it for efficiency. </p>

<p>Reimplemented in <a class="el" href="classlibMesh_1_1UniformRefinementEstimator.html#aad3f8bda67ab47bf783b022836354cc4">libMesh::UniformRefinementEstimator</a>.</p>

<p>Definition at line <a class="el" href="error__estimator_8C_source.html#l00094">94</a> of file <a class="el" href="error__estimator_8C_source.html">error_estimator.C</a>.</p>

<p>References <a class="el" href="error__estimator_8h_source.html#l00142">libMesh::ErrorEstimator::error_norm</a>, <a class="el" href="classlibMesh_1_1ErrorEstimator.html#a4e8751ba26dfeb9e692d92e10f1cbd28">libMesh::ErrorEstimator::estimate_error()</a>, <a class="el" href="equation__systems_8h_source.html#l00647">libMesh::EquationSystems::get_system()</a>, <a class="el" href="equation__systems_8h_source.html#l00546">libMesh::EquationSystems::n_systems()</a>, <a class="el" href="exact__error__estimator_8C_source.html#l00219">libMesh::n_vars</a>, <a class="el" href="system_8h_source.html#l02016">libMesh::System::n_vars()</a>, <a class="el" href="petsc__diff__solver_8C_source.html#l00154">libMesh::sys</a>, and <a class="el" href="system__norm_8h_source.html#l00269">libMesh::SystemNorm::type()</a>.</p>
<div class="fragment"><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;{</div>
<div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;  SystemNorm old_error_norm = this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">error_norm</a>;</div>
<div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;</div>
<div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;  <span class="comment">// Find the requested error values from each system</span></div>
<div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> s = 0; s != equation_systems.n_systems(); ++s)</div>
<div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;    {</div>
<div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;      <span class="keyword">const</span> System &amp;<a class="code" href="namespacelibMesh.html#a13b55b2e3e43370c0ccf466d8615ccea">sys</a> = equation_systems.get_system(s);</div>
<div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;</div>
<div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;      <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacelibMesh.html#a08547a9aebd4fda0632d711e56e5bdf3">n_vars</a> = sys.n_vars();</div>
<div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v = 0; v != <a class="code" href="namespacelibMesh.html#a08547a9aebd4fda0632d711e56e5bdf3">n_vars</a>; ++v)</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;        {</div>
<div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;          <span class="comment">// Only fill in ErrorVectors the user asks for</span></div>
<div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;          <span class="keywordflow">if</span> (errors_per_cell.find(std::make_pair(&amp;sys, v)) ==</div>
<div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;              errors_per_cell.end())</div>
<div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;            <span class="keywordflow">continue</span>;</div>
<div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;</div>
<div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;          <span class="comment">// Calculate error in only one variable</span></div>
<div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;          std::vector&lt;Real&gt; weights(n_vars, 0.0);</div>
<div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;          weights[v] = 1.0;</div>
<div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;          this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">error_norm</a> =</div>
<div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;            SystemNorm(std::vector&lt;FEMNormType&gt;(n_vars, old_error_norm.type(v)),</div>
<div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;                       weights);</div>
<div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;</div>
<div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;          <span class="keyword">const</span> NumericVector&lt;Number&gt;* solution_vector = NULL;</div>
<div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;          <span class="keywordflow">if</span> (solution_vectors &amp;&amp;</div>
<div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;              solution_vectors-&gt;find(&amp;sys) != solution_vectors-&gt;end())</div>
<div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;            solution_vector = solution_vectors-&gt;find(&amp;sys)-&gt;second;</div>
<div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;</div>
<div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;          this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#a4e8751ba26dfeb9e692d92e10f1cbd28">estimate_error</a></div>
<div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;            (sys, *errors_per_cell[std::make_pair(&amp;sys, v)],</div>
<div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;             solution_vector, estimate_parent_error);</div>
<div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;        }</div>
<div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;    }</div>
<div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;</div>
<div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;  <span class="comment">// Restore our old state before returning</span></div>
<div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;  this-&gt;<a class="code" href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">error_norm</a> = old_error_norm;</div>
<div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;}</div>
<div class="ttc" id="classlibMesh_1_1ErrorEstimator_html_a9d626496b0b6f99f679c4ef4f0a5e46e"><div class="ttname"><a href="classlibMesh_1_1ErrorEstimator.html#a9d626496b0b6f99f679c4ef4f0a5e46e">libMesh::ErrorEstimator::error_norm</a></div><div class="ttdeci">SystemNorm error_norm</div><div class="ttdef"><b>Definition:</b> <a href="error__estimator_8h_source.html#l00142">error_estimator.h:142</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a08547a9aebd4fda0632d711e56e5bdf3"><div class="ttname"><a href="namespacelibMesh.html#a08547a9aebd4fda0632d711e56e5bdf3">libMesh::n_vars</a></div><div class="ttdeci">const unsigned int n_vars</div><div class="ttdef"><b>Definition:</b> <a href="exact__error__estimator_8C_source.html#l00219">exact_error_estimator.C:219</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a13b55b2e3e43370c0ccf466d8615ccea"><div class="ttname"><a href="namespacelibMesh.html#a13b55b2e3e43370c0ccf466d8615ccea">libMesh::sys</a></div><div class="ttdeci">ImplicitSystem &amp; sys</div><div class="ttdef"><b>Definition:</b> <a href="petsc__diff__solver_8C_source.html#l00154">petsc_diff_solver.C:154</a></div></div>
<div class="ttc" id="classlibMesh_1_1ErrorEstimator_html_a4e8751ba26dfeb9e692d92e10f1cbd28"><div class="ttname"><a href="classlibMesh_1_1ErrorEstimator.html#a4e8751ba26dfeb9e692d92e10f1cbd28">libMesh::ErrorEstimator::estimate_error</a></div><div class="ttdeci">virtual void estimate_error(const System &amp;system, ErrorVector &amp;error_per_cell, const NumericVector&lt; Number &gt; *solution_vector=NULL, bool estimate_parent_error=false)=0</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0143c56bd2fdc236700dd3b1262d7097"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a>&amp; libMesh::AdjointRefinementEstimator::get_global_QoI_error_estimate </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>qoi_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an accessor function to access the computed global QoI error estimates </p>

<p>Definition at line <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00106">106</a> of file <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a>.</p>

<p>References <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00124">computed_global_QoI_errors</a>.</p>
<div class="fragment"><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;  {</div>
<div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;    <span class="keywordflow">return</span> <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#af635c66743cb57b7ffc0c16343055a8d">computed_global_QoI_errors</a>[qoi_index];</div>
<div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;  }</div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_af635c66743cb57b7ffc0c16343055a8d"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#af635c66743cb57b7ffc0c16343055a8d">libMesh::AdjointRefinementEstimator::computed_global_QoI_errors</a></div><div class="ttdeci">std::vector&lt; Number &gt; computed_global_QoI_errors</div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00124">adjoint_refinement_estimator.h:124</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0aca6ed2c5e83a66cbea3fb745d42bb6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1QoISet.html">QoISet</a>&amp; libMesh::AdjointRefinementEstimator::qoi_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access to the <a class="el" href="classlibMesh_1_1QoISet.html">QoISet</a> (default: weight all QoIs equally) to use when computing errors </p>

<p>Definition at line <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00073">73</a> of file <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a>.</p>

<p>References <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00140">_qoi_set</a>.</p>
<div class="fragment"><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>; }</div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_ad51061a9299eba61c328edca03b0cd20"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">libMesh::AdjointRefinementEstimator::_qoi_set</a></div><div class="ttdeci">QoISet _qoi_set</div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00140">adjoint_refinement_estimator.h:140</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="afcdc392b69087dc11dc56fe15b29708a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classlibMesh_1_1QoISet.html">QoISet</a>&amp; libMesh::AdjointRefinementEstimator::qoi_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access to the <a class="el" href="classlibMesh_1_1QoISet.html">QoISet</a> (default: weight all QoIs equally) to use when computing errors </p>

<p>Definition at line <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00079">79</a> of file <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a>.</p>

<p>References <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00140">_qoi_set</a>.</p>
<div class="fragment"><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">_qoi_set</a>; }</div>
<div class="ttc" id="classlibMesh_1_1AdjointRefinementEstimator_html_ad51061a9299eba61c328edca03b0cd20"><div class="ttname"><a href="classlibMesh_1_1AdjointRefinementEstimator.html#ad51061a9299eba61c328edca03b0cd20">libMesh::AdjointRefinementEstimator::_qoi_set</a></div><div class="ttdeci">QoISet _qoi_set</div><div class="ttdef"><b>Definition:</b> <a href="adjoint__refinement__estimator_8h_source.html#l00140">adjoint_refinement_estimator.h:140</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3e03d60b2e3261e2485d3530ea8e0140"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void libMesh::ErrorEstimator::reduce_error </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>error_per_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classlibMesh_1_1Parallel_1_1Communicator.html">Parallel::Communicator</a> &amp;<a class="el" href="namespacelibMesh.html#ac58d93c086340dd1c4e8071081728d18">comm</a>&#160;</td>
          <td class="paramname"><em>LIBMESH_CAN_DEFAULT_TO_COMMWORLD</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This method takes the local error contributions in <code>error_per_cell</code> from each processor and combines them to get the global error vector. </p>

<p>Definition at line <a class="el" href="error__estimator_8C_source.html#l00033">33</a> of file <a class="el" href="error__estimator_8C_source.html">error_estimator.C</a>.</p>

<p>References <a class="el" href="parallel__implementation_8h_source.html#l01792">libMesh::Parallel::Communicator::sum()</a>.</p>

<p>Referenced by <a class="el" href="uniform__refinement__estimator_8C_source.html#l00086">libMesh::UniformRefinementEstimator::_estimate_error()</a>, <a class="el" href="weighted__patch__recovery__estimator_8C_source.html#l00044">libMesh::WeightedPatchRecoveryErrorEstimator::estimate_error()</a>, <a class="el" href="patch__recovery__error__estimator_8C_source.html#l00131">libMesh::PatchRecoveryErrorEstimator::estimate_error()</a>, <a class="el" href="jump__error__estimator_8C_source.html#l00054">libMesh::JumpErrorEstimator::estimate_error()</a>, and <a class="el" href="adjoint__refinement__estimator_8C_source.html#l00069">estimate_error()</a>.</p>
<div class="fragment"><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;{</div>
<div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;  <span class="comment">// This function must be run on all processors at once</span></div>
<div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;  <span class="comment">// parallel_object_only();</span></div>
<div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;</div>
<div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;  <span class="comment">// Each processor has now computed the error contribuions</span></div>
<div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;  <span class="comment">// for its local elements.  We may need to sum the vector to</span></div>
<div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;  <span class="comment">// recover the error for each element.</span></div>
<div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;</div>
<div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;  <a class="code" href="namespacelibMesh.html#ac58d93c086340dd1c4e8071081728d18">comm</a>.sum(error_per_cell);</div>
<div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;}</div>
<div class="ttc" id="namespacelibMesh_html_ac58d93c086340dd1c4e8071081728d18"><div class="ttname"><a href="namespacelibMesh.html#ac58d93c086340dd1c4e8071081728d18">libMesh::comm</a></div><div class="ttdeci">void PetscPreconditioner&lt; T &gt;::set_petsc_subpreconditioner_type(PCType type, PC &amp;pc) void PetscPreconditioner&lt; T &gt; Parallel::communicator comm</div><div class="ttdef"><b>Definition:</b> <a href="petsc__preconditioner_8C_source.html#l00265">petsc_preconditioner.C:265</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ad51061a9299eba61c328edca03b0cd20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1QoISet.html">QoISet</a> libMesh::AdjointRefinementEstimator::_qoi_set</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A <a class="el" href="classlibMesh_1_1QoISet.html">QoISet</a> to handle cases with multiple QoIs available </p>

<p>Definition at line <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00140">140</a> of file <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a>.</p>

<p>Referenced by <a class="el" href="adjoint__refinement__estimator_8C_source.html#l00069">estimate_error()</a>, and <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00073">qoi_set()</a>.</p>

</div>
</div>
<a class="anchor" id="af635c66743cb57b7ffc0c16343055a8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacelibMesh.html#a8b17bf24a15bc292850c3a3894e2e8f9">Number</a>&gt; libMesh::AdjointRefinementEstimator::computed_global_QoI_errors</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00124">124</a> of file <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a>.</p>

<p>Referenced by <a class="el" href="adjoint__refinement__estimator_8C_source.html#l00069">estimate_error()</a>, and <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00106">get_global_QoI_error_estimate()</a>.</p>

</div>
</div>
<a class="anchor" id="a9d626496b0b6f99f679c4ef4f0a5e46e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1SystemNorm.html">SystemNorm</a> libMesh::ErrorEstimator::error_norm</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When estimating the error in a single system, the <code>error_norm</code> is used to control the scaling and norm choice for each variable. Not all estimators will support all norm choices. The default scaling is for all variables to be weighted equally. The default norm choice depends on the error estimator.</p>
<p>Part of this functionality was supported via component_scale and sobolev_order in older <a class="el" href="namespacelibMesh.html">libMesh</a> versions, and a small part was supported via component_mask in even older versions. Hopefully the encapsulation here will allow us to avoid changing this API again. </p>

<p>Definition at line <a class="el" href="error__estimator_8h_source.html#l00142">142</a> of file <a class="el" href="error__estimator_8h_source.html">error_estimator.h</a>.</p>

<p>Referenced by <a class="el" href="uniform__refinement__estimator_8C_source.html#l00086">libMesh::UniformRefinementEstimator::_estimate_error()</a>, <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00053">AdjointRefinementEstimator()</a>, <a class="el" href="discontinuity__measure_8C_source.html#l00096">libMesh::DiscontinuityMeasure::boundary_side_integration()</a>, <a class="el" href="kelly__error__estimator_8C_source.html#l00100">libMesh::KellyErrorEstimator::boundary_side_integration()</a>, <a class="el" href="discontinuity__measure_8h_source.html#l00057">libMesh::DiscontinuityMeasure::DiscontinuityMeasure()</a>, <a class="el" href="jump__error__estimator_8C_source.html#l00054">libMesh::JumpErrorEstimator::estimate_error()</a>, <a class="el" href="adjoint__residual__error__estimator_8C_source.html#l00051">libMesh::AdjointResidualErrorEstimator::estimate_error()</a>, <a class="el" href="error__estimator_8C_source.html#l00048">libMesh::ErrorEstimator::estimate_errors()</a>, <a class="el" href="exact__error__estimator_8h_source.html#l00074">libMesh::ExactErrorEstimator::ExactErrorEstimator()</a>, <a class="el" href="exact__error__estimator_8C_source.html#l00429">libMesh::ExactErrorEstimator::find_squared_element_error()</a>, <a class="el" href="fourth__error__estimators_8C_source.html#l00059">libMesh::LaplacianErrorEstimator::internal_side_integration()</a>, <a class="el" href="discontinuity__measure_8C_source.html#l00057">libMesh::DiscontinuityMeasure::internal_side_integration()</a>, <a class="el" href="kelly__error__estimator_8C_source.html#l00059">libMesh::KellyErrorEstimator::internal_side_integration()</a>, <a class="el" href="kelly__error__estimator_8h_source.html#l00071">libMesh::KellyErrorEstimator::KellyErrorEstimator()</a>, <a class="el" href="fourth__error__estimators_8h_source.html#l00054">libMesh::LaplacianErrorEstimator::LaplacianErrorEstimator()</a>, <a class="el" href="weighted__patch__recovery__estimator_8C_source.html#l00103">libMesh::WeightedPatchRecoveryErrorEstimator::EstimateError::operator()()</a>, <a class="el" href="patch__recovery__error__estimator_8C_source.html#l00190">libMesh::PatchRecoveryErrorEstimator::EstimateError::operator()()</a>, <a class="el" href="patch__recovery__error__estimator_8h_source.html#l00056">libMesh::PatchRecoveryErrorEstimator::PatchRecoveryErrorEstimator()</a>, and <a class="el" href="uniform__refinement__estimator_8h_source.html#l00051">libMesh::UniformRefinementEstimator::UniformRefinementEstimator()</a>.</p>

</div>
</div>
<a class="anchor" id="a4437c7888b7459952e06a9157bf61ffe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char libMesh::AdjointRefinementEstimator::number_h_refinements</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>How many h refinements to perform to get the fine grid </p>

<p>Definition at line <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00114">114</a> of file <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a>.</p>

<p>Referenced by <a class="el" href="adjoint__refinement__estimator_8C_source.html#l00069">estimate_error()</a>.</p>

</div>
</div>
<a class="anchor" id="abff7ac97985f693cd3cc7a8311a24558"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char libMesh::AdjointRefinementEstimator::number_p_refinements</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>How many p refinements to perform to get the fine grid </p>

<p>Definition at line <a class="el" href="adjoint__refinement__estimator_8h_source.html#l00119">119</a> of file <a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a>.</p>

<p>Referenced by <a class="el" href="adjoint__refinement__estimator_8C_source.html#l00069">estimate_error()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="adjoint__refinement__estimator_8h_source.html">adjoint_refinement_estimator.h</a></li>
<li><a class="el" href="adjoint__refinement__estimator_8C_source.html">adjoint_refinement_estimator.C</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
generated by <a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a>
</small></address>
<!-- dynamic header stuff -->
<script type="text/javascript">
$(document).ready(function(){
  $(window).on('scroll',function() {
    var scrolltop = $(this).scrollTop();
    if(scrolltop >= 215) {
      $('#fixedbar').fadeIn(250);
    }
    else if(scrolltop <= 210) {
      $('#fixedbar').fadeOut(250);
    }
  });
});
</script>
<!-- Google Analytics stuff -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-24978333-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</body>
</html>
