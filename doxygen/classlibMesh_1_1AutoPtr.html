<!-- HTML header for doxygen -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libMesh: libMesh::AutoPtr&lt; Tp &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="../styles.css" rel="stylesheet" type="text/css" />
<link href="doxygen_stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <nav id="fixedbar">
    <ul id="fixednav">
      <li><a href="../index.html">Home</a></li>
      <li><a href="../support.html">About Us</a></li>
      <li><a href="../publications.html">Publications</a></li>
      <li><a href="../developers.html">Developers</a></li>
      <li><a href="../installation.html">Installation</a></li>
      <li><a href="../examples.html">Examples</a></li>
      <li><a href="../doxygen/index.html">Documentation</a></li>
    </ul>
  </nav>
  <div id="w">
    <header id="logo"><a href="index.html"><span id="logobg">SomeWebsiteLogo</span></a></header>
    <nav id="navigation">
      <ul>
        <li><a href="../index.html">Home</a></li>
        <li><a href="../support.html">About Us</a></li>
        <li><a href="../publications.html">Publications</a></li>
        <li><a href="../developers.html">Developers</a></li>
        <li><a href="../installation.html">Installation</a></li>
        <li><a href="../examples.html">Examples</a></li>
        <li><a href="../doxygen/index.html">Documentation</a></li>
      </ul>
    </nav>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- <\!--BEGIN TITLEAREA-\-> -->
<!-- <div id="titlearea"> -->
<!-- <table cellspacing="0" cellpadding="0"> -->
<!--  <tbody> -->
<!--  <tr style="height: 56px;"> -->
<!--   <\!--BEGIN PROJECT_LOGO-\-> -->
<!--   <td id="projectlogo"><img alt="Logo" src=""/></td> -->
<!--   <\!--END PROJECT_LOGO-\-> -->
<!--   <\!--BEGIN PROJECT_NAME-\-> -->
<!--   <td style="padding-left: 0.5em;"> -->
<!--    <div id="projectname">libMesh -->
<!--    <\!--BEGIN PROJECT_NUMBER-\->&#160;<span id="projectnumber"></span><\!--END PROJECT_NUMBER-\-> -->
<!--    </div> -->
<!--    <\!--BEGIN PROJECT_BRIEF-\-><div id="projectbrief"></div><\!--END PROJECT_BRIEF-\-> -->
<!--   </td> -->
<!--   <\!--END PROJECT_NAME-\-> -->
<!--   <\!--BEGIN !PROJECT_NAME-\-> -->
<!--    <\!--BEGIN PROJECT_BRIEF-\-> -->
<!--     <td style="padding-left: 0.5em;"> -->
<!--     <div id="projectbrief"></div> -->
<!--     </td> -->
<!--    <\!--END PROJECT_BRIEF-\-> -->
<!--   <\!--END !PROJECT_NAME-\-> -->
<!--   <\!--BEGIN DISABLE_INDEX-\-> -->
<!--    <\!--BEGIN SEARCHENGINE-\-> -->
<!--    <td></td> -->
<!--    <\!--END SEARCHENGINE-\-> -->
<!--   <\!--END DISABLE_INDEX-\-> -->
<!--  </tr> -->
<!--  </tbody> -->
<!-- </table> -->
<!-- </div> -->
<!-- <\!--END TITLEAREA-\-> -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibMesh.html">libMesh</a></li><li class="navelem"><a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classlibMesh_1_1AutoPtr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">libMesh::AutoPtr&lt; Tp &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A simple smart pointer providing strict ownership semantics.  
 <a href="classlibMesh_1_1AutoPtr.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for libMesh::AutoPtr&lt; Tp &gt;:</div>
<div class="dyncontent">
<div class="center"><img src="classlibMesh_1_1AutoPtr__inherit__graph.png" border="0" usemap="#libMesh_1_1AutoPtr_3_01Tp_01_4_inherit__map" alt="Inheritance graph"/></div>
<map name="libMesh_1_1AutoPtr_3_01Tp_01_4_inherit__map" id="libMesh_1_1AutoPtr_3_01Tp_01_4_inherit__map">
<area shape="rect" id="node2" href="classlibMesh_1_1safe__bool.html" title="libMesh::safe_bool\l\&lt; AutoPtr\&lt; Tp \&gt; \&gt;" alt="" coords="23,81,156,122"/><area shape="rect" id="node3" href="classlibMesh_1_1safe__bool__base.html" title="libMesh::safe_bool_base" alt="" coords="5,5,173,32"/></map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af7d6809e6bdb84d790ad2ef11afe3fa6"><td class="memItemLeft" align="right" valign="top">typedef Tp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a></td></tr>
<tr class="separator:af7d6809e6bdb84d790ad2ef11afe3fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6e5b3ce1fc0f9d76bb6b55e79342910c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#a6e5b3ce1fc0f9d76bb6b55e79342910c">AutoPtr</a> (<a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a> *p=0)</td></tr>
<tr class="memdesc:a6e5b3ce1fc0f9d76bb6b55e79342910c"><td class="mdescLeft">&#160;</td><td class="mdescRight">An AutoPtr is usually constructed from a raw pointer.  <a href="#a6e5b3ce1fc0f9d76bb6b55e79342910c">More...</a><br /></td></tr>
<tr class="separator:a6e5b3ce1fc0f9d76bb6b55e79342910c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ea7c5bc4f7cd137cf52a14ea88de52"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#a29ea7c5bc4f7cd137cf52a14ea88de52">AutoPtr</a> (<a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a> &amp;a)</td></tr>
<tr class="memdesc:a29ea7c5bc4f7cd137cf52a14ea88de52"><td class="mdescLeft">&#160;</td><td class="mdescRight">An AutoPtr can be constructed from another AutoPtr.  <a href="#a29ea7c5bc4f7cd137cf52a14ea88de52">More...</a><br /></td></tr>
<tr class="separator:a29ea7c5bc4f7cd137cf52a14ea88de52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b25a1da420a9ce5d0990fcadc3b04f"><td class="memTemplParams" colspan="2">template&lt;typename Tp1 &gt; </td></tr>
<tr class="memitem:a67b25a1da420a9ce5d0990fcadc3b04f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#a67b25a1da420a9ce5d0990fcadc3b04f">AutoPtr</a> (<a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a>&lt; Tp1 &gt; &amp;a)</td></tr>
<tr class="memdesc:a67b25a1da420a9ce5d0990fcadc3b04f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An AutoPtr can be constructed from another AutoPtr.  <a href="#a67b25a1da420a9ce5d0990fcadc3b04f">More...</a><br /></td></tr>
<tr class="separator:a67b25a1da420a9ce5d0990fcadc3b04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b5eb5ed5b453121b0a6db973ff9d72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#ae1b5eb5ed5b453121b0a6db973ff9d72">operator=</a> (<a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a> &amp;a)</td></tr>
<tr class="memdesc:ae1b5eb5ed5b453121b0a6db973ff9d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">AutoPtr assignment operator.  <a href="#ae1b5eb5ed5b453121b0a6db973ff9d72">More...</a><br /></td></tr>
<tr class="separator:ae1b5eb5ed5b453121b0a6db973ff9d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e04b7d615d01081d22c445ae27deff5"><td class="memTemplParams" colspan="2">template&lt;typename Tp1 &gt; </td></tr>
<tr class="memitem:a7e04b7d615d01081d22c445ae27deff5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#a7e04b7d615d01081d22c445ae27deff5">operator=</a> (<a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a>&lt; Tp1 &gt; &amp;a)</td></tr>
<tr class="memdesc:a7e04b7d615d01081d22c445ae27deff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">AutoPtr assignment operator.  <a href="#a7e04b7d615d01081d22c445ae27deff5">More...</a><br /></td></tr>
<tr class="separator:a7e04b7d615d01081d22c445ae27deff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0e9fbbfdd93f5dd0b1a2c580d36202"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#a6c0e9fbbfdd93f5dd0b1a2c580d36202">~AutoPtr</a> ()</td></tr>
<tr class="separator:a6c0e9fbbfdd93f5dd0b1a2c580d36202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280cc923315c8202a9d1b5613157a58e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#a280cc923315c8202a9d1b5613157a58e">operator*</a> () const </td></tr>
<tr class="memdesc:a280cc923315c8202a9d1b5613157a58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer dereferencing.  <a href="#a280cc923315c8202a9d1b5613157a58e">More...</a><br /></td></tr>
<tr class="separator:a280cc923315c8202a9d1b5613157a58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a072981e5044e4d87143a5b5841c5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#a05a072981e5044e4d87143a5b5841c5a">operator-&gt;</a> () const </td></tr>
<tr class="memdesc:a05a072981e5044e4d87143a5b5841c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer dereferencing.  <a href="#a05a072981e5044e4d87143a5b5841c5a">More...</a><br /></td></tr>
<tr class="separator:a05a072981e5044e4d87143a5b5841c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c8f66bc54219761cefe575c26a81dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#a47c8f66bc54219761cefe575c26a81dd">get</a> () const </td></tr>
<tr class="memdesc:a47c8f66bc54219761cefe575c26a81dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bypassing the smart pointer.  <a href="#a47c8f66bc54219761cefe575c26a81dd">More...</a><br /></td></tr>
<tr class="separator:a47c8f66bc54219761cefe575c26a81dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aac56a85f0e34e52bd3ebf05f244526"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#a9aac56a85f0e34e52bd3ebf05f244526">release</a> ()</td></tr>
<tr class="memdesc:a9aac56a85f0e34e52bd3ebf05f244526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bypassing the smart pointer.  <a href="#a9aac56a85f0e34e52bd3ebf05f244526">More...</a><br /></td></tr>
<tr class="separator:a9aac56a85f0e34e52bd3ebf05f244526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7dac34d00cd798c43629794345a09c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#aca7dac34d00cd798c43629794345a09c">reset</a> (<a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a> *p=0)</td></tr>
<tr class="memdesc:aca7dac34d00cd798c43629794345a09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forcibly deletes the managed object.  <a href="#aca7dac34d00cd798c43629794345a09c">More...</a><br /></td></tr>
<tr class="separator:aca7dac34d00cd798c43629794345a09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13378fcb4705c5722893eee224398100"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1safe__bool.html#a13378fcb4705c5722893eee224398100">operator bool_type</a> () const</td></tr>
<tr class="separator:a13378fcb4705c5722893eee224398100"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac87f7a29cee79240f59b9fe132212640"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#ac87f7a29cee79240f59b9fe132212640">AutoPtr</a> (<a class="el" href="structlibMesh_1_1AutoPtrRef.html">AutoPtrRef</a>&lt; <a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a> &gt; ref)</td></tr>
<tr class="memdesc:ac87f7a29cee79240f59b9fe132212640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatic conversions.  <a href="#ac87f7a29cee79240f59b9fe132212640">More...</a><br /></td></tr>
<tr class="separator:ac87f7a29cee79240f59b9fe132212640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2d725cb78d2dafc1e80d847d62c487"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#abc2d725cb78d2dafc1e80d847d62c487">operator=</a> (<a class="el" href="structlibMesh_1_1AutoPtrRef.html">AutoPtrRef</a>&lt; <a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a> &gt; ref)</td></tr>
<tr class="separator:abc2d725cb78d2dafc1e80d847d62c487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ecac20f5c1754c5ed4b9afd63f2bd03"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#a4ecac20f5c1754c5ed4b9afd63f2bd03">boolean_test</a> () const </td></tr>
<tr class="separator:a4ecac20f5c1754c5ed4b9afd63f2bd03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bdbe1f868c4d3e96fcafe98e873b679"><td class="memTemplParams" colspan="2">template&lt;typename Tp1 &gt; </td></tr>
<tr class="memitem:a0bdbe1f868c4d3e96fcafe98e873b679"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#a0bdbe1f868c4d3e96fcafe98e873b679">operator AutoPtrRef&lt; Tp1 &gt;</a> ()</td></tr>
<tr class="separator:a0bdbe1f868c4d3e96fcafe98e873b679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b070154b91cb631accf241a322b5fbd"><td class="memTemplParams" colspan="2">template&lt;typename Tp1 &gt; </td></tr>
<tr class="memitem:a6b070154b91cb631accf241a322b5fbd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#a6b070154b91cb631accf241a322b5fbd">operator AutoPtr&lt; Tp1 &gt;</a> ()</td></tr>
<tr class="separator:a6b070154b91cb631accf241a322b5fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7e8340fb4f4326ce8496a49f52980374"><td class="memItemLeft" align="right" valign="top">Tp *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a></td></tr>
<tr class="separator:a7e8340fb4f4326ce8496a49f52980374"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Tp&gt;<br />
class libMesh::AutoPtr&lt; Tp &gt;</h3>

<p>A simple smart pointer providing strict ownership semantics. </p>
<p>The Standard says: </p><pre>
 An <code><a class="el" href="classlibMesh_1_1AutoPtr.html" title="A simple smart pointer providing strict ownership semantics. ">AutoPtr</a></code> owns the object it holds a pointer to.  Copying an
 <code><a class="el" href="classlibMesh_1_1AutoPtr.html" title="A simple smart pointer providing strict ownership semantics. ">AutoPtr</a></code> copies the pointer and transfers ownership to the destination.
 If more than one <code><a class="el" href="classlibMesh_1_1AutoPtr.html" title="A simple smart pointer providing strict ownership semantics. ">AutoPtr</a></code> owns the same object at the same time the
 behavior of the program is undefined.</pre><pre> The uses of <code><a class="el" href="classlibMesh_1_1AutoPtr.html" title="A simple smart pointer providing strict ownership semantics. ">AutoPtr</a></code> include providing temporary exception-safety for
 dynamically allocated memory, passing ownership of dynamically allocated
 memory to a function, and returning dynamically allocated memory from a
 function.  <code><a class="el" href="classlibMesh_1_1AutoPtr.html" title="A simple smart pointer providing strict ownership semantics. ">AutoPtr</a></code> does not meet the CopyConstructible and Assignable
 requirements for Standard Library <a href="tables.html#65">container</a>
 elements and thus instantiating a Standard Library container with an
 <code><a class="el" href="classlibMesh_1_1AutoPtr.html" title="A simple smart pointer providing strict ownership semantics. ">AutoPtr</a></code> results in undefined behavior.
 </pre><p> Quoted from [20.4.5]/3.</p>
<p>This class is adopted from the GCC 3.2.1 source tree and should function as a replacement for <code>std::auto_ptr&lt;&gt;</code>. Unfortunately the <code>std::auto_ptr&lt;&gt;</code> is not particularly portable since various compilers implement various revisions of the standard. Using <code>AutoPtr&lt;&gt;</code> instead of <code>std::auto_ptr&lt;&gt;</code> allows for easy portability.</p>
<p>The following are the original copyright declarations distributed with this class:</p>
<p>Copyright (C) 2001, 2002 Free Software Foundation, Inc.</p>
<p>This file is part of the GNU ISO C++ Library. This library is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation; either version 2, or (at your option) any later version.</p>
<p>This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.</p>
<p>You should have received a copy of the GNU General Public License along with this library; see the file COPYING. If not, write to the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</p>
<p>As a special exception, you may use this file as part of a free software library without restriction. Specifically, if other files instantiate templates or use macros or inline functions from this file, or you compile this file and link it with other files to produce an executable, this file does not by itself cause the resulting executable to be covered by the GNU General Public License. This exception does not however invalidate any other reasons why the executable file might be covered by the GNU General Public License.</p>
<p>Copyright (c) 1997-1999 Silicon Graphics Computer Systems, Inc.</p>
<p>Permission to use, copy, modify, distribute and sell this software and its documentation for any purpose is hereby granted without fee, provided that the above copyright notice appear in all copies and that both that copyright notice and this permission notice appear in supporting documentation. Silicon Graphics makes no representations about the suitability of this software for any purpose. It is provided "as is" without express or implied warranty. </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00163">163</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="af7d6809e6bdb84d790ad2ef11afe3fa6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Tp <a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::<a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The pointed-to type. </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00176">176</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6e5b3ce1fc0f9d76bb6b55e79342910c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::<a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a> *&#160;</td>
          <td class="paramname"><em>p</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An AutoPtr is usually constructed from a raw pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>A pointer (defaults to NULL).</td></tr>
  </table>
  </dd>
</dl>
<p>This object now <em>owns</em> the object pointed to by <em>p</em>. </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00185">185</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;    : <a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a>(p)</div>
<div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;  {</div>
<div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;    <span class="comment">// Note: we can&#39;t call libmesh_deprecated() here, since global</span></div>
<div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;    <span class="comment">// AutoPtr variables are sometimes created before the libMesh::out</span></div>
<div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;    <span class="comment">// stream is ready.</span></div>
<div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;  }</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_a7e8340fb4f4326ce8496a49f52980374"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">libMesh::AutoPtr::_ptr</a></div><div class="ttdeci">Tp * _ptr</div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00170">auto_ptr.h:170</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a29ea7c5bc4f7cd137cf52a14ea88de52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::<a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An AutoPtr can be constructed from another AutoPtr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Another AutoPtr of the same type.</td></tr>
  </table>
  </dd>
</dl>
<p>This object now <em>owns</em> the object previously owned by <em>a</em>, which has given up ownsership. </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00200">200</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;    : <a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a>(a.release())</div>
<div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;  {</div>
<div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;  }</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_a7e8340fb4f4326ce8496a49f52980374"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">libMesh::AutoPtr::_ptr</a></div><div class="ttdeci">Tp * _ptr</div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00170">auto_ptr.h:170</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a67b25a1da420a9ce5d0990fcadc3b04f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<div class="memtemplate">
template&lt;typename Tp1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::<a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a>&lt; Tp1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An AutoPtr can be constructed from another AutoPtr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Another AutoPtr of a different but related type.</td></tr>
  </table>
  </dd>
</dl>
<p>A pointer-to-Tp1 must be convertible to a pointer-to-Tp/element_type.</p>
<p>This object now <em>owns</em> the object previously owned by <em>a</em>, which has given up ownsership. </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00215">215</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;    : <a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a>(a.release())</div>
<div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;  {</div>
<div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;  }</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_a7e8340fb4f4326ce8496a49f52980374"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">libMesh::AutoPtr::_ptr</a></div><div class="ttdeci">Tp * _ptr</div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00170">auto_ptr.h:170</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6c0e9fbbfdd93f5dd0b1a2c580d36202"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::~<a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When the AutoPtr goes out of scope, the object it owns is deleted. If it no longer owns anything (i.e., <code><a class="el" href="classlibMesh_1_1AutoPtr.html#a47c8f66bc54219761cefe575c26a81dd" title="Bypassing the smart pointer. ">get()</a></code> is <code>NULL</code>), then this has no effect.</p>
<p>maint </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00265">265</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>

<p>References <a class="el" href="auto__ptr_8h_source.html#l00170">libMesh::AutoPtr&lt; Tp &gt;::_ptr</a>, <a class="el" href="libmesh__common_8h_source.html#l00231">libMesh::out</a>, and <a class="el" href="namespacelibMesh.html#a27a859c2c661c6945f90683fe578b7f6">libMesh::warned_about_auto_ptr</a>.</p>
<div class="fragment"><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;  {</div>
<div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;    <span class="keywordflow">if</span> (!<a class="code" href="namespacelibMesh.html#a27a859c2c661c6945f90683fe578b7f6">libMesh::warned_about_auto_ptr</a>)</div>
<div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;      {</div>
<div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;        <a class="code" href="namespacelibMesh.html#a27a859c2c661c6945f90683fe578b7f6">libMesh::warned_about_auto_ptr</a> = <span class="keyword">true</span>;</div>
<div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;        <a class="code" href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a> &lt;&lt; <span class="stringliteral">&quot;*** Warning, AutoPtr is deprecated and will be removed in a future library version! &quot;</span></div>
<div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;                     &lt;&lt; __FILE__ &lt;&lt; <span class="stringliteral">&quot;, line &quot;</span> &lt;&lt; __LINE__ &lt;&lt; <span class="stringliteral">&quot;, compiled &quot;</span> &lt;&lt; __DATE__ &lt;&lt; <span class="stringliteral">&quot; at &quot;</span> &lt;&lt; __TIME__ &lt;&lt; <span class="stringliteral">&quot; ***&quot;</span> &lt;&lt; std::endl;</div>
<div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;      }</div>
<div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;    <span class="keyword">delete</span> <a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a>;</div>
<div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;  }</div>
<div class="ttc" id="namespacelibMesh_html_a27a859c2c661c6945f90683fe578b7f6"><div class="ttname"><a href="namespacelibMesh.html#a27a859c2c661c6945f90683fe578b7f6">libMesh::warned_about_auto_ptr</a></div><div class="ttdeci">bool warned_about_auto_ptr</div></div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_a7e8340fb4f4326ce8496a49f52980374"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">libMesh::AutoPtr::_ptr</a></div><div class="ttdeci">Tp * _ptr</div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00170">auto_ptr.h:170</a></div></div>
<div class="ttc" id="namespacelibMesh_html_a63e3c3158308e2184c12b55ab9ea9a35"><div class="ttname"><a href="namespacelibMesh.html#a63e3c3158308e2184c12b55ab9ea9a35">libMesh::out</a></div><div class="ttdeci">OStreamProxy out(std::cout)</div><div class="ttdef"><b>Definition:</b> <a href="libmesh__common_8h_source.html#l00231">libmesh_common.h:231</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac87f7a29cee79240f59b9fe132212640"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::<a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlibMesh_1_1AutoPtrRef.html">AutoPtrRef</a>&lt; <a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Automatic conversions. </p>
<p>These operations convert an AutoPtr into and from an <a class="el" href="structlibMesh_1_1AutoPtrRef.html">AutoPtrRef</a> automatically as needed. This allows constructs such as </p><div class="fragment"><div class="line">AutoPtr&lt;Derived&gt;  func_returning_AutoPtr(.....);</div>
<div class="line">...</div>
<div class="line">AutoPtr&lt;Base&gt; ptr = func_returning_AutoPtr(.....);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00356">356</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00357"></a><span class="lineno">  357</span>&#160;    : <a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a>(ref._ptr) {}</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_a7e8340fb4f4326ce8496a49f52980374"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">libMesh::AutoPtr::_ptr</a></div><div class="ttdeci">Tp * _ptr</div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00170">auto_ptr.h:170</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a4ecac20f5c1754c5ed4b9afd63f2bd03"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::boolean_test </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A "safe" replacement for operator bool () that behaves more like an explicit conversion operator even in C++98. This allows code like if (!foo) to work with <a class="el" href="classlibMesh_1_1AutoPtr.html" title="A simple smart pointer providing strict ownership semantics. ">AutoPtr</a>. </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00381">381</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00382"></a><span class="lineno">  382</span>&#160;  {</div>
<div class="line"><a name="l00383"></a><span class="lineno">  383</span>&#160;    <span class="keywordflow">return</span> (this-&gt;<span class="keyword">get</span>() != NULL);</div>
<div class="line"><a name="l00384"></a><span class="lineno">  384</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a47c8f66bc54219761cefe575c26a81dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a>* <a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bypassing the smart pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>The raw pointer being managed.</dd></dl>
<p>You can get a copy of the pointer that this object owns, for situations such as passing to a function which only accepts a raw pointer.</p>
<dl class="section note"><dt>Note</dt><dd>This AutoPtr still owns the memory. </dd></dl>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00307">307</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>

<p>References <a class="el" href="auto__ptr_8h_source.html#l00170">libMesh::AutoPtr&lt; Tp &gt;::_ptr</a>.</p>
<div class="fragment"><div class="line"><a name="l00307"></a><span class="lineno">  307</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a>; }</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_a7e8340fb4f4326ce8496a49f52980374"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">libMesh::AutoPtr::_ptr</a></div><div class="ttdeci">Tp * _ptr</div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00170">auto_ptr.h:170</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6b070154b91cb631accf241a322b5fbd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<div class="memtemplate">
template&lt;typename Tp1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::operator <a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a>&lt; Tp1 &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>op() for AutoPtr&lt;Tp1&gt;. Calls the release member. </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00397">397</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>

<p>References <a class="el" href="auto__ptr_8h_source.html#l00321">libMesh::AutoPtr&lt; Tp &gt;::release()</a>.</p>
<div class="fragment"><div class="line"><a name="l00398"></a><span class="lineno">  398</span>&#160;  { <span class="keywordflow">return</span> AutoPtr&lt;Tp1&gt;(this-&gt;<a class="code" href="classlibMesh_1_1AutoPtr.html#a9aac56a85f0e34e52bd3ebf05f244526">release</a>()); }</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_a9aac56a85f0e34e52bd3ebf05f244526"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#a9aac56a85f0e34e52bd3ebf05f244526">libMesh::AutoPtr::release</a></div><div class="ttdeci">element_type * release()</div><div class="ttdoc">Bypassing the smart pointer. </div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00321">auto_ptr.h:321</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0bdbe1f868c4d3e96fcafe98e873b679"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<div class="memtemplate">
template&lt;typename Tp1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::operator <a class="el" href="structlibMesh_1_1AutoPtrRef.html">AutoPtrRef</a>&lt; Tp1 &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>op() for AutoPtrRef&lt;Tp1&gt;. Calls the release member. </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00390">390</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>

<p>References <a class="el" href="auto__ptr_8h_source.html#l00321">libMesh::AutoPtr&lt; Tp &gt;::release()</a>.</p>
<div class="fragment"><div class="line"><a name="l00391"></a><span class="lineno">  391</span>&#160;  { <span class="keywordflow">return</span> AutoPtrRef&lt;Tp1&gt;(this-&gt;<a class="code" href="classlibMesh_1_1AutoPtr.html#a9aac56a85f0e34e52bd3ebf05f244526">release</a>()); }</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_a9aac56a85f0e34e52bd3ebf05f244526"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#a9aac56a85f0e34e52bd3ebf05f244526">libMesh::AutoPtr::release</a></div><div class="ttdeci">element_type * release()</div><div class="ttdoc">Bypassing the smart pointer. </div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00321">auto_ptr.h:321</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a13378fcb4705c5722893eee224398100"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1safe__bool.html">libMesh::safe_bool</a>&lt; <a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a>&lt; Tp &gt;  &gt;::operator <a class="el" href="classlibMesh_1_1safe__bool__base.html#a3306f2fd8584165024f5d662dd93dc4f">bool_type</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="safe__bool_8h_source.html#l00065">65</a> of file <a class="el" href="safe__bool_8h_source.html">safe_bool.h</a>.</p>

<p>References <a class="el" href="safe__bool_8h_source.html#l00048">libMesh::safe_bool_base::this_type_does_not_support_comparisons()</a>.</p>
<div class="fragment"><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;  {</div>
<div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;    <span class="keywordflow">return</span> (static_cast&lt;const T*&gt;(<span class="keyword">this</span>))-&gt;boolean_test()</div>
<div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;      ? &amp;safe_bool_base::this_type_does_not_support_comparisons : 0;</div>
<div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;  }</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a280cc923315c8202a9d1b5613157a58e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a>&amp; <a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Smart pointer dereferencing. </p>
<p>If this AutoPtr no longer owns anything, then this operation will crash. (For a smart pointer, "no longer owns anything" is the same as being a null pointer, and you know what happens when you dereference one of those...) </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00285">285</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>

<p>References <a class="el" href="auto__ptr_8h_source.html#l00170">libMesh::AutoPtr&lt; Tp &gt;::_ptr</a>.</p>
<div class="fragment"><div class="line"><a name="l00285"></a><span class="lineno">  285</span>&#160;{ <span class="keywordflow">return</span> *<a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a>; }</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_a7e8340fb4f4326ce8496a49f52980374"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">libMesh::AutoPtr::_ptr</a></div><div class="ttdeci">Tp * _ptr</div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00170">auto_ptr.h:170</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a05a072981e5044e4d87143a5b5841c5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a>* <a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Smart pointer dereferencing. </p>
<p>This returns the pointer itself, which the language then will automatically cause to be dereferenced. </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00294">294</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>

<p>References <a class="el" href="auto__ptr_8h_source.html#l00170">libMesh::AutoPtr&lt; Tp &gt;::_ptr</a>.</p>
<div class="fragment"><div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a>; }</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_a7e8340fb4f4326ce8496a49f52980374"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">libMesh::AutoPtr::_ptr</a></div><div class="ttdeci">Tp * _ptr</div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00170">auto_ptr.h:170</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae1b5eb5ed5b453121b0a6db973ff9d72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a>&amp; <a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>AutoPtr assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Another AutoPtr of the same type.</td></tr>
  </table>
  </dd>
</dl>
<p>This object now <em>owns</em> the object previously owned by <em>a</em>, which has given up ownsership. The object that this one <em>used</em> to own and track has been deleted. </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00229">229</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>

<p>References <a class="el" href="auto__ptr_8h_source.html#l00321">libMesh::AutoPtr&lt; Tp &gt;::release()</a>, and <a class="el" href="auto__ptr_8h_source.html#l00336">libMesh::AutoPtr&lt; Tp &gt;::reset()</a>.</p>
<div class="fragment"><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;  {</div>
<div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    <a class="code" href="classlibMesh_1_1AutoPtr.html#aca7dac34d00cd798c43629794345a09c">reset</a>(a.release());</div>
<div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;  }</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_aca7dac34d00cd798c43629794345a09c"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#aca7dac34d00cd798c43629794345a09c">libMesh::AutoPtr::reset</a></div><div class="ttdeci">void reset(element_type *p=0)</div><div class="ttdoc">Forcibly deletes the managed object. </div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00336">auto_ptr.h:336</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7e04b7d615d01081d22c445ae27deff5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<div class="memtemplate">
template&lt;typename Tp1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a>&amp; <a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a>&lt; Tp1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>AutoPtr assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Another AutoPtr of a different but related type.</td></tr>
  </table>
  </dd>
</dl>
<p>A pointer-to-Tp1 must be convertible to a pointer-to-Tp/element_type.</p>
<p>This object now <em>owns</em> the object previously owned by <em>a</em>, which has given up ownsership. The object that this one <em>used</em> to own and track has been deleted. </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00247">247</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>

<p>References <a class="el" href="auto__ptr_8h_source.html#l00321">libMesh::AutoPtr&lt; Tp &gt;::release()</a>, and <a class="el" href="auto__ptr_8h_source.html#l00336">libMesh::AutoPtr&lt; Tp &gt;::reset()</a>.</p>
<div class="fragment"><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;  {</div>
<div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;    <a class="code" href="classlibMesh_1_1AutoPtr.html#aca7dac34d00cd798c43629794345a09c">reset</a>(a.release());</div>
<div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;  }</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_aca7dac34d00cd798c43629794345a09c"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#aca7dac34d00cd798c43629794345a09c">libMesh::AutoPtr::reset</a></div><div class="ttdeci">void reset(element_type *p=0)</div><div class="ttdoc">Forcibly deletes the managed object. </div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00336">auto_ptr.h:336</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abc2d725cb78d2dafc1e80d847d62c487"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a>&amp; <a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlibMesh_1_1AutoPtrRef.html">AutoPtrRef</a>&lt; <a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>op= for <a class="el" href="classlibMesh_1_1AutoPtr.html" title="A simple smart pointer providing strict ownership semantics. ">AutoPtr</a>. Allows you to write: </p><div class="fragment"><div class="line">AutoPtr&lt;Base&gt; ptr = func_returning_AutoPtr(.....);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00366">366</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>

<p>References <a class="el" href="auto__ptr_8h_source.html#l00084">libMesh::AutoPtrRef&lt; Tp1 &gt;::_ptr</a>, and <a class="el" href="auto__ptr_8h_source.html#l00170">libMesh::AutoPtr&lt; Tp &gt;::_ptr</a>.</p>
<div class="fragment"><div class="line"><a name="l00367"></a><span class="lineno">  367</span>&#160;  {</div>
<div class="line"><a name="l00368"></a><span class="lineno">  368</span>&#160;    <span class="keywordflow">if</span> (ref._ptr != this-&gt;get())</div>
<div class="line"><a name="l00369"></a><span class="lineno">  369</span>&#160;      {</div>
<div class="line"><a name="l00370"></a><span class="lineno">  370</span>&#160;        <span class="keyword">delete</span> <a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a>;</div>
<div class="line"><a name="l00371"></a><span class="lineno">  371</span>&#160;        <a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a> = ref._ptr;</div>
<div class="line"><a name="l00372"></a><span class="lineno">  372</span>&#160;      }</div>
<div class="line"><a name="l00373"></a><span class="lineno">  373</span>&#160;    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00374"></a><span class="lineno">  374</span>&#160;  }</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_a7e8340fb4f4326ce8496a49f52980374"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">libMesh::AutoPtr::_ptr</a></div><div class="ttdeci">Tp * _ptr</div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00170">auto_ptr.h:170</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9aac56a85f0e34e52bd3ebf05f244526"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a>* <a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bypassing the smart pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>The raw pointer being managed.</dd></dl>
<p>You can get a copy of the pointer that this object owns, for situations such as passing to a function which only accepts a raw pointer.</p>
<dl class="section note"><dt>Note</dt><dd>This AutoPtr no longer owns the memory. When this object goes out of scope, nothing will happen. </dd></dl>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00321">321</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>

<p>References <a class="el" href="auto__ptr_8h_source.html#l00170">libMesh::AutoPtr&lt; Tp &gt;::_ptr</a>.</p>

<p>Referenced by <a class="el" href="auto__ptr_8h_source.html#l00397">libMesh::AutoPtr&lt; Tp &gt;::operator AutoPtr&lt; Tp1 &gt;()</a>, <a class="el" href="auto__ptr_8h_source.html#l00390">libMesh::AutoPtr&lt; Tp &gt;::operator AutoPtrRef&lt; Tp1 &gt;()</a>, and <a class="el" href="auto__ptr_8h_source.html#l00229">libMesh::AutoPtr&lt; Tp &gt;::operator=()</a>.</p>
<div class="fragment"><div class="line"><a name="l00322"></a><span class="lineno">  322</span>&#160;  {</div>
<div class="line"><a name="l00323"></a><span class="lineno">  323</span>&#160;    <a class="code" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a>* tmp = <a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a>;</div>
<div class="line"><a name="l00324"></a><span class="lineno">  324</span>&#160;    <a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a> = 0;</div>
<div class="line"><a name="l00325"></a><span class="lineno">  325</span>&#160;    <span class="keywordflow">return</span> tmp;</div>
<div class="line"><a name="l00326"></a><span class="lineno">  326</span>&#160;  }</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_af7d6809e6bdb84d790ad2ef11afe3fa6"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">libMesh::AutoPtr::element_type</a></div><div class="ttdeci">Tp element_type</div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00176">auto_ptr.h:176</a></div></div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_a7e8340fb4f4326ce8496a49f52980374"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">libMesh::AutoPtr::_ptr</a></div><div class="ttdeci">Tp * _ptr</div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00170">auto_ptr.h:170</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aca7dac34d00cd798c43629794345a09c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a> *&#160;</td>
          <td class="paramname"><em>p</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forcibly deletes the managed object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>A pointer (defaults to NULL).</td></tr>
  </table>
  </dd>
</dl>
<p>This object now <em>owns</em> the object pointed to by <em>p</em>. The previous object has been deleted. </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00336">336</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>

<p>References <a class="el" href="auto__ptr_8h_source.html#l00170">libMesh::AutoPtr&lt; Tp &gt;::_ptr</a>.</p>

<p>Referenced by <a class="el" href="auto__ptr_8h_source.html#l00229">libMesh::AutoPtr&lt; Tp &gt;::operator=()</a>.</p>
<div class="fragment"><div class="line"><a name="l00337"></a><span class="lineno">  337</span>&#160;  {</div>
<div class="line"><a name="l00338"></a><span class="lineno">  338</span>&#160;    <span class="keywordflow">if</span> (p != <a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a>)</div>
<div class="line"><a name="l00339"></a><span class="lineno">  339</span>&#160;      {</div>
<div class="line"><a name="l00340"></a><span class="lineno">  340</span>&#160;        <span class="keyword">delete</span> <a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a>;</div>
<div class="line"><a name="l00341"></a><span class="lineno">  341</span>&#160;        <a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a> = p;</div>
<div class="line"><a name="l00342"></a><span class="lineno">  342</span>&#160;      }</div>
<div class="line"><a name="l00343"></a><span class="lineno">  343</span>&#160;  }</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_a7e8340fb4f4326ce8496a49f52980374"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">libMesh::AutoPtr::_ptr</a></div><div class="ttdeci">Tp * _ptr</div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00170">auto_ptr.h:170</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a7e8340fb4f4326ce8496a49f52980374"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tp* <a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::_ptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The actual dumb pointer this class wraps. </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00170">170</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>

<p>Referenced by <a class="el" href="auto__ptr_8h_source.html#l00307">libMesh::AutoPtr&lt; Tp &gt;::get()</a>, <a class="el" href="auto__ptr_8h_source.html#l00285">libMesh::AutoPtr&lt; Tp &gt;::operator*()</a>, <a class="el" href="auto__ptr_8h_source.html#l00294">libMesh::AutoPtr&lt; Tp &gt;::operator-&gt;()</a>, <a class="el" href="auto__ptr_8h_source.html#l00366">libMesh::AutoPtr&lt; Tp &gt;::operator=()</a>, <a class="el" href="auto__ptr_8h_source.html#l00321">libMesh::AutoPtr&lt; Tp &gt;::release()</a>, <a class="el" href="auto__ptr_8h_source.html#l00336">libMesh::AutoPtr&lt; Tp &gt;::reset()</a>, and <a class="el" href="auto__ptr_8h_source.html#l00265">libMesh::AutoPtr&lt; Tp &gt;::~AutoPtr()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
generated by <a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a>
</small></address>
<!-- dynamic header stuff -->
<script type="text/javascript">
$(document).ready(function(){
  $(window).on('scroll',function() {
    var scrolltop = $(this).scrollTop();
    if(scrolltop >= 215) {
      $('#fixedbar').fadeIn(250);
    }
    else if(scrolltop <= 210) {
      $('#fixedbar').fadeOut(250);
    }
  });
});
</script>
<!-- Google Analytics stuff -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-24978333-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</body>
</html>
