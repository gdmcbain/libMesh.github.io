<!-- HTML header for doxygen -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libMesh: libMesh::AutoPtr&lt; Tp &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="../styles.css" rel="stylesheet" type="text/css" />
<link href="doxygen_stylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
  <nav id="fixedbar">
    <ul id="fixednav">
      <li><a href="../index.html">Home</a></li>
      <li><a href="../support.html">About Us</a></li>
      <li><a href="../publications.html">Publications</a></li>
      <li><a href="../developers.html">Developers</a></li>
      <li><a href="../installation.html">Installation</a></li>
      <li><a href="../examples.html">Examples</a></li>
      <li><a href="../doxygen/index.html">Documentation</a></li>
    </ul>
  </nav>
  <div id="w">
    <header id="logo"><a href="index.html"><span id="logobg">SomeWebsiteLogo</span></a></header>
    <nav id="navigation">
      <ul>
        <li><a href="../index.html">Home</a></li>
        <li><a href="../support.html">About Us</a></li>
        <li><a href="../publications.html">Publications</a></li>
        <li><a href="../developers.html">Developers</a></li>
        <li><a href="../installation.html">Installation</a></li>
        <li><a href="../examples.html">Examples</a></li>
        <li><a href="../doxygen/index.html">Documentation</a></li>
      </ul>
    </nav>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- <\!--BEGIN TITLEAREA-\-> -->
<!-- <div id="titlearea"> -->
<!-- <table cellspacing="0" cellpadding="0"> -->
<!--  <tbody> -->
<!--  <tr style="height: 56px;"> -->
<!--   <\!--BEGIN PROJECT_LOGO-\-> -->
<!--   <td id="projectlogo"><img alt="Logo" src=""/></td> -->
<!--   <\!--END PROJECT_LOGO-\-> -->
<!--   <\!--BEGIN PROJECT_NAME-\-> -->
<!--   <td style="padding-left: 0.5em;"> -->
<!--    <div id="projectname">libMesh -->
<!--    <\!--BEGIN PROJECT_NUMBER-\->&#160;<span id="projectnumber"></span><\!--END PROJECT_NUMBER-\-> -->
<!--    </div> -->
<!--    <\!--BEGIN PROJECT_BRIEF-\-><div id="projectbrief"></div><\!--END PROJECT_BRIEF-\-> -->
<!--   </td> -->
<!--   <\!--END PROJECT_NAME-\-> -->
<!--   <\!--BEGIN !PROJECT_NAME-\-> -->
<!--    <\!--BEGIN PROJECT_BRIEF-\-> -->
<!--     <td style="padding-left: 0.5em;"> -->
<!--     <div id="projectbrief"></div> -->
<!--     </td> -->
<!--    <\!--END PROJECT_BRIEF-\-> -->
<!--   <\!--END !PROJECT_NAME-\-> -->
<!--   <\!--BEGIN DISABLE_INDEX-\-> -->
<!--    <\!--BEGIN SEARCHENGINE-\-> -->
<!--    <td></td> -->
<!--    <\!--END SEARCHENGINE-\-> -->
<!--   <\!--END DISABLE_INDEX-\-> -->
<!--  </tr> -->
<!--  </tbody> -->
<!-- </table> -->
<!-- </div> -->
<!-- <\!--END TITLEAREA-\-> -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacelibMesh.html">libMesh</a></li><li class="navelem"><a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classlibMesh_1_1AutoPtr-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">libMesh::AutoPtr&lt; Tp &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A simple smart pointer providing strict ownership semantics.  
 <a href="classlibMesh_1_1AutoPtr.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af7d6809e6bdb84d790ad2ef11afe3fa6"><td class="memItemLeft" align="right" valign="top">typedef Tp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a></td></tr>
<tr class="separator:af7d6809e6bdb84d790ad2ef11afe3fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6e5b3ce1fc0f9d76bb6b55e79342910c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#a6e5b3ce1fc0f9d76bb6b55e79342910c">AutoPtr</a> (<a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a> *p=0)</td></tr>
<tr class="memdesc:a6e5b3ce1fc0f9d76bb6b55e79342910c"><td class="mdescLeft">&#160;</td><td class="mdescRight">An AutoPtr is usually constructed from a raw pointer.  <a href="#a6e5b3ce1fc0f9d76bb6b55e79342910c">More...</a><br /></td></tr>
<tr class="separator:a6e5b3ce1fc0f9d76bb6b55e79342910c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ea7c5bc4f7cd137cf52a14ea88de52"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#a29ea7c5bc4f7cd137cf52a14ea88de52">AutoPtr</a> (<a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a> &amp;a)</td></tr>
<tr class="memdesc:a29ea7c5bc4f7cd137cf52a14ea88de52"><td class="mdescLeft">&#160;</td><td class="mdescRight">An AutoPtr can be constructed from another AutoPtr.  <a href="#a29ea7c5bc4f7cd137cf52a14ea88de52">More...</a><br /></td></tr>
<tr class="separator:a29ea7c5bc4f7cd137cf52a14ea88de52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67b25a1da420a9ce5d0990fcadc3b04f"><td class="memTemplParams" colspan="2">template&lt;typename Tp1 &gt; </td></tr>
<tr class="memitem:a67b25a1da420a9ce5d0990fcadc3b04f"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#a67b25a1da420a9ce5d0990fcadc3b04f">AutoPtr</a> (<a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a>&lt; Tp1 &gt; &amp;a)</td></tr>
<tr class="memdesc:a67b25a1da420a9ce5d0990fcadc3b04f"><td class="mdescLeft">&#160;</td><td class="mdescRight">An AutoPtr can be constructed from another AutoPtr.  <a href="#a67b25a1da420a9ce5d0990fcadc3b04f">More...</a><br /></td></tr>
<tr class="separator:a67b25a1da420a9ce5d0990fcadc3b04f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1b5eb5ed5b453121b0a6db973ff9d72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#ae1b5eb5ed5b453121b0a6db973ff9d72">operator=</a> (<a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a> &amp;a)</td></tr>
<tr class="memdesc:ae1b5eb5ed5b453121b0a6db973ff9d72"><td class="mdescLeft">&#160;</td><td class="mdescRight">AutoPtr assignment operator.  <a href="#ae1b5eb5ed5b453121b0a6db973ff9d72">More...</a><br /></td></tr>
<tr class="separator:ae1b5eb5ed5b453121b0a6db973ff9d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e04b7d615d01081d22c445ae27deff5"><td class="memTemplParams" colspan="2">template&lt;typename Tp1 &gt; </td></tr>
<tr class="memitem:a7e04b7d615d01081d22c445ae27deff5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#a7e04b7d615d01081d22c445ae27deff5">operator=</a> (<a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a>&lt; Tp1 &gt; &amp;a)</td></tr>
<tr class="memdesc:a7e04b7d615d01081d22c445ae27deff5"><td class="mdescLeft">&#160;</td><td class="mdescRight">AutoPtr assignment operator.  <a href="#a7e04b7d615d01081d22c445ae27deff5">More...</a><br /></td></tr>
<tr class="separator:a7e04b7d615d01081d22c445ae27deff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c0e9fbbfdd93f5dd0b1a2c580d36202"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#a6c0e9fbbfdd93f5dd0b1a2c580d36202">~AutoPtr</a> ()</td></tr>
<tr class="separator:a6c0e9fbbfdd93f5dd0b1a2c580d36202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a280cc923315c8202a9d1b5613157a58e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#a280cc923315c8202a9d1b5613157a58e">operator*</a> () const </td></tr>
<tr class="memdesc:a280cc923315c8202a9d1b5613157a58e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer dereferencing.  <a href="#a280cc923315c8202a9d1b5613157a58e">More...</a><br /></td></tr>
<tr class="separator:a280cc923315c8202a9d1b5613157a58e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a072981e5044e4d87143a5b5841c5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#a05a072981e5044e4d87143a5b5841c5a">operator-&gt;</a> () const </td></tr>
<tr class="memdesc:a05a072981e5044e4d87143a5b5841c5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smart pointer dereferencing.  <a href="#a05a072981e5044e4d87143a5b5841c5a">More...</a><br /></td></tr>
<tr class="separator:a05a072981e5044e4d87143a5b5841c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c8f66bc54219761cefe575c26a81dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#a47c8f66bc54219761cefe575c26a81dd">get</a> () const </td></tr>
<tr class="memdesc:a47c8f66bc54219761cefe575c26a81dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bypassing the smart pointer.  <a href="#a47c8f66bc54219761cefe575c26a81dd">More...</a><br /></td></tr>
<tr class="separator:a47c8f66bc54219761cefe575c26a81dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9aac56a85f0e34e52bd3ebf05f244526"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#a9aac56a85f0e34e52bd3ebf05f244526">release</a> ()</td></tr>
<tr class="memdesc:a9aac56a85f0e34e52bd3ebf05f244526"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bypassing the smart pointer.  <a href="#a9aac56a85f0e34e52bd3ebf05f244526">More...</a><br /></td></tr>
<tr class="separator:a9aac56a85f0e34e52bd3ebf05f244526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7dac34d00cd798c43629794345a09c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#aca7dac34d00cd798c43629794345a09c">reset</a> (<a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a> *p=0)</td></tr>
<tr class="memdesc:aca7dac34d00cd798c43629794345a09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forcibly deletes the managed object.  <a href="#aca7dac34d00cd798c43629794345a09c">More...</a><br /></td></tr>
<tr class="separator:aca7dac34d00cd798c43629794345a09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:ac87f7a29cee79240f59b9fe132212640"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#ac87f7a29cee79240f59b9fe132212640">AutoPtr</a> (<a class="el" href="structlibMesh_1_1AutoPtrRef.html">AutoPtrRef</a>&lt; <a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a> &gt; ref)</td></tr>
<tr class="memdesc:ac87f7a29cee79240f59b9fe132212640"><td class="mdescLeft">&#160;</td><td class="mdescRight">Automatic conversions.  <a href="#ac87f7a29cee79240f59b9fe132212640">More...</a><br /></td></tr>
<tr class="separator:ac87f7a29cee79240f59b9fe132212640"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2d725cb78d2dafc1e80d847d62c487"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#abc2d725cb78d2dafc1e80d847d62c487">operator=</a> (<a class="el" href="structlibMesh_1_1AutoPtrRef.html">AutoPtrRef</a>&lt; <a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a> &gt; ref)</td></tr>
<tr class="separator:abc2d725cb78d2dafc1e80d847d62c487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bdbe1f868c4d3e96fcafe98e873b679"><td class="memTemplParams" colspan="2">template&lt;typename Tp1 &gt; </td></tr>
<tr class="memitem:a0bdbe1f868c4d3e96fcafe98e873b679"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#a0bdbe1f868c4d3e96fcafe98e873b679">operator AutoPtrRef&lt; Tp1 &gt;</a> ()</td></tr>
<tr class="separator:a0bdbe1f868c4d3e96fcafe98e873b679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b070154b91cb631accf241a322b5fbd"><td class="memTemplParams" colspan="2">template&lt;typename Tp1 &gt; </td></tr>
<tr class="memitem:a6b070154b91cb631accf241a322b5fbd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#a6b070154b91cb631accf241a322b5fbd">operator AutoPtr&lt; Tp1 &gt;</a> ()</td></tr>
<tr class="separator:a6b070154b91cb631accf241a322b5fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7e8340fb4f4326ce8496a49f52980374"><td class="memItemLeft" align="right" valign="top">Tp *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a></td></tr>
<tr class="separator:a7e8340fb4f4326ce8496a49f52980374"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Tp&gt;<br />
class libMesh::AutoPtr&lt; Tp &gt;</h3>

<p>A simple smart pointer providing strict ownership semantics. </p>
<p>The Standard says: </p><pre>
 An <code><a class="el" href="classlibMesh_1_1AutoPtr.html" title="A simple smart pointer providing strict ownership semantics. ">AutoPtr</a></code> owns the object it holds a pointer to.  Copying an
 <code><a class="el" href="classlibMesh_1_1AutoPtr.html" title="A simple smart pointer providing strict ownership semantics. ">AutoPtr</a></code> copies the pointer and transfers ownership to the destination.
 If more than one <code><a class="el" href="classlibMesh_1_1AutoPtr.html" title="A simple smart pointer providing strict ownership semantics. ">AutoPtr</a></code> owns the same object at the same time the
 behavior of the program is undefined.</pre><pre> The uses of <code><a class="el" href="classlibMesh_1_1AutoPtr.html" title="A simple smart pointer providing strict ownership semantics. ">AutoPtr</a></code> include providing temporary exception-safety for
 dynamically allocated memory, passing ownership of dynamically allocated
 memory to a function, and returning dynamically allocated memory from a
 function.  <code><a class="el" href="classlibMesh_1_1AutoPtr.html" title="A simple smart pointer providing strict ownership semantics. ">AutoPtr</a></code> does not meet the CopyConstructible and Assignable
 requirements for Standard Library <a href="tables.html#65">container</a>
 elements and thus instantiating a Standard Library container with an
 <code><a class="el" href="classlibMesh_1_1AutoPtr.html" title="A simple smart pointer providing strict ownership semantics. ">AutoPtr</a></code> results in undefined behavior.
 </pre><p> Quoted from [20.4.5]/3.</p>
<p>This class is adopted from the GCC 3.2.1 source tree and should function as a replacement for <code>std::auto_ptr&lt;&gt;</code>. Unfortunately the <code>std::auto_ptr&lt;&gt;</code> is not particularly portable since various compilers implement various revisions of the standard. Using <code>AutoPtr&lt;&gt;</code> instead of <code>std::auto_ptr&lt;&gt;</code> allows for easy portability. </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00102">102</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="af7d6809e6bdb84d790ad2ef11afe3fa6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">typedef Tp <a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::<a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The pointed-to type. </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00115">115</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a6e5b3ce1fc0f9d76bb6b55e79342910c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::<a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a> *&#160;</td>
          <td class="paramname"><em>p</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An AutoPtr is usually constructed from a raw pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>A pointer (defaults to NULL).</td></tr>
  </table>
  </dd>
</dl>
<p>This object now <em>owns</em> the object pointed to by <em>p</em>. </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00124">124</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;    : <a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a>(p) {}</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_a7e8340fb4f4326ce8496a49f52980374"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">libMesh::AutoPtr::_ptr</a></div><div class="ttdeci">Tp * _ptr</div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00109">auto_ptr.h:109</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a29ea7c5bc4f7cd137cf52a14ea88de52"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::<a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An AutoPtr can be constructed from another AutoPtr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Another AutoPtr of the same type.</td></tr>
  </table>
  </dd>
</dl>
<p>This object now <em>owns</em> the object previously owned by <em>a</em>, which has given up ownsership. </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00134">134</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;    : <a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a>(a.release()) {}</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_a7e8340fb4f4326ce8496a49f52980374"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">libMesh::AutoPtr::_ptr</a></div><div class="ttdeci">Tp * _ptr</div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00109">auto_ptr.h:109</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a67b25a1da420a9ce5d0990fcadc3b04f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<div class="memtemplate">
template&lt;typename Tp1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::<a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a>&lt; Tp1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>An AutoPtr can be constructed from another AutoPtr. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Another AutoPtr of a different but related type.</td></tr>
  </table>
  </dd>
</dl>
<p>A pointer-to-Tp1 must be convertible to a pointer-to-Tp/element_type.</p>
<p>This object now <em>owns</em> the object previously owned by <em>a</em>, which has given up ownsership. </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00147">147</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;    : <a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a>(a.release()) {}</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_a7e8340fb4f4326ce8496a49f52980374"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">libMesh::AutoPtr::_ptr</a></div><div class="ttdeci">Tp * _ptr</div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00109">auto_ptr.h:109</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6c0e9fbbfdd93f5dd0b1a2c580d36202"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::~<a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When the AutoPtr goes out of scope, the object it owns is deleted. If it no longer owns anything (i.e., <code><a class="el" href="classlibMesh_1_1AutoPtr.html#a47c8f66bc54219761cefe575c26a81dd" title="Bypassing the smart pointer. ">get()</a></code> is <code>NULL</code>), then this has no effect.</p>
<p>maint </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00195">195</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;{ <span class="keyword">delete</span> <a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a>; }</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_a7e8340fb4f4326ce8496a49f52980374"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">libMesh::AutoPtr::_ptr</a></div><div class="ttdeci">Tp * _ptr</div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00109">auto_ptr.h:109</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ac87f7a29cee79240f59b9fe132212640"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::<a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlibMesh_1_1AutoPtrRef.html">AutoPtrRef</a>&lt; <a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Automatic conversions. </p>
<p>These operations convert an AutoPtr into and from an <a class="el" href="structlibMesh_1_1AutoPtrRef.html">AutoPtrRef</a> automatically as needed. This allows constructs such as </p><div class="fragment"><div class="line">AutoPtr&lt;Derived&gt;  func_returning_AutoPtr(.....);</div>
<div class="line">...</div>
<div class="line">AutoPtr&lt;Base&gt; ptr = func_returning_AutoPtr(.....);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00277">277</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;    : <a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a>(ref._ptr) {}</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_a7e8340fb4f4326ce8496a49f52980374"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">libMesh::AutoPtr::_ptr</a></div><div class="ttdeci">Tp * _ptr</div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00109">auto_ptr.h:109</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a47c8f66bc54219761cefe575c26a81dd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a>* <a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bypassing the smart pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>The raw pointer being managed.</dd></dl>
<p>You can get a copy of the pointer that this object owns, for situations such as passing to a function which only accepts a raw pointer.</p>
<dl class="section note"><dt>Note</dt><dd>This AutoPtr still owns the memory. </dd></dl>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00228">228</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>

<p>Referenced by <a class="el" href="exact__solution_8C_source.html#l00508">libMesh::ExactSolution::_compute_error()</a>, <a class="el" href="uniform__refinement__estimator_8C_source.html#l00086">libMesh::UniformRefinementEstimator::_estimate_error()</a>, <a class="el" href="implicit__system_8C_source.html#l00684">libMesh::ImplicitSystem::adjoint_qoi_parameter_sensitivity()</a>, <a class="el" href="dof__map_8C_source.html#l00227">libMesh::DofMap::attach_matrix()</a>, <a class="el" href="system_8C_source.html#l01410">libMesh::System::calculate_norm()</a>, <a class="el" href="dof__map_8C_source.html#l01676">libMesh::DofMap::clear_sparsity()</a>, <a class="el" href="xdr__cxx_8C_source.html#l00277">libMesh::Xdr::close()</a>, <a class="el" href="xdr__cxx_8C_source.html#l01351">libMesh::Xdr::comment()</a>, <a class="el" href="xdr__cxx_8C_source.html#l00614">libMesh::Xdr::data()</a>, <a class="el" href="xdr__cxx_8C_source.html#l00665">libMesh::Xdr::data_stream()</a>, <a class="el" href="xdr__cxx_8C_source.html#l00544">libMesh::Xdr::do_read()</a>, <a class="el" href="xdr__cxx_8C_source.html#l00584">libMesh::Xdr::do_write()</a>, <a class="el" href="elem__cutter_8C_source.html#l00041">libMesh::ElemCutter::ElemCutter()</a>, <a class="el" href="dof__map__constraints_8C_source.html#l01997">libMesh::DofMap::enforce_adjoint_constraints_exactly()</a>, <a class="el" href="dof__map__constraints_8C_source.html#l01895">libMesh::DofMap::enforce_constraints_exactly()</a>, <a class="el" href="exact__error__estimator_8C_source.html#l00241">libMesh::for()</a>, <a class="el" href="inf__fe__map_8C_source.html#l00089">libMesh::InfFE&lt; friend_Dim, friend_T_radial, friend_T_map &gt;::inverse_map()</a>, <a class="el" href="xdr__cxx_8C_source.html#l00346">libMesh::Xdr::is_open()</a>, <a class="el" href="mesh__refinement_8C_source.html#l00957">libMesh::MeshRefinement::make_coarsening_compatible()</a>, <a class="el" href="mesh__refinement_8C_source.html#l01306">libMesh::MeshRefinement::make_refinement_compatible()</a>, <a class="el" href="inf__fe__map_8C_source.html#l00040">libMesh::InfFE&lt; friend_Dim, friend_T_radial, friend_T_map &gt;::map()</a>, <a class="el" href="xdr__cxx_8C_source.html#l00166">libMesh::Xdr::open()</a>, <a class="el" href="postscript__io_8C_source.html#l00239">libMesh::PostscriptIO::plot_quadratic_elem()</a>, <a class="el" href="system__projection_8C_source.html#l00273">libMesh::System::project_vector()</a>, <a class="el" href="parallel__algebra_8h_source.html#l00058">libMesh::Parallel::StandardType&lt; TypeVector&lt; T &gt; &gt;::StandardType()</a>, <a class="el" href="parallel__algebra_8h_source.html#l00137">libMesh::Parallel::StandardType&lt; VectorValue&lt; T &gt; &gt;::StandardType()</a>, <a class="el" href="parallel__algebra_8h_source.html#l00216">libMesh::Parallel::StandardType&lt; Point &gt;::StandardType()</a>, <a class="el" href="mesh__refinement_8C_source.html#l00304">libMesh::MeshRefinement::test_level_one()</a>, and <a class="el" href="system__io_8C_source.html#l01799">libMesh::System::write_serialized_blocked_dof_objects()</a>.</p>
<div class="fragment"><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a>; }</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_a7e8340fb4f4326ce8496a49f52980374"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">libMesh::AutoPtr::_ptr</a></div><div class="ttdeci">Tp * _ptr</div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00109">auto_ptr.h:109</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6b070154b91cb631accf241a322b5fbd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<div class="memtemplate">
template&lt;typename Tp1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::operator <a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a>&lt; Tp1 &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>op() for AutoPtr&lt;Tp1&gt;. Calls the release member. </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00308">308</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00309"></a><span class="lineno">  309</span>&#160;  { <span class="keywordflow">return</span> AutoPtr&lt;Tp1&gt;(this-&gt;<a class="code" href="classlibMesh_1_1AutoPtr.html#a9aac56a85f0e34e52bd3ebf05f244526">release</a>()); }</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_a9aac56a85f0e34e52bd3ebf05f244526"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#a9aac56a85f0e34e52bd3ebf05f244526">libMesh::AutoPtr::release</a></div><div class="ttdeci">element_type * release()</div><div class="ttdoc">Bypassing the smart pointer. </div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00242">auto_ptr.h:242</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0bdbe1f868c4d3e96fcafe98e873b679"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<div class="memtemplate">
template&lt;typename Tp1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::operator <a class="el" href="structlibMesh_1_1AutoPtrRef.html">AutoPtrRef</a>&lt; Tp1 &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>op() for AutoPtrRef&lt;Tp1&gt;. Calls the release member. </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00301">301</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00302"></a><span class="lineno">  302</span>&#160;  { <span class="keywordflow">return</span> AutoPtrRef&lt;Tp1&gt;(this-&gt;<a class="code" href="classlibMesh_1_1AutoPtr.html#a9aac56a85f0e34e52bd3ebf05f244526">release</a>()); }</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_a9aac56a85f0e34e52bd3ebf05f244526"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#a9aac56a85f0e34e52bd3ebf05f244526">libMesh::AutoPtr::release</a></div><div class="ttdeci">element_type * release()</div><div class="ttdoc">Bypassing the smart pointer. </div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00242">auto_ptr.h:242</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a280cc923315c8202a9d1b5613157a58e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a>&amp; <a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Smart pointer dereferencing. </p>
<p>If this AutoPtr no longer owns anything, then this operation will crash. (For a smart pointer, "no longer owns anything" is the same as being a null pointer, and you know what happens when you dereference one of those...) </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00206">206</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;{ <span class="keywordflow">return</span> *<a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a>; }</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_a7e8340fb4f4326ce8496a49f52980374"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">libMesh::AutoPtr::_ptr</a></div><div class="ttdeci">Tp * _ptr</div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00109">auto_ptr.h:109</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a05a072981e5044e4d87143a5b5841c5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a>* <a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::operator-&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Smart pointer dereferencing. </p>
<p>This returns the pointer itself, which the language then will automatically cause to be dereferenced. </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00215">215</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;{ <span class="keywordflow">return</span> <a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a>; }</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_a7e8340fb4f4326ce8496a49f52980374"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">libMesh::AutoPtr::_ptr</a></div><div class="ttdeci">Tp * _ptr</div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00109">auto_ptr.h:109</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae1b5eb5ed5b453121b0a6db973ff9d72"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a>&amp; <a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a>&lt; Tp &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>AutoPtr assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Another AutoPtr of the same type.</td></tr>
  </table>
  </dd>
</dl>
<p>This object now <em>owns</em> the object previously owned by <em>a</em>, which has given up ownsership. The object that this one <em>used</em> to own and track has been deleted. </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00159">159</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;  {</div>
<div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;    <a class="code" href="classlibMesh_1_1AutoPtr.html#aca7dac34d00cd798c43629794345a09c">reset</a>(a.release());</div>
<div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;  }</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_aca7dac34d00cd798c43629794345a09c"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#aca7dac34d00cd798c43629794345a09c">libMesh::AutoPtr::reset</a></div><div class="ttdeci">void reset(element_type *p=0)</div><div class="ttdoc">Forcibly deletes the managed object. </div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00257">auto_ptr.h:257</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7e04b7d615d01081d22c445ae27deff5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<div class="memtemplate">
template&lt;typename Tp1 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a>&amp; <a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a>&lt; Tp1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>AutoPtr assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>Another AutoPtr of a different but related type.</td></tr>
  </table>
  </dd>
</dl>
<p>A pointer-to-Tp1 must be convertible to a pointer-to-Tp/element_type.</p>
<p>This object now <em>owns</em> the object previously owned by <em>a</em>, which has given up ownsership. The object that this one <em>used</em> to own and track has been deleted. </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00177">177</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;  {</div>
<div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;    <a class="code" href="classlibMesh_1_1AutoPtr.html#aca7dac34d00cd798c43629794345a09c">reset</a>(a.release());</div>
<div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;  }</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_aca7dac34d00cd798c43629794345a09c"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#aca7dac34d00cd798c43629794345a09c">libMesh::AutoPtr::reset</a></div><div class="ttdeci">void reset(element_type *p=0)</div><div class="ttdoc">Forcibly deletes the managed object. </div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00257">auto_ptr.h:257</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abc2d725cb78d2dafc1e80d847d62c487"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AutoPtr.html">AutoPtr</a>&amp; <a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlibMesh_1_1AutoPtrRef.html">AutoPtrRef</a>&lt; <a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a> &gt;&#160;</td>
          <td class="paramname"><em>ref</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>op= for <a class="el" href="classlibMesh_1_1AutoPtr.html" title="A simple smart pointer providing strict ownership semantics. ">AutoPtr</a>. Allows you to write: </p><div class="fragment"><div class="line">AutoPtr&lt;Base&gt; ptr = func_returning_AutoPtr(.....);</div>
</div><!-- fragment --> 
<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00287">287</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00288"></a><span class="lineno">  288</span>&#160;  {</div>
<div class="line"><a name="l00289"></a><span class="lineno">  289</span>&#160;    <span class="keywordflow">if</span> (ref._ptr != this-&gt;get())</div>
<div class="line"><a name="l00290"></a><span class="lineno">  290</span>&#160;      {</div>
<div class="line"><a name="l00291"></a><span class="lineno">  291</span>&#160;        <span class="keyword">delete</span> <a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a>;</div>
<div class="line"><a name="l00292"></a><span class="lineno">  292</span>&#160;        <a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a> = ref._ptr;</div>
<div class="line"><a name="l00293"></a><span class="lineno">  293</span>&#160;      }</div>
<div class="line"><a name="l00294"></a><span class="lineno">  294</span>&#160;    <span class="keywordflow">return</span> *<span class="keyword">this</span>;</div>
<div class="line"><a name="l00295"></a><span class="lineno">  295</span>&#160;  }</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_a7e8340fb4f4326ce8496a49f52980374"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">libMesh::AutoPtr::_ptr</a></div><div class="ttdeci">Tp * _ptr</div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00109">auto_ptr.h:109</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9aac56a85f0e34e52bd3ebf05f244526"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a>* <a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::release </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Bypassing the smart pointer. </p>
<dl class="section return"><dt>Returns</dt><dd>The raw pointer being managed.</dd></dl>
<p>You can get a copy of the pointer that this object owns, for situations such as passing to a function which only accepts a raw pointer.</p>
<dl class="section note"><dt>Note</dt><dd>This AutoPtr no longer owns the memory. When this object goes out of scope, nothing will happen. </dd></dl>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00242">242</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>

<p>Referenced by <a class="el" href="inf__fe_8C_source.html#l00103">libMesh::InfFE&lt; friend_Dim, friend_T_radial, friend_T_map &gt;::attach_quadrature_rule()</a>, <a class="el" href="inf__fe__base__radial_8C_source.html#l00036">libMesh::InfFE&lt; friend_Dim, friend_T_radial, friend_T_map &gt;::Base::build_elem()</a>, <a class="el" href="inf__fe_8C_source.html#l00040">libMesh::InfFE&lt; friend_Dim, friend_T_radial, friend_T_map &gt;::InfFE()</a>, <a class="el" href="inf__fe__boundary_8C_source.html#l00127">libMesh::InfFE&lt; friend_Dim, friend_T_radial, friend_T_map &gt;::init_face_shape_functions()</a>, <a class="el" href="auto__ptr_8h_source.html#l00308">libMesh::AutoPtr&lt; libMesh::FETransformationBase&lt; OutputType &gt; &gt;::operator AutoPtr&lt; Tp1 &gt;()</a>, <a class="el" href="auto__ptr_8h_source.html#l00301">libMesh::AutoPtr&lt; libMesh::FETransformationBase&lt; OutputType &gt; &gt;::operator AutoPtrRef&lt; Tp1 &gt;()</a>, <a class="el" href="auto__ptr_8h_source.html#l00159">libMesh::AutoPtr&lt; libMesh::FETransformationBase&lt; OutputType &gt; &gt;::operator=()</a>, and <a class="el" href="inf__fe_8C_source.html#l00146">libMesh::InfFE&lt; friend_Dim, friend_T_radial, friend_T_map &gt;::reinit()</a>.</p>
<div class="fragment"><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;  {</div>
<div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;    <a class="code" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a>* tmp = <a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a>;</div>
<div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;    <a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a> = 0;</div>
<div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;    <span class="keywordflow">return</span> tmp;</div>
<div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;  }</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_af7d6809e6bdb84d790ad2ef11afe3fa6"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">libMesh::AutoPtr::element_type</a></div><div class="ttdeci">Tp element_type</div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00115">auto_ptr.h:115</a></div></div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_a7e8340fb4f4326ce8496a49f52980374"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">libMesh::AutoPtr::_ptr</a></div><div class="ttdeci">Tp * _ptr</div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00109">auto_ptr.h:109</a></div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aca7dac34d00cd798c43629794345a09c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classlibMesh_1_1AutoPtr.html#af7d6809e6bdb84d790ad2ef11afe3fa6">element_type</a> *&#160;</td>
          <td class="paramname"><em>p</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Forcibly deletes the managed object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p</td><td>A pointer (defaults to NULL).</td></tr>
  </table>
  </dd>
</dl>
<p>This object now <em>owns</em> the object pointed to by <em>p</em>. The previous object has been deleted. </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00257">257</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>

<p>Referenced by <a class="el" href="nonlinear__solver_8C_source.html#l00038">libMesh::NonlinearSolver&lt; T &gt;::build()</a>, <a class="el" href="cell__prism6_8C_source.html#l00119">libMesh::Prism6::build_side()</a>, <a class="el" href="cell__pyramid5_8C_source.html#l00108">libMesh::Pyramid5::build_side()</a>, <a class="el" href="face__inf__quad4_8C_source.html#l00166">libMesh::InfQuad4::build_side()</a>, <a class="el" href="face__inf__quad6_8C_source.html#l00111">libMesh::InfQuad6::build_side()</a>, <a class="el" href="cell__inf__hex8_8C_source.html#l00105">libMesh::InfHex8::build_side()</a>, <a class="el" href="cell__inf__prism6_8C_source.html#l00103">libMesh::InfPrism6::build_side()</a>, <a class="el" href="cell__inf__prism12_8C_source.html#l00104">libMesh::InfPrism12::build_side()</a>, <a class="el" href="cell__inf__hex16_8C_source.html#l00107">libMesh::InfHex16::build_side()</a>, <a class="el" href="cell__inf__hex18_8C_source.html#l00160">libMesh::InfHex18::build_side()</a>, <a class="el" href="cell__pyramid13_8C_source.html#l00118">libMesh::Pyramid13::build_side()</a>, <a class="el" href="cell__prism15_8C_source.html#l00132">libMesh::Prism15::build_side()</a>, <a class="el" href="cell__pyramid14_8C_source.html#l00122">libMesh::Pyramid14::build_side()</a>, <a class="el" href="cell__prism18_8C_source.html#l00177">libMesh::Prism18::build_side()</a>, <a class="el" href="dof__map_8C_source.html#l01676">libMesh::DofMap::clear_sparsity()</a>, <a class="el" href="xdr__cxx_8C_source.html#l00277">libMesh::Xdr::close()</a>, <a class="el" href="dof__map_8C_source.html#l01639">libMesh::DofMap::compute_sparsity()</a>, <a class="el" href="elem__cutter_8C_source.html#l00041">libMesh::ElemCutter::ElemCutter()</a>, <a class="el" href="xdr__cxx_8C_source.html#l00166">libMesh::Xdr::open()</a>, <a class="el" href="auto__ptr_8h_source.html#l00159">libMesh::AutoPtr&lt; libMesh::FETransformationBase&lt; OutputType &gt; &gt;::operator=()</a>, <a class="el" href="parallel__algebra_8h_source.html#l00058">libMesh::Parallel::StandardType&lt; TypeVector&lt; T &gt; &gt;::StandardType()</a>, <a class="el" href="parallel__algebra_8h_source.html#l00137">libMesh::Parallel::StandardType&lt; VectorValue&lt; T &gt; &gt;::StandardType()</a>, <a class="el" href="parallel__algebra_8h_source.html#l00216">libMesh::Parallel::StandardType&lt; Point &gt;::StandardType()</a>, and <a class="el" href="system__io_8C_source.html#l01799">libMesh::System::write_serialized_blocked_dof_objects()</a>.</p>
<div class="fragment"><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;  {</div>
<div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;    <span class="keywordflow">if</span> (p != <a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a>)</div>
<div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;      {</div>
<div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;        <span class="keyword">delete</span> <a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a>;</div>
<div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;        <a class="code" href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">_ptr</a> = p;</div>
<div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;      }</div>
<div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;  }</div>
<div class="ttc" id="classlibMesh_1_1AutoPtr_html_a7e8340fb4f4326ce8496a49f52980374"><div class="ttname"><a href="classlibMesh_1_1AutoPtr.html#a7e8340fb4f4326ce8496a49f52980374">libMesh::AutoPtr::_ptr</a></div><div class="ttdeci">Tp * _ptr</div><div class="ttdef"><b>Definition:</b> <a href="auto__ptr_8h_source.html#l00109">auto_ptr.h:109</a></div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a7e8340fb4f4326ce8496a49f52980374"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tp&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Tp* <a class="el" href="classlibMesh_1_1AutoPtr.html">libMesh::AutoPtr</a>&lt; Tp &gt;::_ptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The actual dumb pointer this class wraps. </p>

<p>Definition at line <a class="el" href="auto__ptr_8h_source.html#l00109">109</a> of file <a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a>.</p>

<p>Referenced by <a class="el" href="auto__ptr_8h_source.html#l00228">libMesh::AutoPtr&lt; libMesh::FETransformationBase&lt; OutputType &gt; &gt;::get()</a>, <a class="el" href="auto__ptr_8h_source.html#l00206">libMesh::AutoPtr&lt; libMesh::FETransformationBase&lt; OutputType &gt; &gt;::operator*()</a>, <a class="el" href="auto__ptr_8h_source.html#l00215">libMesh::AutoPtr&lt; libMesh::FETransformationBase&lt; OutputType &gt; &gt;::operator-&gt;()</a>, <a class="el" href="auto__ptr_8h_source.html#l00287">libMesh::AutoPtr&lt; libMesh::FETransformationBase&lt; OutputType &gt; &gt;::operator=()</a>, <a class="el" href="auto__ptr_8h_source.html#l00242">libMesh::AutoPtr&lt; libMesh::FETransformationBase&lt; OutputType &gt; &gt;::release()</a>, <a class="el" href="auto__ptr_8h_source.html#l00257">libMesh::AutoPtr&lt; libMesh::FETransformationBase&lt; OutputType &gt; &gt;::reset()</a>, and <a class="el" href="auto__ptr_8h_source.html#l00195">libMesh::AutoPtr&lt; libMesh::FETransformationBase&lt; OutputType &gt; &gt;::~AutoPtr()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="auto__ptr_8h_source.html">auto_ptr.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
generated by <a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a>
</small></address>
<!-- dynamic header stuff -->
<script type="text/javascript">
$(document).ready(function(){
  $(window).on('scroll',function() {
    var scrolltop = $(this).scrollTop();
    if(scrolltop >= 215) {
      $('#fixedbar').fadeIn(250);
    }
    else if(scrolltop <= 210) {
      $('#fixedbar').fadeOut(250);
    }
  });
});
</script>
<!-- Google Analytics stuff -->
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-24978333-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</body>
</html>
